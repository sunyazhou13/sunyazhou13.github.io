<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://www.sunyazhou.com</id><title>迈腾大队长</title><subtitle>嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者.</subtitle> <updated>2022-07-04T17:30:45+08:00</updated> <author> <name>孙亚洲</name> <uri>https://www.sunyazhou.com</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.sunyazhou.com" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 孙亚洲 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>合并两个有序数组</title><link href="https://www.sunyazhou.com/2022/07/mergesortarray/" rel="alternate" type="text/html" title="合并两个有序数组" /><published>2022-07-04T17:25:00+08:00</published> <updated>2022-07-04T17:30:45+08:00</updated> <id>https://www.sunyazhou.com/2022/07/mergesortarray/</id> <content src="https://www.sunyazhou.com/2022/07/mergesortarray/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给你两个按非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n ，分别表示nums1和nums2中的元素数目。 请你合并 nums2 到nums1中，使合并后的数组同样按非递减顺序排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组nums1中。为了应对这种情况，nums1的初始长度为m + n，其中前m个元素表示应合并的元素，后n个元素为 0，应忽略。nums2的长度为n。 示例1 1 2 3 4 5 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 ... </summary> </entry> <entry><title>二叉树的最近公共祖先</title><link href="https://www.sunyazhou.com/2022/07/commonancestor/" rel="alternate" type="text/html" title="二叉树的最近公共祖先" /><published>2022-07-04T17:12:00+08:00</published> <updated>2022-07-04T17:30:45+08:00</updated> <id>https://www.sunyazhou.com/2022/07/commonancestor/</id> <content src="https://www.sunyazhou.com/2022/07/commonancestor/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例1 1 2 3 4 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例2 1 2 3 4 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。... </summary> </entry> <entry><title>搜索旋转排序数组</title><link href="https://www.sunyazhou.com/2022/07/searchrotatearray/" rel="alternate" type="text/html" title="搜索旋转排序数组" /><published>2022-07-04T14:53:00+08:00</published> <updated>2022-07-04T17:30:45+08:00</updated> <id>https://www.sunyazhou.com/2022/07/searchrotatearray/</id> <content src="https://www.sunyazhou.com/2022/07/searchrotatearray/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 整数数组nums按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 示例1 1 2 3 输... </summary> </entry> <entry><title>二叉树的锯齿形层序遍历</title><link href="https://www.sunyazhou.com/2022/07/zigzaglevelorder/" rel="alternate" type="text/html" title="二叉树的锯齿形层序遍历" /><published>2022-07-04T14:19:00+08:00</published> <updated>2022-07-04T17:30:45+08:00</updated> <id>https://www.sunyazhou.com/2022/07/zigzaglevelorder/</id> <content src="https://www.sunyazhou.com/2022/07/zigzaglevelorder/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给你二叉树的根节点root，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 示例1 1 2 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[20,9],[15,7]] 示例2 1 2 输入：root = [1] 输出：[[1]] 示例3 1 2 输入：root = [] 输出：[] 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 struct TreeNode { int val; ... </summary> </entry> <entry><title>环形链表</title><link href="https://www.sunyazhou.com/2022/07/cyclelinktable/" rel="alternate" type="text/html" title="环形链表" /><published>2022-07-04T14:09:00+08:00</published> <updated>2022-07-04T17:30:45+08:00</updated> <id>https://www.sunyazhou.com/2022/07/cyclelinktable/</id> <content src="https://www.sunyazhou.com/2022/07/cyclelinktable/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给你一个链表的头节点head，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数pos来表示链表尾连接到链表中的位置（索引从 0 开始）. 注意：pos不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回true。 否则，返回false。 示例1 1 2 3 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例2 1 2 3 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例3 1 2 3 输入：he... </summary> </entry> </feed>
