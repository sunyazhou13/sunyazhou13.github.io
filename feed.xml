<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://www.sunyazhou.com</id><title>迈腾大队长</title><subtitle>嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者.</subtitle> <updated>2022-07-04T14:36:11+08:00</updated> <author> <name>孙亚洲</name> <uri>https://www.sunyazhou.com</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.sunyazhou.com" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 孙亚洲 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>二叉树的锯齿形层序遍历</title><link href="https://www.sunyazhou.com/2022/07/zigzaglevelorder/" rel="alternate" type="text/html" title="二叉树的锯齿形层序遍历" /><published>2022-07-04T14:19:00+08:00</published> <updated>2022-07-04T14:36:11+08:00</updated> <id>https://www.sunyazhou.com/2022/07/zigzaglevelorder/</id> <content src="https://www.sunyazhou.com/2022/07/zigzaglevelorder/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给你二叉树的根节点root，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 示例1 1 2 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[20,9],[15,7]] 示例2 1 2 输入：root = [1] 输出：[[1]] 示例3 1 2 输入：root = [] 输出：[] 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 struct TreeNode { int val; ... </summary> </entry> <entry><title>环形链表</title><link href="https://www.sunyazhou.com/2022/07/cyclelinktable/" rel="alternate" type="text/html" title="环形链表" /><published>2022-07-04T14:09:00+08:00</published> <updated>2022-07-04T14:36:11+08:00</updated> <id>https://www.sunyazhou.com/2022/07/cyclelinktable/</id> <content src="https://www.sunyazhou.com/2022/07/cyclelinktable/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给你一个链表的头节点head，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数pos来表示链表尾连接到链表中的位置（索引从 0 开始）. 注意：pos不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回true。 否则，返回false。 示例1 1 2 3 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例2 1 2 3 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例3 1 2 3 输入：he... </summary> </entry> <entry><title>二叉树的层序遍历</title><link href="https://www.sunyazhou.com/2022/07/binarytreelevelorder/" rel="alternate" type="text/html" title="二叉树的层序遍历" /><published>2022-07-04T10:10:00+08:00</published> <updated>2022-07-04T14:36:11+08:00</updated> <id>https://www.sunyazhou.com/2022/07/binarytreelevelorder/</id> <content src="https://www.sunyazhou.com/2022/07/binarytreelevelorder/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给你二叉树的根节点root，返回其节点值的层序遍历.（即逐层地，从左到右访问所有节点）. 示例1 1 2 3 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 示例2 1 2 输入：root = [1] 输出：[[1]] 示例3 1 2 输入：root = [] 输出：[] 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct TreeNode { int val; TreeNode *left; TreeNode *right; ... </summary> </entry> <entry><title>两数之和</title><link href="https://www.sunyazhou.com/2022/07/twosum/" rel="alternate" type="text/html" title="两数之和" /><published>2022-07-04T10:03:00+08:00</published> <updated>2022-07-04T14:36:11+08:00</updated> <id>https://www.sunyazhou.com/2022/07/twosum/</id> <content src="https://www.sunyazhou.com/2022/07/twosum/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值 target的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例1 1 2 3 4 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例2 1 2 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例3 1 2 输入：nums = [3,3], target = 6 输出：[0,1] Answer 1 2 3 4 5 6 7 8 9 10 11 ... </summary> </entry> <entry><title>合并两个有序链表</title><link href="https://www.sunyazhou.com/2022/07/mergetwolists/" rel="alternate" type="text/html" title="合并两个有序链表" /><published>2022-07-01T15:38:00+08:00</published> <updated>2022-07-04T14:36:11+08:00</updated> <id>https://www.sunyazhou.com/2022/07/mergetwolists/</id> <content src="https://www.sunyazhou.com/2022/07/mergetwolists/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例1 1 2 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例2 1 2 输入：l1 = [], l2 = [] 输出：[] 示例3 1 2 输入：l1 = [], l2 = [0] 输出：[0] Answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNo... </summary> </entry> </feed>
