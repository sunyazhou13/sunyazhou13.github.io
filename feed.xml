<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://www.sunyazhou.com</id><title>迈腾大队长</title><subtitle>嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者.</subtitle> <updated>2024-10-22T05:07:06+00:00</updated> <author> <name>孙亚洲</name> <uri>https://www.sunyazhou.com</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.sunyazhou.com" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 孙亚洲 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>iOS卡顿监控代码</title><link href="https://www.sunyazhou.com/2024/10/hangmonitor/" rel="alternate" type="text/html" title="iOS卡顿监控代码" /><published>2024-10-22T05:01:00+00:00</published> <updated>2024-10-22T05:07:06+00:00</updated> <id>https://www.sunyazhou.com/2024/10/hangmonitor/</id> <content src="https://www.sunyazhou.com/2024/10/hangmonitor/" /> <author> <name>孙亚洲</name> </author> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或分享,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,感谢支持! 监控原理是注册runloop观察者，检测耗时，记录调用栈，上报后台分析。长时间卡顿后，若未进入下一个活跃状态，则标记为卡死崩溃上报。 以下是一个 iOS 卡死监控的代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98... </summary> </entry> <entry><title>UIImage镜像</title><link href="https://www.sunyazhou.com/2024/10/uiimagemirror/" rel="alternate" type="text/html" title="UIImage镜像" /><published>2024-10-16T01:46:00+00:00</published> <updated>2024-10-22T05:07:06+00:00</updated> <id>https://www.sunyazhou.com/2024/10/uiimagemirror/</id> <content src="https://www.sunyazhou.com/2024/10/uiimagemirror/" /> <author> <name>孙亚洲</name> </author> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或分享,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,感谢支持! 示例代码记录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @implementation UIImage (MTMirrorImage) - (nullable UIImage *)mirrorImageHorizontally { if (self == nil) { return nil; } CGSize size = self.size; CGRect rect = CGRectMake(0, 0, size.width, size... </summary> </entry> <entry><title>CFNotification进程间通讯</title><link href="https://www.sunyazhou.com/2024/09/cfnotificationprocesscommunication/" rel="alternate" type="text/html" title="CFNotification进程间通讯" /><published>2024-09-02T12:08:00+00:00</published> <updated>2024-10-22T05:07:06+00:00</updated> <id>https://www.sunyazhou.com/2024/09/cfnotificationprocesscommunication/</id> <content src="https://www.sunyazhou.com/2024/09/cfnotificationprocesscommunication/" /> <author> <name>孙亚洲</name> </author> <category term="iOS" /> <category term="SwiftUI" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或分享,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,感谢支持! 背景 在iOS开发中，应用扩展（App Extensions）与其容器应用（Containing App）在不同的进程中运行。这种隔离带来了一个挑战：当你需要在主应用和它的扩展之间进行通信时。虽然NSNotificationCenter是在同一应用内传递数据给不同视图控制器的常见选择，但在处理进程间通信时就力不从心了。你是否曾想过如何在主应用及其扩展之间传递数据？Darwin通知为这一场景提供了一个强大的解决方案。在本文中，我们将探讨如何实现一个Darwin通知管理器，并使用它来促进主应用和其扩展之间的实时数据传输。 什么是Darwin通知（又称CFNotificationCenterGetDarwinNotifyCenter）？ CFNotificationCenterGetDarwinNotifyCenter是苹果Core F... </summary> </entry> <entry><title>在Objective-C中多层block嵌套时如何使用weak self和strong self</title><link href="https://www.sunyazhou.com/2024/08/multiblockembedded/" rel="alternate" type="text/html" title="在Objective-C中多层block嵌套时如何使用weak self和strong self" /><published>2024-08-22T12:32:00+00:00</published> <updated>2024-10-22T05:07:06+00:00</updated> <id>https://www.sunyazhou.com/2024/08/multiblockembedded/</id> <content src="https://www.sunyazhou.com/2024/08/multiblockembedded/" /> <author> <name>孙亚洲</name> </author> <category term="iOS" /> <category term="SwiftUI" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或分享,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,感谢支持! 开发中遇到的问题 在Objective-C中如何 正确的使用 block的 weakSelf和 strongSelf在 多层blokc 在Objective-C中，weak self和strong self用于解决循环引用问题。当你在一个方法中使用了self作为block的参数时，你需要使用__weak typeof(self) weakSelf = self;来创建一个弱引用，以避免循环引用。然后在block内部，你可以使用strongSelf来获取一个强引用。 以下是一个示例，展示了如何在三层嵌套的方法中使用weak self和strong self： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32... </summary> </entry> <entry><title>NSIntegerMax整数溢出问题记录</title><link href="https://www.sunyazhou.com/2024/08/dispatchafternsintegermax/" rel="alternate" type="text/html" title="NSIntegerMax整数溢出问题记录" /><published>2024-08-19T01:50:00+00:00</published> <updated>2024-10-22T05:07:06+00:00</updated> <id>https://www.sunyazhou.com/2024/08/dispatchafternsintegermax/</id> <content src="https://www.sunyazhou.com/2024/08/dispatchafternsintegermax/" /> <author> <name>孙亚洲</name> </author> <category term="iOS" /> <category term="SwiftUI" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或分享,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,感谢支持! 开发中遇到的问题 最近开发 测试同学提了一个bug, 首页底部tab的气泡一闪而过瞬间消失,认真追踪代码后发现,配置后台下发-1,客户端同学把这个-1替换成了NSIntegerMax 如下代码,是控制一个气泡 从展示到结束的代码实现. 1 2 3 4 5 NSInteger delaySeconds = NSIntegerMax; NSLog(@"%@,展示前,%zd",[NSDate date],delaySeconds); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delaySeconds * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@"%@,展示后,%zd",[NSDate da... </summary> </entry> </feed>
