<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://www.sunyazhou.com</id><title>迈腾大队长</title><subtitle>嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者.</subtitle> <updated>2022-07-04T18:09:36+08:00</updated> <author> <name>孙亚洲</name> <uri>https://www.sunyazhou.com</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.sunyazhou.com" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 孙亚洲 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>二叉树的前、中、后序遍历</title><link href="https://www.sunyazhou.com/2022/07/binarytreeorder/" rel="alternate" type="text/html" title="二叉树的前、中、后序遍历" /><published>2022-07-04T17:58:00+08:00</published> <updated>2022-07-04T18:09:36+08:00</updated> <id>https://www.sunyazhou.com/2022/07/binarytreeorder/</id> <content src="https://www.sunyazhou.com/2022/07/binarytreeorder/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给你二叉树的根节点root，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 示例1 1 2 输入：root = [1,null,2,3] 输出：[1,2,3] 示例2 1 2 输入：root = [] 输出：[] 示例3 1 2 输入：root = [1] 输出：[1] 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 struct TreeNode { int val; TreeNode *left; TreeNode *right; ... </summary> </entry> <entry><title>岛屿数量</title><link href="https://www.sunyazhou.com/2022/07/islandscount/" rel="alternate" type="text/html" title="岛屿数量" /><published>2022-07-04T17:50:00+08:00</published> <updated>2022-07-04T18:09:36+08:00</updated> <id>https://www.sunyazhou.com/2022/07/islandscount/</id> <content src="https://www.sunyazhou.com/2022/07/islandscount/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例1 1 2 3 4 5 6 7 8 输入：grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"], ["1","1","0","0","0"], ["0","0","0","0","0"] ] 输出：1 示例2 1 2 3 4 5 6 7 8 输入：grid = [ ["1","1","0","0","0"], ["1","1","0","0","0"], ["0","0","1","0","0... </summary> </entry> <entry><title>最长回文子串</title><link href="https://www.sunyazhou.com/2022/07/longestpalindrome/" rel="alternate" type="text/html" title="最长回文子串" /><published>2022-07-04T17:41:00+08:00</published> <updated>2022-07-04T18:09:36+08:00</updated> <id>https://www.sunyazhou.com/2022/07/longestpalindrome/</id> <content src="https://www.sunyazhou.com/2022/07/longestpalindrome/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给你一个字符串s，找到s中最长的回文子串。 示例1 1 2 3 输入：s = "babad" 输出："bab" 解释："aba" 同样是符合题意的答案。 示例2 1 2 输入：s = "cbbd" 输出："bb" 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //中心扩展算法 class Solution { public: pair&amp;lt;int, int&amp;gt; expandAroundCenter(const string&amp;amp; s, int left, int right) { while (left &amp;gt;= 0 &amp;amp;&amp;amp; ... </summary> </entry> <entry><title>合并两个有序数组</title><link href="https://www.sunyazhou.com/2022/07/mergesortarray/" rel="alternate" type="text/html" title="合并两个有序数组" /><published>2022-07-04T17:25:00+08:00</published> <updated>2022-07-04T18:09:36+08:00</updated> <id>https://www.sunyazhou.com/2022/07/mergesortarray/</id> <content src="https://www.sunyazhou.com/2022/07/mergesortarray/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给你两个按非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n ，分别表示nums1和nums2中的元素数目。 请你合并 nums2 到nums1中，使合并后的数组同样按非递减顺序排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组nums1中。为了应对这种情况，nums1的初始长度为m + n，其中前m个元素表示应合并的元素，后n个元素为 0，应忽略。nums2的长度为n。 示例1 1 2 3 4 5 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 ... </summary> </entry> <entry><title>二叉树的最近公共祖先</title><link href="https://www.sunyazhou.com/2022/07/commonancestor/" rel="alternate" type="text/html" title="二叉树的最近公共祖先" /><published>2022-07-04T17:12:00+08:00</published> <updated>2022-07-04T18:09:36+08:00</updated> <id>https://www.sunyazhou.com/2022/07/commonancestor/</id> <content src="https://www.sunyazhou.com/2022/07/commonancestor/" /> <author> <name>孙亚洲</name> </author> <category term="algorithm" /> <summary> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 如题 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例1 1 2 3 4 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例2 1 2 3 4 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。... </summary> </entry> </feed>
