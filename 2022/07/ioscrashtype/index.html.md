---
layout: post
title: iOS中的崩溃类型
date: 2022-07-11 09:53 +0800
categories: [iOS, Swift]
tags: [iOS, Swift, Objective-C, skills]
typora-root-url: ..

---

![](/assets/images/20220711iOSCrashType/kernel.webp)

# 前言

本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或分享,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,感谢支持!

## 崩溃类型

崩溃通常是指操作系统向正在运行的程序发送的信号，所以我们在查看崩溃日志时，常常看到如下错误摘要：Application received signal SIGSEGV。一般来说，常见的崩溃类型有以下几种：

### 1.`EXC_BAD_ACCESS`

野指针引起的崩溃，访问了一个已经释放的内存而导致，向已经释放的对象或向它发送消息时，`EXC_BAD_ACCESS`就会出现。造成`EXC_BAD_ACCESS`最常见的原因是，在初始化方法中初始化变量时用错了所有权修饰符，这会导致对象过早地被释放。举个例子，在`viewDidLoad`方法中为`UIViewController`创建了一个包含元素的`NSArray`，却将该数组的所有权修饰符设成了`assign`而不是`strong`。现在在`viewWillAppear`中，若要访问已经释放掉的对象时，就会得到名为`EXC_BAD_ACCESS`的崩溃。

这个崩溃发生时，查看崩溃日志，却往往得不到有用的栈信息。还好，有一个方法用来解决这个问题：`NSZombieEnabled`。

这是一个环境变量，用来调试与内存相关的问题，跟踪对象的释放过程。启用了`NSZombieEnabled`的话，它会用一个僵尸实现来替换你的默认的`dealloc`实现，也就是在引用计数降到0时，该僵尸实现会将该对象转换成僵尸对象。僵尸对象的作用是在你向它发送消息时，它会显示一段日志并自动跳入调试器。

所以，当在应用中启用`NSZombie`而不是让应用直接崩溃时，一个错误的内存访问就会变成一条无法识别的消息发送给僵尸对象。僵尸对象会显示接收到的消息，然后跳入调试器，这样你就可以查看到底哪时出了问题。 可以在`Xcode`的`scheme`页面中设置`NSZombieEnabled`环境变量。点击`Product`的`Edit Scheme`打开该页面，然后勾选`Enable Zombie Objects`复选框，如图所示：

![](/assets/images/20220711iOSCrashType/1.webp)

僵尸在RAC出现以前作用很大。但自从有了ARC，如果你在对象的所有权方面比较注意，那么通常不会碰到内存相关的崩溃。


### 2.`SIGSEGV`

段错误信息（`SIGSEGV`）是操作系统产生的一个更严重的问题。当硬件出现错误、访问不可读的内存地址或向受保护的内存地址写入数据时，就会发生这个错误。

硬件错误这一情况并不常见。当要读取保存在`RAM`中的数据，而该位置的`RAM`硬件有问题时，你会收到`SIGSEGV`。`SIGSEGV`更多是出现在后两种情况。默认情况下，代码页不允许进行写操作。当应用中的某个指针指向代码页并试图修改指向位置的值时，你会收到`SIGSEGV`。当要读取一个指针的值，而它被初始化成指向无效内存地址的垃圾值时，你也会收到`SIGSEGV`。

`SIGSEGV`错误调试起来更困难，而导致`SIGSEGV`的最常见原因是不正确的类型转换。要避免过度使用指针或尝试手动修改指针来读取私有数据结构。如果你那样做了，而在修改指针时没有注意内存对齐和填充问题，就会收到`SIGSEGV`。

### 3.`SIGBUS`

总线错误信号（`SIGBUG`）代表无效内存访问，即访问的内存是一个无效的内存地址。也就是说，那个地址指向的位置根本不是物理内存地址（它可能是某个硬件芯片的地址）。

### 4.`SIGTRAP`

`SIGTRAP`代表陷阱信号。它并不是一个真正的崩溃信号。它会在处理器执行trap指令发送。`LLDB`调试器通常会处理此信号，并在指定的断点处停止运行。如果你收到了原因不明的`SIGTRAP`，先清除上次的输出，然后重新进行构建通常能解决这个问题。

### 5.`EXC_ARITHETIC`

当要除零时，应用会收到`EXC_ARITHMETIC`信号。这个错误应该很容易解决。

``` objc
int result = 10/0;  //0不能作为除数 否则crash
``` 

### 6.`SIGILL`

`SIGILL`代表`signal illegal instruction`(非法指令信号)。当在处理器上执行非法指令时，它就会发生。执行非法指令是指，将函数指针会给另外一个函数时，该函数指针由于某种原因是坏的，指向了一段已经释放的内存或是一个数据段。有时你收到的是`EXC_BAD_INSTRUCTION`而不是`SIGILL`，虽然它们是一回事，不过`EXC_*`等同于此信号不依赖体系结构。

### 7. `SIGABRT`

`SIGABRT`代表`SIGNAL ABORT`（中止信号）。当操作系统发现不安全的情况时，它能够对这种情况进行更多的控制；必要的话，它能要求进程进行清理工作。在调试造成此信号的底层错误时，并没有什么妙招。`Cocos2d`或`UIKit`等框架通常会在特定的前提条件没有满足或一些糟糕的情况出现时调用C函数`abort`（由它来发送此信号）。当`SIGABRT`出现时，控制台通常会输出大量的信息，说明具体哪里出错了。由于它是可控制的崩溃，所以可以在`LLDB`控制台上键入`bt`命令打印出回溯信息。

### 8.`看门狗超时`

这种崩溃通常比较容易分辨，因为错误码是固定的0x8badf00d。在iOS上，它经常出现在执行一个同步网络调用而阻塞主线程的情况。因此，永远不要进行同步网络调用。

# 总结

crash log类型不限于上述这些,结合实际跟踪将会找到影响的崩溃信息.这里只做参考使用. 如果想了解更加详细请参考gnu的[源码](http://fxr.watson.org/fxr/source/osfmk/mach/exception_types.h?v=xnu-2050.18.24)

[参考](https://zhuanlan.zhihu.com/p/269371735)  
[理解 iOS 异常类型](https://juejin.cn/post/6844903866128039944)  
[浅谈 iOS 中的 Crash 捕获与防护
](http://shevakuilin.com/ios-crashprotection/)