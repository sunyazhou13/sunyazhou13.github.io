<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>阿里、字节：一套高效的iOS面试题之Block | 迈腾大队长</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="阿里、字节：一套高效的iOS面试题之Block | 迈腾大队长">
    <meta name="twitter:description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="阿里、字节：一套高效的iOS面试题之Block | 迈腾大队长">
    <meta property="og:description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    
    <meta name="author" content="sunyazhou">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//apps.bdimg.com/libs/fontawesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/favicon.ico">
    

    
    <link rel="apple-touch-icon" href="/images/logo.jpg">
    
    
    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="迈腾大队长" href="/atom.xml">
    

    <link rel="canonical" href="https://www.sunyazhou.com/2020/09/17/20200917Block/"/>

    
    <link rel="author" href="https://plus.google.com/107423989995616646161"/>
    
    <!-- fancybox support -->
    
        <script src="/lib/jquery-3.3.1.min.js"></script>
        <link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.min.css">
        <script src="/lib/fancybox/dist/jquery.fancybox.min.js"></script>
        <script src="/js/wrapImage.js"></script>
    
</head>

<body class="home-template no-js">

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 迈腾大队长 的主页"><img src="/images/logo2.jpg" width="80" alt="迈腾大队长 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 迈腾大队长">迈腾大队长</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">不断学习, 与时俱进. - 始于2017</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">文章</a></li>
            
              <li class="navigation__item"><a href="/archives">归档</a></li>
            
              <li class="navigation__item"><a href="/projects">作品</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/sunyazhou13" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/sunyazhou13" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  
  <li class="navigation__item">
    <a href="https://plus.google.com/107423989995616646161" title="Google+" target="_blank">
      <i class='social fa fa-google-plus-square'></i>
      <span class="label">Google+</span>
    </a>
  </li>


<!-- Facebook -->


<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/sunyazhou" title="上Twitter找我" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

<!-- instagram -->


  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>


  <li class="navigation__item">
    <a href="mailto:sunyazhou13@163.com" title="邮件联系我" target="_blank">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-red"></div>
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2020-09-17T06:34:10.000Z" class="post-list__meta--date date">2020-09-17</time>
 &#8226; <span class="post-meta__tags tags">分类&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/iOS面试题/">iOS面试题</a>

</span>
    </div>
    <h1 class="post-title">阿里、字节：一套高效的iOS面试题之Block</h1>
  </header>

  <section class="post">
    <p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="block">block</h2>
<p>这一篇我们来研究一下objc的block并回答一下面试中的下列问题:</p>
<p>1.block的内部实现，结构体是什么样的<br>
2.block是类吗，有哪些类型<br>
3.一个int变量被 <code>__block</code> 修饰与否的区别？block的变量截获<br>
4.block在修改NSMutableArray，需不需要添加<code>__block</code><br>
5.怎么进行内存管理的<br>
6.block可以用strong修饰吗<br>
7.解决循环引用时为什么要用<code>__strong</code>、<code>__weak</code>修饰<br>
8.<code>block</code>发生<code>copy</code>时机<br>
9.<code>Block</code>访问对象类型的<code>auto</code>变量时，在<code>ARC</code>和<code>MRC</code>下有什么区别</p>
<p>在回答所有问题之前我们需要了解一些block背景相关的知识. 如下:</p>
<p>- 如何查看Block的内部实现,也就是说转换成背后真正的c/c++代码的block是什么样的？以及转换格式或者原理等.<br>
-关于变量的作用域</p>
<h4 id="objective-c-转-c的方法">Objective-C 转 C++的方法</h4>
<p>下面我写了个示例<code>TestClass.m</code>类其中block代码如下</p>
<p>OC代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestClass</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testMethods &#123;</span><br><span class="line">    <span class="keyword">void</span> (^blockA)(<span class="keyword">int</span> a) = ^(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (blockA) &#123;</span><br><span class="line">        blockA(<span class="number">1990</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>经过上述转换操作我们在TestClass.cpp中最下面发现如下代码</p>
<p>C++代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @interface TestClass ()</span></span><br><span class="line"><span class="comment">/* @end */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @implementation TestClass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __TestClass__testMethods_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0* Desc;</span><br><span class="line">  __TestClass__testMethods_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestClass__testMethods_block_func_0(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0 *__cself, <span class="keyword">int</span> a) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_wx_b8tcry0j24dbhr7zlzjq3v340000gn_T_TestClass_ee18d3_mi_0,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __TestClass__testMethods_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestClass_testMethods(TestClass * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">void</span> (*blockA)(<span class="keyword">int</span> a) = ((<span class="keyword">void</span> (*)(<span class="keyword">int</span>))&amp;__TestClass__testMethods_block_impl_0((<span class="keyword">void</span> *)__TestClass__testMethods_block_func_0, &amp;__TestClass__testMethods_block_desc_0_DATA));</span><br><span class="line">    <span class="keyword">if</span> (blockA) &#123;</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *, <span class="keyword">int</span>))((__block_impl *)blockA)-&gt;FuncPtr)((__block_impl *)blockA, <span class="number">1990</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码生成是通过如下操作:</p>
<p>打开终端，cd到TestClass.m所在文件夹,使用如下命令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc TestClass.m</span><br></pre></td></tr></table></figure>
<p>就会在当前文件夹内自动生成对应的TestClass.cpp文件</p>
<blockquote>
<p>注意: 如果提示clang没有的话 需要安装, 输入如下</p>
</blockquote>
<p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install clang-format</span><br><span class="line">或者</span><br><span class="line">brew link clang-forma</span><br><span class="line">然后输入 下面命令测试是否好使</span><br><span class="line">clang-format --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></p>
<p>通过上述代码我们发现Block的其实是一个结构体类型</p>
<p>底层实现 会根据 <code>__</code><strong>类名</strong><code>__</code><strong>方法名</strong><code>_</code>block<code>_</code>impl<code>_</code><strong>下标</strong> (0代表这个方法或者这个类中第0个block 下面如果还有将会 第1个block 第2个...)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __类名__方法名_block_impl_下标</span><br></pre></td></tr></table></figure>
<h4 id="关于变量的作用域">关于变量的作用域</h4>
<p>c语言的函数中可能使用的参数变量种类</p>
<ul>
<li>参数类型</li>
<li>自动变量(局部变量)</li>
<li>静态变量(静态局部变量)</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>由于存储区域特殊,这其中有三种变量是可以在任何时候以任何状态调用的.</p>
<ul>
<li>静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>而其他两种,则是有各自相应的作用域,超过作用域后,会被销毁.</p>
<hr>
<h3 id="block的内部实现结构体是什么样的">1.block的内部实现，结构体是什么样的</h3>
<p>看了上面的背景知识我们来回到一下这个问题</p>
<p>block的内部实现如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __TestClass__testMethods_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl; <span class="comment">//成员变量</span></span><br><span class="line">  <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0* Desc; <span class="comment">//desc 结构体声明</span></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="comment">// fp 函数指针</span></span><br><span class="line">  <span class="comment">// desc 静态全局变量初始化的 __main_block_desc_ 结构体实例指针</span></span><br><span class="line">  <span class="comment">// flags block 的负载信息(引用计数和类型信息),按位存储.</span></span><br><span class="line">  __TestClass__testMethods_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将来被调用的block内部的代码：block值被转换为C的函数代码</span></span><br><span class="line"><span class="comment">//这里，*__cself 是指向Block的值的指针，也就相当于是Block的值它自己(相当于C++里的this，</span></span><br><span class="line">OC里的<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">//__cself 是指向__TestClass__testMethods_block_impl_0结构体实现的指针</span></span><br><span class="line"><span class="comment">//Block结构体就是__TestClass__testMethods_block_impl_0结构体.Block的值就是通过__TestClass__testMethods_block_impl_0构造出来的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestClass__testMethods_block_func_0(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0 *__cself, <span class="keyword">int</span> a) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_wx_b8tcry0j24dbhr7zlzjq3v340000gn_T_TestClass_9f58f7_mi_0,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __TestClass__testMethods_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestClass_testMethods(TestClass * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">void</span> (*blockA)(<span class="keyword">int</span> a) = ((<span class="keyword">void</span> (*)(<span class="keyword">int</span>))&amp;__TestClass__testMethods_block_impl_0((<span class="keyword">void</span> *)__TestClass__testMethods_block_func_0, &amp;__TestClass__testMethods_block_desc_0_DATA));</span><br><span class="line">    <span class="keyword">if</span> (blockA) &#123;</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *, <span class="keyword">int</span>))((__block_impl *)blockA)-&gt;FuncPtr)((__block_impl *)blockA, <span class="number">1990</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看得出来<code>__TestClass__testMethods_block_impl_0</code>有3个部分组成</p>
<ul>
<li><p>impl 函数指针指向<code>__TestClass__testMethods_block_impl_0</code></p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;  <span class="comment">//今后版本升级所需的区域</span></span><br><span class="line">  <span class="keyword">void</span> *FuncPtr; <span class="comment">//函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Desc 指向<code>__TestClass__testMethods_block_impl_0</code>的Desc指针,用于描述当前这个block的附加信息的，包括结构体的大小等等信息.</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 &#123;</span><br><span class="line">  size_t reserved; <span class="comment">//今后升级版本所需区域</span></span><br><span class="line">  size_t Block_size; <span class="comment">//block的大小</span></span><br><span class="line">&#125; __TestClass__testMethods_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>__TestClass__testMethods_block_impl_0()</code>构造函数,也就是该block的具体实现</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__TestClass__testMethods_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">   impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">   impl.Flags = flags;</span><br><span class="line">   impl.FuncPtr = fp;</span><br><span class="line">   Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此结构体中</p>
<ul>
<li>isa指针保持这所属类的结构体的实例的指针.</li>
<li><code>struct __TestClass__testMethods_block_impl_0</code>相当于Objective-C类对象的结构体</li>
<li><code>_NSConcreteStackBlock</code>相当于Block的结构体实例,也就是说<strong>block其实就是Objective-C对于闭包的对象实现</strong></li>
</ul></li>
</ul>
<p>讲到这里block的内部实现你看懂了吗?结构体是什么样的你记住了吗? 其实看着繁琐 细心观察代码会发现还是比较简单的.</p>
<h3 id="block是类吗有哪些类型">2.block是类吗，有哪些类型?</h3>
<p>block也算是个类,因为它有isa指针,block.isa的类型包括</p>
<ul>
<li>_NSConcreteGlobalBlock 跟全局变量一样,设置在程序的数据区域(.data)中</li>
<li>_NSConcreteStackBlock栈上(前面讲的都是栈上的 block)</li>
<li>_NSConcreteMallocBlock 堆上</li>
</ul>
<blockquote>
<p>这个isa可以按位运算</p>
</blockquote>
<h3 id="一个int变量被-__block-修饰与否的区别block的变量截获">3.一个int变量被 <code>__block</code> 修饰与否的区别？block的变量截获</h3>
<h4 id="被__block-修饰与否的区别">被<code>__block</code> 修饰与否的区别</h4>
<p>用一段示例代码来解答这个问题吧:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">PrintTwoIntBlock block = ^()&#123;</span><br><span class="line">    a -= <span class="number">10</span>;</span><br><span class="line">    printf(<span class="string">"%d, %d\n"</span>,a,b);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">block();<span class="comment">//0 20</span></span><br><span class="line">    </span><br><span class="line">a += <span class="number">20</span>;</span><br><span class="line">b += <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">printf(<span class="string">"%d, %d\n"</span>,a,b);<span class="comment">//20 50</span></span><br><span class="line">    </span><br><span class="line">block();/<span class="number">10</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>通过<code>__block</code>修饰<code>int</code> <code>a</code>,block体中对这个变量的引用是指针拷贝,它会作为block结构体构造参数传入到结构体中且复制这个变量的指针引用，从而达到可以修改变量的作用.</p>
<p><code>int</code> <code>b</code>没有被<code>__block</code>修饰,block内部对<code>b</code>是值copy.所以在block内部修改<code>b</code>不影响外部b的变化.</p>
<h4 id="block的变量截获">block的变量截获</h4>
<p>通过如下代码我们来观察要一下变量的捕获</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    blk = [^(<span class="keyword">id</span> object)&#123;</span><br><span class="line">        [array addObject:object];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>,[array count]);</span><br><span class="line">    &#125; <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);</span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);</span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);</span><br></pre></td></tr></table></figure>
<p>输出打印</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">block_demo[28963:1629127] array count = 1</span><br><span class="line">block_demo[28963:1629127] array count = 2</span><br><span class="line">block_demo[28963:1629127] array count = 3</span><br></pre></td></tr></table></figure>
<p>我们把上面的代码翻译成C++看下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  id <span class="built_in">array</span>;<span class="comment">//截获的对象</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Objc中，C结构体里不能含有被<code>__strong</code>修饰的变量，因为编译器不知道应该何时初始化和废弃C结构体。但是Objc的运行时库能够准确把握<code>Block</code>从栈复制到堆，以及堆上的block被废弃的时机，在实现上是通过<code>__TestClass__testMethods_block_copy_0</code>函数和<code>__TestClass__testMethods_block_dispose_0</code>函数进行的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestClass__testMethods_block_copy_0(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0*dst, <span class="keyword">struct</span> __TestClass__testMethods_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;array, (<span class="keyword">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestClass__testMethods_block_dispose_0(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_Block_object_assign</code>相当于retain操作,将对象赋值在对象类型的结构体成员变量中.<br>
</li>
<li><code>_Block_object_dispose</code>相当于release操作.</li>
</ul>
<p>这两个函数调用的时机是在什么时候呢？</p>
<table>
<thead>
<tr class="header">
<th>函数</th>
<th>被调用时机</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__TestClass__testMethods_block_copy_0</code></td>
<td>从栈复制到堆时</td>
</tr>
<tr class="even">
<td><code>__TestClass__testMethods_block_dispose_0</code></td>
<td>堆上的Block被废弃时</td>
</tr>
</tbody>
</table>
<h5 id="什么时候栈上的block会被复制到堆呢">什么时候栈上的Block会被复制到堆呢？</h5>
<ul>
<li>调用block的copy函数时。<br>
</li>
<li>Block作为函数返回值返回时。<br>
</li>
<li>将Block赋值给附有<code>__strong</code>修饰符id类型的类或者Block类型成员变量时。<br>
</li>
<li>方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。</li>
</ul>
<h5 id="什么时候block被废弃呢">什么时候Block被废弃呢？</h5>
<ul>
<li>堆上的Block被释放后,谁都不再持有Block时调用dispose函数。</li>
</ul>
<p>以上就是变量被block捕获的内容</p>
<hr>
<h3 id="block在修改nsmutablearray需不需要添加__block">4.<code>block</code>在修改<code>NSMutableArray</code>，需不需要添加<code>__block</code></h3>
<ul>
<li>如修改<code>NSMutableArray</code>的存储内容的话,是不需要添加<code>__block</code>修饰的。</li>
<li>如修改<code>NSMutableArray</code>对象的本身,那必须添加<code>__block</code>修饰。</li>
</ul>
<h3 id="怎么进行内存管理的">5.怎么进行内存管理的?</h3>
<p>在上面Block的构造函数<code>__TestClass__testMethods_block_impl_0</code>中的isa指针指向的是&amp;_NSConcreteStackBlock，它表示当前的Block位于栈区中.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">block内存操作</th>
<th style="text-align: center;">存储域/存储位置</th>
<th style="text-align: center;">copy操作的影响</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">_NSConcreteGlobalBlock</td>
<td style="text-align: center;">程序的数据区域</td>
<td style="text-align: center;">什么也不做</td>
</tr>
<tr class="even">
<td style="text-align: center;">_NSConcreteStackBlock</td>
<td style="text-align: center;">栈</td>
<td style="text-align: center;">从栈拷贝到堆</td>
</tr>
<tr class="odd">
<td style="text-align: center;">_NSConcreteMallocBlock</td>
<td style="text-align: center;">堆</td>
<td style="text-align: center;">引用计数增加</td>
</tr>
</tbody>
</table>
<ul>
<li>全局Block:<code>_NSConcreteGlobalBlock</code>的结构体实例设置在程序的数据存储区，所以可以在程序的任意位置通过指针来访问，它的产生条件:
<ul>
<li>记述全局变量的地方有block语法时.</li>
<li>block不截获的自动变量.</li>
</ul>
<blockquote>
<p>以上两个条件只要满足一个就可以产生全局Block. <a href="https://juejin.im/post/6844903474312773646#heading-13" target="_blank" rel="noopener">参考</a></p>
</blockquote></li>
<li>栈Block:<code>_NSConcreteStackBlock</code>在生成Block以后，如果这个Block不是全局Block,那它就是栈Block,生命周期在其所属的变量作用域内.(也就是说如果销毁取决于所属的变量作用域).如果Block变量和<code>__block</code>变量复制到了堆上以后，则不再会受到变量作用域结束的影响了，因为它变成了堆Block.<br>
</li>
<li>堆Block:<code>_NSConcreteMallocBlock</code>将栈block复制到堆以后，block结构体的isa成员变量变成了<code>_NSConcreteMallocBlock</code>。</li>
</ul>
<h3 id="block可以用strong修饰吗">6.block可以用strong修饰吗?</h3>
<p>在ARC中可以，因为在ARC环境中的block只能在堆内存或全局内存中，因此不涉及到从栈拷贝到堆中的操作.</p>
<p>在MRC中不行,因为要有拷贝过程.如果执行copy用strong的话会crash, <code>strong</code>是ARC中引入的关键字.如果使用retain相当于忽视了block的copy过程.</p>
<h3 id="解决循环引用时为什么要用__strong__weak修饰">7.解决循环引用时为什么要用<code>__strong</code>、<code>__weak</code>修饰?</h3>
<p>首先因为block捕获变量的时候 结构体构造时传入了self,造成了默认的引用关系,所以一般在block外部对操作对象会加上<code>__weak</code>,在Block内部使用<code>__strong</code>修饰符的对象类型的自动变量，那么当Block从栈复制到堆的时候，该对象就会被Block所持有,但是持有的是我们上面加了<code>__weak</code>所以行程了比消此长的链条,刚好能解决block延迟销毁的时候对外部对象生命周期造成的影响.如果不这样做很容易造成循环引用.</p>
<h3 id="block发生copy时机">8.block发生copy时机?</h3>
<p>在ARC中,编译器将创建在栈中的block会自动拷贝到堆内存中,而block作为方法或函数的参数传递时,编译器不会做copy操作.</p>
<ul>
<li>调用block的copy函数时。<br>
</li>
<li>Block作为函数返回值返回时。<br>
</li>
<li>将Block赋值给附有<code>__strong</code>修饰符id类型的类或者Block类型成员变量时。<br>
</li>
<li>方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。</li>
</ul>
<h3 id="block访问对象类型的auto变量时在arc和mrc下有什么区别">9.Block访问对象类型的auto变量时，在ARC和MRC下有什么区别?</h3>
<p>ARC下会对这个对象强引用，MRC下不会</p>
<p><a href="https://juejin.im/post/6844903474312773646" target="_blank" rel="noopener">详细请参考</a></p>

  </section>

</article>


    <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           ↑<br>
           欣赏此文？求鼓励，求支持！
        </span>
        <br>
    </div>  
    <div id="donate_guide" class="donate_bar center hidden" >
        <!-- 方式一： 
            ![](/img/Alipay.jpg)
            ![](/img/WeChatpay.jpg)
        -->
        <!-- 方式二；
            step1：在_config.yml中添加配置
                Alipay: /img/Alipay.jpg
                WeChatpay: /img/WeChatpay.jpg
            step2：此处两张图片的路径分别设置为如下
                <img src="undefined"
                <img src="undefined"
        -->
        <!-- 支付宝打赏图案 -->
        <img src="/images/Alipay.jpg" alt="支付宝打赏">
        <!-- 微信打赏图案 -->
        <img src="/images/WeChatpay.jpg" alt="微信打赏">
    </div>
    <script type="text/javascript">
        document.getElementById('btn_donate').onclick = function(){
            $('#donate_board').addClass('hidden');
            $('#donate_guide').removeClass('hidden');
        }
    </script>
</div>

<! -- 添加捐赠图标 -->



<section class="read-more">
     
        
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2020/09/19/20200919GCD/" title="阿里、字节：一套高效的iOS面试题之多线程">阿里、字节：一套高效的iOS面试题之多线程</a></h2>
                <p class="excerpt">
                
                
前言
本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.
本篇我们来讲一下 阿里、字节：一
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-09-19T03:09:28.000Z" class="post-list__meta--date date">2020-09-19</time>
 &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/iOS面试题/">iOS面试题</a>

</span><a class="btn-border-small" href="/2020/09/19/20200919GCD/">继续阅读</a></div>

            </div>
        

        
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2020/09/02/20200902iOSinterviewAnswers/" title="阿里、字节：一套高效的iOS面试题之Runloop&amp;KVO">阿里、字节：一套高效的iOS面试题之Runloop&amp;KVO</a></h2>
                <p class="excerpt">
                
                
前言
本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.
前几篇我们一路讲了内存,关联对象
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-09-02T03:23:24.000Z" class="post-list__meta--date date">2020-09-02</time>
 &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/iOS面试题/">iOS面试题</a>

</span><a class="btn-border-small" href="/2020/09/02/20200902iOSinterviewAnswers/">继续阅读</a></div>

            </div>
        
   
</section>



  <div id="gitalk-container" style="padding: 0px 30px 0px 30px;"></div> 

  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script type="text/javascript">

  if(true){
    var gitalk = new Gitalk({
      clientID: '15c55ed469ea673ae332',
      clientSecret: '1801dbf9b1589c256260c85d779eb51d0cf40885',
      repo: 'gitment-comments',
      owner: 'sunyazhou13',
      admin: ['sunyazhou13'],
      id: 'Thu Sep 17 2020 14:34:10 GMT+0800',
      distractionFreeMode: 'true'
  })
  gitalk.render('gitalk-container') 
  }
  </script>




            <footer class="footer">
    <span class="footer__copyright">
        本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 和 Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2020 - 本站由 <a href="/">@sunyazhou13</a> 创建,
        使用<a href="https://github.com/lenbo-ma/hexo-theme-vno">hexo-theme-vno</a>主题,
        修改自<a href="https://github.com/onevcat/vno" target="_blank">喵神的vno</a>
    </span>
</footer>

        </div>
    </div>

    <script src="https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>

     




    


    

<script type="text/javascript">

// var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
// document.write(unescape("%3Cspan id='cnzz_stat_icon_1274885345'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1274885345%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));

var cnzz_s_tag = document.createElement('script');
cnzz_s_tag.type = 'text/javascript';
cnzz_s_tag.async = true;
cnzz_s_tag.charset = "utf-8";
cnzz_s_tag.src = src="https://s13.cnzz.com/z_stat.php?id=1274885345&web_id=1274885345&async=1";
var root_s = document.getElementsByTagName('script')[0];
root_s.parentNode.insertBefore(cnzz_s_tag, root_s);

</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
