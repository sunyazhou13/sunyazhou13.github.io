<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>阿里、字节：一套高效的iOS面试题之我整理的答案之runtime相关问题1 | 東引甌越</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="阿里、字节：一套高效的iOS面试题之我整理的答案之runtime相关问题1 | 東引甌越">
    <meta name="twitter:description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="阿里、字节：一套高效的iOS面试题之我整理的答案之runtime相关问题1 | 東引甌越">
    <meta property="og:description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    
    <meta name="author" content="sunyazhou">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//apps.bdimg.com/libs/fontawesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/favicon.ico">
    

    
    <link rel="apple-touch-icon" href="/images/logo.jpg">
    
    
    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="東引甌越" href="/atom.xml">
    

    <link rel="canonical" href="https://www.sunyazhou.com/2020/07/06/20200721iOSinterviewAnswers/"/>

    
    <link rel="author" href="https://plus.google.com/107423989995616646161"/>
    
    <!-- fancybox support -->
    
        <script src="/lib/jquery-3.3.1.min.js"></script>
        <link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.min.css">
        <script src="/lib/fancybox/dist/jquery.fancybox.min.js"></script>
        <script src="/js/wrapImage.js"></script>
    
</head>

<body class="home-template no-js">

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 東引甌越 的主页"><img src="/images/logo2.jpg" width="80" alt="東引甌越 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 東引甌越">東引甌越</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">不断学习, 与时俱进. - 始于2017</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">文章</a></li>
            
              <li class="navigation__item"><a href="/archives">归档</a></li>
            
              <li class="navigation__item"><a href="/projects">作品</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/sunyazhou13" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/sunyazhou13" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  
  <li class="navigation__item">
    <a href="https://plus.google.com/107423989995616646161" title="Google+" target="_blank">
      <i class='social fa fa-google-plus-square'></i>
      <span class="label">Google+</span>
    </a>
  </li>


<!-- Facebook -->


<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/sunyazhou" title="上Twitter找我" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

<!-- instagram -->


  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>


  <li class="navigation__item">
    <a href="mailto:sunyazhou13@163.com" title="邮件联系我" target="_blank">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-red"></div>
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2020-07-06T01:52:47.000Z" class="post-list__meta--date date">2020-07-06</time>
 &#8226; <span class="post-meta__tags tags">分类&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/iOS面试系列/">iOS面试系列</a>

</span>
    </div>
    <h1 class="post-title">阿里、字节：一套高效的iOS面试题之我整理的答案之runtime相关问题1</h1>
  </header>

  <section class="post">
    <p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/d41ccde23ec0d6cf14438b8f95f8a75407046c45/20200706iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<blockquote>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
</blockquote>
<p>记得过年时候 <a href="https://mp.weixin.qq.com/s/bDnsaD__ZpdHIk3_So382w" target="_blank" rel="noopener">有一个微信公众号</a> 的面试题引起了我的关注,但是只有问题没有答案,由于最近半年时间太忙了,博客几乎停更了一个季度,所以今天我打算把这个面试题的答案 整理一下,方便后续iOS开发者需要时可时长关注.期间如果有解答不清楚或者不对之处还请各位指正.</p>
<h1 id="面试题的结构分类和细化">面试题的结构分类和细化</h1>
<ul>
<li>runtime相关问题
<ol type="1">
<li>runtime结构模型</li>
<li>内存管理</li>
<li>关联属下或者hook相关的Method Swizzle</li>
</ol></li>
<li>NSNotification相关
<ol type="1">
<li>参考GNUStep源码</li>
<li>NSNotification实现原理 相关</li>
</ol></li>
<li>Runloop &amp; KVO
<ol type="1">
<li>runloop</li>
<li>KVO</li>
</ol></li>
<li>Block
<ol type="1">
<li>Block实现原理和注意事项相关</li>
</ol></li>
<li>多线程
<ol type="1">
<li>GCD相关和一些多线程概念</li>
</ol></li>
<li>视图&amp;图像相关
<ol type="1">
<li>视图UI布局方案</li>
<li>视图渲染相关</li>
</ol></li>
<li>性能优化</li>
<li>开发证书</li>
<li>架构设计
<ol type="1">
<li>各种设计模式</li>
<li>自己的设计</li>
</ol></li>
<li>其他问题
<ol type="1">
<li>方法调用和切面编程等</li>
</ol></li>
<li>系统基础知识</li>
<li>数据结构与算法</li>
</ul>
<h2 id="runtime相关问题">runtime相关问题</h2>
<p><a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">objc-runtime源码地址</a><br>
<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4官方源码地址</a></p>
<h3 id="结构模型">结构模型</h3>
<h4 id="介绍下runtime的内存模型isa对象类metaclass结构体的存储信息等">介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）</h4>
<h5 id="对象">对象</h5>
<p>OC中的对象指向的是一个<code>objc_object</code>指针类型，<code>typedef struct objc_object *id;</code>从它的结构体中可以看出，它包括一个isa指针，指向的是这个对象的类对象,一个对象实例就是通过这个isa找到它自己的Class，而这个Class中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>这个objc_object 的实现比较长 在这里<a href="https://github.com/RetVal/objc-runtime/blob/master/runtime/objc-private.h" target="_blank" rel="noopener">查看</a></p>
<h4 id="类">类</h4>
<p>在OC中的类是用Class来表示的，实际上它指向的是一个<code>objc_class</code>的指针类型，<code>typedef struct objc_class *Class;</code><br>
对应的结构体如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="class和-object-小结">class和 object 小结</h5>
<p>从结构体中定义的变量可知，OC的<code>Class</code>类型包括如下</p>
<p>数据（即：元数据<code>metadata</code>）：<code>super_class</code>（父类类对象）;<br>
name（类对象的名称）;<br>
version、info（版本和相关信息）;<br>
instance_size（实例内存大小）;<br>
ivars（实例变量列表）；<br>
methodLists（方法列表）；<br>
cache（缓存）；<br>
protocols（实现的协议列表）;<br>
当然也包括一个isa指针，这说明Class也是一个对象类型，所以我们称之为类对象， 这里的isa指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/ace59aaa421b057ec4de674f0c5b098e75c1ee68/20200706iOSinterviewAnswers/class_inherit.png" alt="Objective-C的对象原型继承链"> <a href>Objective-C的对象原型继承链</a></p>
<p>从图中可知，最终的基类<code>NSObject</code>的元类对象<code>isa</code>指向的是自己本身，从而形成一个闭环。<br>
元类（<code>Meta Class</code>）：是一个类对象的类，即：Class的类，这里保存了类方法等相关信息。<br>
我们再看一下类对象中存储的方法、属性、成员变量等信息的结构体<br>
<code>objc_ivar_list</code>：存储了类的成员变量，<br>
可以通过<code>object_getIvar</code>或<code>class_copyIvarList</code>获取；<br>
另外这两个方法是用来获取类的属性列表的<code>class_getProperty</code>和<code>class_copyPropertyList</code>，属性和成员变量是有区别的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_type                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_method_list</code>：存储了类的方法列表，可以通过<code>class_copyMethodList</code>获取。</p>
<p>结构体如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable method_types                            OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable obsolete             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_protocol_list</code>：储存了类的协议列表，可以通过<code>class_copyProtocolList</code>获取。</p>
<p>结构体如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_protocol_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable next;</span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Protocol * _Nullable list[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此问题参考<a href="https://developer.aliyun.com/ask/282811" target="_blank" rel="noopener">介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）</a></p>
<h4 id="为什么要设计metaclass">为什么要设计metaclass?</h4>
<p>先说结论: 为了更好的<strong>复用传递消息</strong>.metaclass只是需要<strong>实现复用消息传递</strong>为目的工具.而Objective-C所有的类默认都是同一个MetaClass(通过isa指针最终指向metaclass). 因为Objective-C的特性基本上是照搬的Smalltalk,Smalltalk中的MetaClass的设计是Smalltalk-80加入的.所以Objective-C也就有了metaclass的设计.</p>
<blockquote>
<p>本质上因为Smalltalk的面向对象的亮点是它的<strong>消息发送机制</strong>.</p>
</blockquote>
<p>回答这个问题之前我们先回看一下上边的Objective-C的对象原型继承链<img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/ea106c8b431313c811fc6d431944ca00cc177cc4/20200706iOSinterviewAnswers/class_inherit2.jpg" alt="Objective-C的对象原型继承链"></p>
<p>通过上图我们明白如下 重点内容:</p>
<ul>
<li><strong>实例的实例方法函数存在类结构体中</strong></li>
<li><strong>类方法函数存在metaclass结构体中</strong></li>
</ul>
<p>而Objective-C的方法调用（消息）就会根据对象去找isa指针指向的Class对象中的方法列表找到对应的方法。 &gt; isa 指向的类就是我们创建实例的类型.</p>
<p>通过<a href="https://www.jianshu.com/p/ea7c42e16da8" target="_blank" rel="noopener">Why is MetaClass in Objective-C？</a>文章我们了解到一个十分重要的概念,python和<strong>Objective-C不太一样的是,并不是每一个类都有一个MetaClass,而是Objective-C所有的类默认都是同一个MetaClass.</strong></p>
<h5 id="smalltalk中的metaclass">Smalltalk中的metaclass</h5>
<p>Smalltalk，被公认为历史上第二个面向对象的语言，其亮点是它的<strong>消息发送机制</strong>。<br>
Smalltalk中的MetaClass的设计是Smalltalk-80加入的。而之前的Smalltalk-76，并不是每个类有一个MetaClass，而是所有类的isa指针都指向一个特殊的类，叫做Class(这种设计之后也被Java借鉴了）。<br>
而每个类都有自己MetaClass的设计，加入的原因是，因为Smalltalk里面，类是对象，而对象就可以响应消息，那么类的消息的响应的方法就应该由类的类去存储，而每个MetaClass就持有每个类的类方法。</p>
<h6 id="每个metaclass的isa指针指向什么">每个MetaClass的isa指针指向什么？</h6>
<p>如果MetaClass再有MetaClass，那么这个关系将无穷无尽。Smalltalk里的解决方案是，指向同一个叫MetaClass的类。</p>
<h6 id="metaclass的isa指针指向什么">MetaClass的isa指针指向什么？</h6>
<p>指向他的实例，也就是实例的isa指向MetaClass，同时MetaClassisa指向实例，相互指着。</p>
<p>那么Smalltalk的继承关系，其实和Objective-C的很像了（后面有class的是前者的MetaClass）。</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/1536ebe653d099c05d65584e0ae7d1ec75629356/20200706iOSinterviewAnswers/class_inherit2_smaltalk.png"></p>
<h6 id="这时候产生了一个重要的问题假如去掉metaclass把类方法放到也类里面是否可行">这时候产生了一个重要的问题，假如去掉MetaClass，把类方法放到也类里面是否可行？</h6>
<p>这个问题，我思索许久，发现其实是一个对面向对象的哲学思想问题，要对这个问题下结论，不得不重新讲讲面向对象</p>
<h5 id="从smalltalk重新认识面向对象">从Smalltalk重新认识面向对象</h5>
<p>以前谈到面向对象，总会提到，面向对象三特征：封装、继承、多态。但其实，面向对象中也分流派，如C++这种来自Simula的设计思想的，更注重的是类的划分，因为方法调用是静态的。而如Objective-C这种借鉴Smalltalk的，更注重的是消息传递，是动态响应消息。</p>
<p>而面向对象三种特征，更基于的是类的划分而提出的。</p>
<p>这两种思想最大的不同，我认为是自上而下和自下而上的思考方式。</p>
<ul>
<li>类的划分，要求类的设计者是以一个很高的层次去设计这个类，提取出类的特性和本质，进行类的构建。知道类型才可以去发送消息给对象。</li>
<li>消息传递，要求的是类的设计者以消息为起点去构建类，也就是对外界的变化进行响应，而不关心自身的类型，设计接口。尝试理解消息，无法处理则进行特殊处理。 在此不讨论两种方式的优劣之分，而着重讲讲Smalltalk这种设计。</li>
</ul>
<p>消息传递对于面向对象的设计，其实在于给出一种对消息的解决方案。而面向对象优点之一的复用，在这种设计里，更多在于复用解决方案，而不是单纯的类本身。这种思想就如设计组件一般，关心接口，关心组合而非类本身。其实之所以有MetaClass这种设计，我的理解并不是先有MetaClass，而是在万物都是对象的Smalltalk里，向对象发送消息的基本解决方案是统一的，希望复用的。而实例和类之间用的这一套通过isa指针指向的Class单例中存储方法列表和查询方法的解决方案的流程，是应该在类上复用的，而MetaClass就顺理成章出现罢了。</p>
<h5 id="为什么要设计metaclass小结">为什么要设计metaclass小结</h5>
<h6 id="回到一开始那个问题为什么要设计metaclass去掉把类方法放到类里面行不行">回到一开始那个问题，为什么要设计MetaClass，去掉把类方法放到类里面行不行？</h6>
<p>我的理解是，可以，但不Smalltalk。这样的设计是C++那种自上而下的设计方式，类方法也是类的一种特征描述。而Smalltalk的精髓正在于消息传递，复用消息传递才是根本目的，而MetaClass只不过是因此需要的一个工具罢了。</p>
<p>参考<a href="https://www.jianshu.com/p/ea7c42e16da8" target="_blank" rel="noopener">Why is MetaClass in Objective-C？</a></p>
<h4 id="class_copyivarlist-class_copypropertylist区别"><strong>class_copyIvarList()</strong> &amp; <strong>class_copyPropertyList()</strong>区别</h4>
<p>先说结论:</p>
<ul>
<li><strong>class_copyIvarList()</strong> 能获取到所有的成员变量,包括 花括号内的变量(<code>.h</code>和<code>.m</code>都包括).</li>
<li><strong>class_copyPropertyList()</strong> 只能获取到 以<code>@property</code>关键字 声明的中属性(<code>.h</code>和<code>.m</code>都包括)</li>
</ul>
<p>区别:</p>
<ul>
<li><code>class_copyIvarList()</code>获取默认是带下划线的变量</li>
<li><code>class_copyPropertyList()</code>获取默认是不带下划线的变量名称.</li>
</ul>
<blockquote>
<p>但是以上两个方法都只能获取到当前类的属性和变量（也就是说获取不到父类的属性和变量）</p>
</blockquote>
<hr>
<p>举例说明:</p>
<p>我们声明一个<code>ClassA</code> 通过 调试代码实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">    <span class="keyword">int</span> _c;</span><br><span class="line">    <span class="built_in">CGFloat</span> d; <span class="comment">//不推荐这样写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>          *arrayA;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>  ) <span class="built_in">NSString</span>         *stringA;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">dispatch_queue_t</span> testQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>如果是通过<code>class_copyIvarList()</code>函数获取则打印如下结果.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--- class_copyIvarList ↓↓↓---</span><br><span class="line">_a</span><br><span class="line">_b</span><br><span class="line">_c</span><br><span class="line">d</span><br><span class="line">_arrayA</span><br><span class="line">_stringA</span><br><span class="line">_testQueue</span><br><span class="line">--------------END----------------</span><br></pre></td></tr></table></figure>
<p>如果是通过<code>class_copyPropertyList()</code>函数获取则打印如下结果.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--- class_copyPropertyList ↓↓↓---</span><br><span class="line">arrayA</span><br><span class="line">stringA</span><br><span class="line">testQueue</span><br><span class="line">--------------END----------------</span><br></pre></td></tr></table></figure>
<p>debug代码如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printIvarOrProperty &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--- class_copyPropertyList ↓↓↓---"</span>);</span><br><span class="line">    ClassA *classA = [[ClassA alloc] init];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;</span><br><span class="line">    objc_property_t *result = class_copyPropertyList(object_getClass(classA), &amp;propertyCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</span><br><span class="line">        objc_property_t objc_property_name = result[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span>, property_getName(objc_property_name)]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(result);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------------END----------------"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--- class_copyIvarList ↓↓↓---"</span>);</span><br><span class="line">    Ivar *iv = class_copyIvarList(object_getClass(classA), &amp;propertyCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</span><br><span class="line">        Ivar ivar = iv[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span>, ivar_getName(ivar)]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(iv);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------------END----------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上<a href="https://github.com/sunyazhou13/IvarAndPropertyDemo" target="_blank" rel="noopener">demo点击这里下载</a></p>
<hr>
<p>下面我们看下<a href="https://github.com/sunyazhou13/objc-runtime" target="_blank" rel="noopener">objc的源码</a></p>
<p>以下代码位于<code>objc-runtime-new.mm</code>中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_copyPropertyList. Returns a heap block containing the </span></span><br><span class="line"><span class="comment">* properties declared in the class, or nil if the class </span></span><br><span class="line"><span class="comment">* declares no properties. Caller must free the block.</span></span><br><span class="line"><span class="comment">* Does not copy any superclass's properties.</span></span><br><span class="line"><span class="comment">* Locking: read-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">objc_property_t</span> *</span><br><span class="line">class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outCount) *outCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">property_t</span> **result = nil;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = rw-&gt;properties.count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = (<span class="keyword">property_t</span> **)<span class="built_in">malloc</span>((count + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">property_t</span> *));</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; prop : rw-&gt;properties) &#123;</span><br><span class="line">            result[count++] = &amp;prop;</span><br><span class="line">        &#125;</span><br><span class="line">        result[count] = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outCount) *outCount = count;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">objc_property_t</span> *)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码我们可以看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">rw-&gt;properties; <span class="comment">//通过rw直接拿到properties</span></span><br></pre></td></tr></table></figure>
<p>通过rw直接拿到properties,然后便利拿出想要的 以<code>@property</code>关键字 声明变量名称.</p>
<p><code>properties</code>详细内容 还请异步运行时源码看下这里篇幅限制就不啰嗦了.</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_copyIvarList</span></span><br><span class="line"><span class="comment">* fixme</span></span><br><span class="line"><span class="comment">* Locking: read-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">Ivar *</span><br><span class="line">class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> *ivars;</span><br><span class="line">    Ivar *result = nil;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outCount) *outCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ivars = cls-&gt;data()-&gt;ro-&gt;ivars)  &amp;&amp;  ivars-&gt;count) &#123;</span><br><span class="line">        result = (Ivar *)<span class="built_in">malloc</span>((ivars-&gt;count+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Ivar));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ivar : *ivars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ivar.offset) <span class="keyword">continue</span>;  <span class="comment">// anonymous bitfield</span></span><br><span class="line">            result[count++] = &amp;ivar;</span><br><span class="line">        &#125;</span><br><span class="line">        result[count] = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (outCount) *outCount = count;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就一个关键点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ivars = cls-&gt;data()-&gt;ro-&gt;ivars</span><br></pre></td></tr></table></figure>
<p>拿到ivars.</p>
<p>由于这两者拿到的成员不一样所以两个API就会有区别.</p>
<h4 id="class_rw_t-和-class_ro_t-的区别"><code>class_rw_t</code> 和 <code>class_ro_t</code> 的区别</h4>
<p>先说结论:</p>
<ul>
<li>两个结构体都存放着当前类的属性、实例变量、方法、协议等.</li>
<li><code>class_ro_t</code>存放的是编译期间就确定的.</li>
<li>而<code>class_rw_t</code>是在runtime时才确定，它会先将<code>class_ro_t</code>的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说<code>class_rw_t</code>是<code>class_ro_t</code>的超集，当然实际访问类的方法、属性等也都是访问的<code>class_rw_t</code>中的内容.</li>
</ul>
<hr>
<h5 id="下面我来深入了解两者具体是什么">下面我来深入了解两者具体是什么</h5>
<p>首先我们需要了解它俩的由来,在<code>objc_class</code>我们知道有一个成员变量叫<code>isa</code>,我们这里要介绍的是<code>objc_class</code>的另一成员变量<code>bits</code>.</p>
<p><code>objc_class</code>的结构如下:</p>
<figure>
<img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/61d110b80ee681981768f6d36211045d11db0d5c/20200706iOSinterviewAnswers/objc_class_struct.png" alt="objc_class的结构"><figcaption>objc_class的结构</figcaption>
</figure>
<p><code>bits</code> 用来存储类的属性，方法，协议等信息。它是一个<code>class_data_bits_t</code>类型</p>
<p><code>class_data_bits_t</code> 如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    <span class="comment">// method here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体只有一个<code>64bit</code>的成员变量<code>bits</code>，先来看看这<code>64bit</code>分别存放的什么信息：</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/61d110b80ee681981768f6d36211045d11db0d5c/20200706iOSinterviewAnswers/objc_class_bits.png"></p>
<ul>
<li><code>is_swift</code> : 第一个bit，判断类是否是Swift类</li>
<li><code>has_default_rr</code> ：第二个bit，判断当前类或者父类含有默认的<code>retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</code> 方法</li>
<li><code>require_raw_isa</code> ：第三个bit， 判断当前类的实例是否需要<code>raw_isa</code></li>
<li><code>data</code> : 第4-48位，存放一个指向class_rw_t结构体的指针，该结构体包含了该类的属性，方法，协议等信息。至于为何只用44bit来存放地址</li>
</ul>
<h5 id="class_rw_t-和class_ro_t"><code>class_rw_t</code> 和<code>class_ro_t</code></h5>
<p>先来看看两个结构体的内部成员变量</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">    uint32_t reserved;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>class_rw_t</code>结构体内有一个指向<code>class_ro_t</code>结构体的指针.</p>
<p>每个类都对应有一个<code>class_ro_t</code>结构体和一个<code>class_rw_t</code>结构体。在编译期间，<code>class_ro_t</code>结构体就已经确定，<code>objc_class</code>中的<code>bits</code>的<code>data</code>部分存放着该结构体的地址。在<code>runtime</code>运行之后，具体说来是在运行<code>runtime</code>的<code>realizeClass</code> 方法时，会生成<code>class_rw_t</code>结构体，该结构体包含了<code>class_ro_t</code>，并且更新<code>data</code>部分，换成<code>class_rw_t</code>结构体的地址。</p>
<p>用两张图来说明这个过程：</p>
<p>类的<code>realizeClass</code>运行之前：<br>
<img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/c0ebe0ba01e4bc70201f9212b382f9c64f894f6b/20200706iOSinterviewAnswers/before_bits.png"></p>
<p>类的<code>realizeClass</code>运行之后：</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/c0ebe0ba01e4bc70201f9212b382f9c64f894f6b/20200706iOSinterviewAnswers/after_bits.png"></p>
<p>细看两个结构体的成员变量会发现很多相同的地方，他们都存放着当前类的属性、实例变量、方法、协议等等。区别在于：<code>class_ro_t</code>存放的是编译期间就确定的；而<code>class_rw_t</code>是在<code>runtime</code>时才确定，它会先将<code>class_ro_t</code>的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说<code>class_rw_t</code>是<code>class_ro_t</code>的超集，当然实际访问类的方法、属性等也都是访问的<code>class_rw_t</code>中的内容</p>
<p>属性(property)存放在<code>class_rw_t</code>中，实例变量(ivar)存放在<code>class_ro_t</code>中。</p>
<p>详细内容请 参考资料<a href="http://vanney9.com/2017/06/05/objective-c-runtime-property-method/" target="_blank" rel="noopener">Objective-C runtime - 属性与方法</a></p>
<h4 id="category如何被加载的两个category的load方法的加载顺序两个category的同名方法的加载顺序">category如何被加载的,两个category的load方法的加载顺序，两个category的同名方法的加载顺序</h4>
<p>结论:</p>
<ol type="1">
<li>category 是 这样 <code>realizeClass</code> -&gt; <code>methodizeClass()</code> -&gt; <code>attachCategories()</code> 一步步被加载的.</li>
<li>主类与分类的加载顺序是:<strong>主类优先于分类加载,无关编译顺序</strong>.</li>
<li>分类间的加载顺序取决于编译的顺序:<strong>编译在前则先加载,编译在后则后加载</strong>.</li>
</ol>
<hr>
<h5 id="category如何被加载的">category如何被加载的</h5>
<p>我在运行时的源码 <code>objc-runtime-new.mm</code>中找到如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Attach categories  被加载</span></span><br><span class="line">	methodizeClass(cls, previously);</span><br><span class="line">	<span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>realizeClass</code> -&gt; <code>methodizeClass()</code> -&gt; <code>attachCategories()</code></p>
<p>核心是在methodizeClass()函数中实现的.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;ro;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码我们发现<code>ro-&gt;baseProperties;</code> , baseProperties 在前，category 在后,</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">property_list_t *proplist = ro-&gt;baseProperties;</span><br><span class="line"><span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">  rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但决定顺序的是 rw-&gt;<code>properties.attachLists ()</code>这个方法.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// category 被附加进去</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="comment">// 将旧内容移动偏移量 addedCount 然后将 addedLists copy 到起始位置</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            struct array_t &#123;</span></span><br><span class="line"><span class="comment">                    uint32_t count;</span></span><br><span class="line"><span class="comment">                    List* lists[0];</span></span><br><span class="line"><span class="comment">                    &#125;;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">        addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以 category 的属性总是在前面的，baseClass的属性被往后偏移了。</p>
<h5 id="两个category的load方法的加载顺序">两个category的load方法的加载顺序</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A class’s +load method is called after all of its superclasses’ +load methods.</span><br><span class="line">一个类的+load方法在其父类的+load方法后调用</span><br><span class="line"></span><br><span class="line">A category +load method is called after the class’s own +load method.</span><br><span class="line">一个Category的+load方法在被其扩展的类的自有+load方法后调用</span><br></pre></td></tr></table></figure>
<p>结论: 主类与分类的加载顺序是:<strong>主类优先于分类加载,无关编译顺序</strong>.</p>
<h5 id="两个category的同名方法的加载顺序">两个category的同名方法的加载顺序</h5>
<p>应用程序 image 镜像加载到内存中时， <code>Category</code> 解析的过程，注意下面的 <code>while(i--)</code> 循环 这里倒序将 <code>category</code> 中的协议 方法 属性添加到了<code>rw = cls-&gt;data()</code>中的 <code>methods/properties/protocols</code>中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 注意下面的代码，上面采用倒叙遍历方式，所以后编译的 category 会先add到数组的前部</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以结论是:分类间的加载顺序取决于编译的顺序:编译在前则先加载,编译在后则后加载</p>
<p>这个问题网上有很多例子 就不多在这举例了.</p>
<h4 id="category-extension区别能给nsobject添加extension吗结果如何"><code>category</code> &amp; <code>extension</code>区别，能给NSObject添加Extension吗，结果如何</h4>
<h5 id="category"><code>category</code></h5>
<ul>
<li>运行时添加分类属性/协议/方法</li>
<li>分类添加的方法会“覆盖”原类方法，因为方法查找的话是从头至尾，一旦查找到了就停止了</li>
<li>同名分类方法谁生效取决于编译顺序，image 读取的信息是倒叙的，所以编译越靠后的越先读入</li>
<li>名字相同的分类会引起编译报错；</li>
</ul>
<h5 id="extension"><code>extension</code></h5>
<ul>
<li>编译时决议</li>
<li>只以声明的形式存在，多数情况下就存在于 .m 文件中；</li>
<li>不能为系统类添加扩展</li>
</ul>
<p>可以给类添加成员变量，但是是私有的 可以給类添加方法，但是是私有的 添加的属性和方法是类的一部分，在编译期就决定的。在编译器和头文件的@interface和实现文件里的<span class="citation" data-cites="implement一起形成了一个完整的类">@implement一起形成了一个完整的类</span>。 伴随着类的产生而产生，也随着类的消失而消失</p>
<blockquote>
<p><strong>必须有类的源码才可以给类添加extension</strong>!!!</p>
</blockquote>
<h5 id="category-extension区别"><code>category</code> &amp; <code>extension</code>区别</h5>
<ul>
<li>Category的小括号中有名字,而Extension没有;</li>
<li>Category只能扩充方法,不能扩充成员变量和属性;</li>
<li>如果Category声明了声明了一个属性,那么Category只会生成这个属性的set,get方法的声明,也就不是会实现.所以对于系统一些类，如nsstring，就无法添加类扩展 不能给NSObject添加Extension，因为在extension中添加的方法或属性必须在源类的文件的.m文件中实现才可以，即：你必须有一个类的源码才能添加一个类的<code>extension</code></li>
</ul>
<h5 id="能给nsobject添加extension吗结果如何">能给NSObject添加Extension吗，结果如何?</h5>
<p>不能 因为没有NSObject的.m源码文件.</p>
<blockquote>
<p>如果能的话那应该不叫Extension.或者我们自己通过运行时的api自己造一套ExtensionDIY.结果就是你用的根本不能称为<code>Extension</code>,而是api调用而已.</p>
</blockquote>
<h4 id="消息转发机制消息转发机制和其他语言的消息机制优劣对比">消息转发机制，消息转发机制和其他语言的消息机制优劣对比</h4>
<blockquote>
<p>前言: 了解消息转发之前我们有必要了解一些Objectivce-C中的消息传递机制</p>
</blockquote>
<h5 id="消息传递机制">消息传递机制</h5>
<p>在Objectivce-C中,我们通过<code>实例变量(对象)</code>或者<code>类方法名</code>调用一个方法,那么我们实际上是在发送一条消息</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = [someObject messageName:parameter];  <span class="comment">//实例调用方式</span></span><br><span class="line"><span class="keyword">id</span> returnValue = [ClassA messageName:parameter];  <span class="comment">//类调用方式</span></span><br></pre></td></tr></table></figure>
<p>上述<code>someObject</code>和<code>ClassA</code>是接受者(receiver)，<code>messageName:</code>是选择器(<code>selector</code>),选择器和参数合起来称为消息(<code>message</code>)。编译器看到此消息后，将其转换为一条标准的c语言函数调用，所调用的函数乃是消息传递机制中的核心函数：<code>objc_msgSend()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_msgSend</span><span class="params">(id self, SEL cmd, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个参数代表接受者，第二个参数代表选择子，后续参数就是消息中的那些参数 编译器会把刚才的那个例子中的消息转换为如下函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:),parameter);</span><br><span class="line"><span class="keyword">id</span> returnValue = objc_msgSend(ClassA, <span class="keyword">@selector</span>(messageName:),parameter);</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSend()</code>函数会依据接受者与选择器的类型来调用适当的方法.为来完成此操作，该方法需要在接受者所属的类中搜寻其“方法列表”(也就是上文我们说的<code>class_ro_t</code>中的method_list)。找到则跳到现实代码，否则，就沿着继承体系继续向上查找，如果还没有则执行消息转发操作。对于其他的“边界情况”，则需要交由Objective-c运行环境的另一些函数来处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">objc_msgSend_stret  <span class="comment">//待发送的消息返回结构体时</span></span><br><span class="line">objc_msgSend_fpret  <span class="comment">//消息返回的是浮点型</span></span><br><span class="line">objc_msgSendSuper   <span class="comment">//如果要给超类发送消息</span></span><br></pre></td></tr></table></figure>
<h5 id="消息转发机制">消息转发机制</h5>
<p>结合上边的消息传递机制,在Objective-C中如果给一个对象发送一条它无法处理的消息，就会进入下图描述的消息转发(Message Forwarding)流程</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/e6159f8ea469323fca413f3be530adee327fcd2f/20200706iOSinterviewAnswers/methodforward.jpg"></p>
<p>在objc中消息转发需要经历3个阶段 <code>resolveInstanceMethod</code> -&gt; <code>forwardingTargetForSelectoer</code> -&gt; <code>forwardInvocation</code> -&gt;<code>消息未能处理</code>。</p>
<ul>
<li>第一阶段:<strong>动态方法解析(Dynamic Method Resolution)</strong>也就是在所属的类中先征询接受者,看其是否能动态加方法，来处理当前这个<strong>未知选择器</strong></li>
<li>第二阶段:<strong>替换消息接收者快速转发</strong></li>
<li>第三阶段:<strong>完全消息转发机制</strong></li>
</ul>
<h5 id="第一阶段动态方法解析dynamic-method-resolution">第一阶段:<strong>动态方法解析(Dynamic Method Resolution)</strong></h5>
<p>对象在受到无法解读的消息后，首先将调用其所属类的下列类方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这俩方法在NSObject.h中</p>
</blockquote>
<p>返回一个<code>Boolean</code>类型，表示这个类是否能新增一个实例方法以处理选择器.</p>
<p>在 消息转发过程中,我们可以使用<code>resolveInstanceMethod:</code>动态的将一个方法添加到一个类中.</p>
<p>例下面示例代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这里我们用到一个运行时函数<code>class_addMethod()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL </span><br><span class="line">class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> ! addMethod(cls, name, imp, types ?: <span class="string">""</span>, NO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>class_addMethod()</code>最后一个参数叫做<code>types</code>，是一个描述方法的参数类型的字符串.</li>
<li><code>v</code>代表<code>void</code></li>
<li><code>@</code>代表对象或者说<code>id类型</code></li>
<li><code>:</code>(这个冒号)代表方法选择器SEL</li>
</ul>
<p>具体代表什么不是我们瞎写的,得按照苹果的这个标准 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Objective-C Runtime Programming Guide-&gt;Type Encodings</a></p>
<p>上面的<code>dynamicMethodIMP</code>，返回值是<code>void</code>，两个入参分别是<code>id</code>和<code>SEL</code>，所以描述这个方法的参数类型的字符串就是<code>v@:</code></p>
<p>这个阶段的意义是为一个类动态提供方法实现,严格来说，还没进入消息转发流程。</p>
<p><code>resolveInstanceMethod:</code> 控制这下面两个方法是否会被调用</p>
<ul>
<li><code>respondsToSelector:</code><br>
</li>
<li><code>instancesRespondToSelector:</code></li>
</ul>
<blockquote>
<p>也就是说，如果<code>resolveInstanceMethod:</code>返回了<code>YES</code>，那么<code>respondsToSelector:</code>和<code>instancesRespondToSelector:</code>都会返回<code>YES</code>.</p>
</blockquote>
<h5 id="第二阶段替换消息接收者快速转发">第二阶段：替换消息接收者(快速转发)</h5>
<p>如果第一阶段中<code>resolveInstanceMethod:</code>返回NO,就会调用<code>forwardingTargetForSelector:</code>询问是否把消息转发给另一个对象.消息的接收者就改变了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第三阶段完全消息转发机制">第三阶段：完全消息转发机制</h5>
<p>如果第二阶段的<code>forwardingTargetForSelector:</code>返回了<code>nil</code>，这就进入了所谓完全消息转发的机制。</p>
<p>首先调用<code>methodSignatureForSelector:</code>为要转发的消息返回正确的签名：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardInvocation"</span>);</span><br><span class="line">    SomeOtherObject *someOtherObject = [SomeOtherObject new];</span><br><span class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector:[anInvocation selector]]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是将消息转发给其他对象，其实这与第二阶段中示例代码做的事情是一样的。区别就在于这个阶段会有一个<code>NSInvocation</code>对象。<a href="https://developer.apple.com/documentation/foundation/nsinvocation?language=objc" target="_blank" rel="noopener"><code>NSInvocation</code></a>是一个用来存储和转发消息的对象。它包含了一个Objective-C消息的所有元素：一个target，一个selector，参数和返回值。每个元素都可以被直接设置。</p>
<blockquote>
<p><code>NSInvocation</code>可以简单理解为一个对象把我们用到 selector方法和对象都存储了一下,然后哪个是指向我们需要调用的指针对象.</p>
</blockquote>
<p>所以不同与第二阶段，在这个阶段你可以：</p>
<ul>
<li>把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。</li>
<li>修改消息的target，selector，参数等</li>
<li>多次转发这个消息，转发给多个对象</li>
</ul>
<p>显然在这个阶段，你可以对一个OC消息做更多的事情</p>
<hr>
<h5 id="消息转发机制和其他语言的消息机制优劣对比">消息转发机制和其他语言的消息机制优劣对比</h5>
<p>这个目前没有深入其它编程语言的运行时层面,比如C的底层或者C++的底层或者Java的底层消息传递这里提供 <a href="探索%20Android%20App%20Bundle">一个android的类似消息转发的文章</a></p>
<h4 id="在方法调用的时候方法查询--动态解析--消息转发-之前做了什么">在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么</h4>
<p>Objective-C 实例对象执行方法步骤</p>
<ol type="1">
<li>获取 receiver 对应的类 Class</li>
<li>在 Class 缓存列表中(就是<code>objc_class</code>里的<code>cache_t</code>到<code>class_ro_t</code>的方法list)根据选择子<code>selector</code>查找<code>IMP</code></li>
<li>若缓存中没有找到，则在方法列表中继续查找.</li>
<li>若方法列表没有，则从父类查找，重复以上步骤.</li>
<li>若最终没有找到，则进行消息转发操作.</li>
</ol>
<ul>
<li>方法查询之前 要知道 receiver和 selector.主要是要明确我们是哪个实例调用了哪个方法.<br>
</li>
<li>动态解析解析之前要 在所属的类中先征询接受者,看其是否能动态加方法，来处理当前这个未知选择器.</li>
<li>消息转发 之前 要询问是否把消息转发给另一个对象.</li>
</ul>
<blockquote>
<p>如果更深入的而理解 那应该是 objc_msgSend() 为啥是汇编实现的,上面的那些方法 调用之前 汇编的哪些指令被执行</p>
</blockquote>
<p>这里找到两篇文章可以参考一下<br>
<a href="https://chipengliu.github.io/2019/06/02/objc-msgSend-forward/" target="_blank" rel="noopener">深入了解Objective-C消息发送与转发过程</a><br>
<a href="https://chipengliu.github.io/2019/04/07/objc-msg-armd64/" target="_blank" rel="noopener">汇编语言编写的，其中具体过程细节</a></p>
<h4 id="impselmethod的区别和使用场景"><code>IMP</code>、<code>SEL</code>、<code>Method</code>的区别和使用场景</h4>
<ul>
<li><p><code>IMP</code> : 是方法的具体实现(指针)</p></li>
<li><p><code>SEL</code> :方法名称</p></li>
<li><p><code>Method</code>:是objc_method类型指针，它是一个结构体 ,如下:</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">	    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span><br><span class="line">	    <span class="keyword">char</span> * _Nullable method_types                            OBJC2_UNAVAILABLE;</span><br><span class="line">	    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span><br><span class="line">	&#125;</span><br><span class="line">	```  </span><br><span class="line"></span><br><span class="line">使用场景</span><br><span class="line"></span><br><span class="line">* 例如 Button添加Target和Selector的时候.或者 实现类的`swizzle`的时候会用到，通过`class_getInstanceMethod(<span class="keyword">class</span>, SEL)`来获取类的方法`Method`，其中用到了SEL作为方法名</span><br><span class="line"></span><br><span class="line">* 例如 给类动态添加方法，此时我们需要调用class_addMethod(Class, SEL, IMP, types)，该方法需要我们传递一个方法的实现函数IMP，例如:</span><br><span class="line"></span><br><span class="line">``` objc</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> funcName(<span class="keyword">id</span> receiver, SEL cmd, 方法参数...) &#123;</span><br><span class="line">   <span class="comment">// 方法具体的实现   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<blockquote>
<p>SEL相当于 方法的类型 关键字.</p>
</blockquote>
<h4 id="loadinitialize方法的区别什么在继承关系中他们有什么区别"><code>load</code>、<code>initialize</code>方法的区别什么？在继承关系中他们有什么区别</h4>
<p>在Objective-C的类被加载和初始化的时候, 类 是 可以收到 方法回调的.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)load;</span><br><span class="line">- (<span class="keyword">void</span>)initialize;</span><br></pre></td></tr></table></figure>
<h5 id="load"><code>+load</code></h5>
<p><code>+ load</code>方法是在这个文件(就是你复写的子类化的class)被程序装载时调用,只要是在Xcode <code>Compile Sources</code>中出现的文件总是会被装载，这与这个类是否被用到无关，因此+load方法总是在<code>main()</code>函数之前调用.</p>
<p>调用时机比较早，运行环境有不确定因素。具体说来，在iOS上通常就是App启动时进行加载，但当load调用的时候，并不能保证所有类都加载完成且可用，必要时还要自己负责做auto release处理。</p>
<blockquote>
<p>补充上面一点，对于有依赖关系的两个库中，被依赖的类的+load会优先调用。但在一个库之内，父、子类、类别之间调用有顺序，不同类之间调用顺序是不确定的。</p>
</blockquote>
<ul>
<li>关于继承：对于一个类而言，没有+load方法实现就不会调用，不会考虑对NSObject的继承，就是不会沿用父类的+load。</li>
<li>父类和本类的调用：父类的方法优先于子类的方法。一个类的+load方法不用写明<code>[super load]</code>，父类就会收到调用。</li>
<li>本类和Category的调用：本类的方法优先于类别(Category)中的方法。Category的+load也会收到调用，但顺序上在本类的+load调用之后。</li>
<li>不会直接触发initialize的调用。</li>
</ul>
<h4 id="initialize"><code>+initialize</code></h4>
<p><code>+initialize</code>方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用，并且只会调用一次。<code>initialize</code>方法实际上是一种惰性(lazy load)调用，也就是说如果一个类一直没被用到，那它的initialize方法也不会被调用，这一点有利于节约资源.</p>
<p>runtime 使用了发送消息 <code>objc_msgSend</code> 的方式对 <code>+initialize</code> 方法进行调用。也就是说 <code>+initialize</code> 方法的调用与普通方法的调用是一样的，走的都是<code>发送消息的流程</code>。换言之，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 <code>+initialize</code> 方法，那么就会对这个类中的实现造成覆盖(override)。</p>
<ul>
<li>initialize的自然调用是在第一次主动使用当前类的时候。</li>
<li>在initialize方法收到调用时，运行环境基本健全。</li>
<li>关于继承：和load不同，即使子类不实现initialize方法，会把父类的实现继承过来调用一遍，就是会沿用父类的+initialize。（沿用父类的方法中，self还是指子类）</li>
<li>父类和本类的调用：子类的+initialize将要调用时会激发父类调用的+initialize方法，所以也不需要在子类写明[super initialize]。(本着除主动调用外，只会调用一次的原则，如果父类的+initialize方法调用过了，则不会再调用)</li>
<li>本类和Category的调用：Category中的+initialize方法会覆盖本类的方法，只执行一个Category的+initialize方法。</li>
</ul>
<p>下面是我整理的一个表格希望对解释这俩方法有帮助:</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>+ load</th>
<th>+ initialize</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>调用方式</td>
<td>直接使用函数内存地址</td>
<td>objc_msgSend()方式</td>
</tr>
<tr class="even">
<td>调用时机</td>
<td>被程序装载时调用main()函数之前,就是被添加到runtime时</td>
<td>在本类或它的子类收到第一条消息之前被调用</td>
</tr>
<tr class="odd">
<td>是否被系统单次调用(除主动调用外)</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="even">
<td>运行时环境是否稳定</td>
<td>不确定</td>
<td>稳定</td>
</tr>
<tr class="odd">
<td>线程是否安全</td>
<td>默认是安全的(已加锁)</td>
<td>安全(已加锁 )</td>
</tr>
<tr class="even">
<td>特性</td>
<td>由于非<code>objc_msgSend()</code>方式调用就使得 +load 方法拥有了一个非常有趣的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用</td>
<td>+initialize 方法的调用与普通方法的调用是一样的，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖</td>
</tr>
</tbody>
</table>
<p>参考<a href="https://cloud.tencent.com/developer/article/1355957" target="_blank" rel="noopener">类方法load和initialize的区别</a></p>
<h5 id="在继承关系中他们有什么区别">在继承关系中他们有什么区别</h5>
<p>super的方法会成功调用，但是这是多余的，因为runtime会自动对父类的+load方法进行调用，而+initialize则会随子类自动激发父类的方法（如Apple文档中所言）不需要显示调用。另一方面，如果父类中的方法用到的self（像示例中的方法），其指代的依然是类自身，而不是父类</p>
<h4 id="说说消息转发机制的优劣">说说消息转发机制的优劣</h4>
<p>优点:</p>
<ul>
<li>利用消息转发机制可以无代码侵入的实现多重代理，让不同对象可以同时代理同个回调，然后在各自负责的区域进行相应的处理，降低了代码的耦合程度。<br>
</li>
<li>使用 <span class="citation" data-cites="synthesize">@synthesize</span> 可以为 <span class="citation" data-cites="property">@property</span> 自动生成 getter 和 setter 方法（现 Xcode 版本中，会自动生成），而 <span class="citation" data-cites="dynamic">@dynamic</span> 则是告诉编译器，不用生成 getter 和 setter 方法。当使用 <span class="citation" data-cites="dynamic">@dynamic</span> 时，我们可以使用消息转发机制，来动态添加 getter 和 setter 方法。当然你也用其他的方法来实现。</li>
</ul>
<p>缺点:</p>
<ul>
<li>Objective-C本身不支持多继承，这是因为消息机制名称查找发生在运行时而非编译时，很难解决多个基类可能导致的二义性问题，但是可以通过消息转发机制在内部创建多个功能的对象，把不能实现的功能给转发到其他对象上去，这样就做出来一种多继承的假象。转发和继承相似，可用于为OC编程添加一些多继承的效果，一个对象把消息转发出去，就好像他把另一个对象中放法接过来或者“继承”一样。消息转发弥补了objc不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</li>
</ul>
<h1 id="总结">总结</h1>
<p>本篇讲述的面试题中的<strong>runtime相关问题</strong>之<strong>结构模型</strong>部分。下一章打算继续讲一下 <strong>runtime相关问题</strong>之<strong>内存管理</strong>,这样循序渐进把相关面试的文章都讲完.</p>
<p>这里不得不说 这样的面试确实很有挑战,顺便 我也喷一下阿里 头条希望厚道一点,有问题可以但是也要有答案.这件事 让我观察出 这两家公司干事 有头没尾,能善始未能善终.</p>

  </section>

</article>


    <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           ↑<br>
           欣赏此文？求鼓励，求支持！
        </span>
        <br>
    </div>  
    <div id="donate_guide" class="donate_bar center hidden" >
        <!-- 方式一： 
            ![](/img/Alipay.jpg)
            ![](/img/WeChatpay.jpg)
        -->
        <!-- 方式二；
            step1：在_config.yml中添加配置
                Alipay: /img/Alipay.jpg
                WeChatpay: /img/WeChatpay.jpg
            step2：此处两张图片的路径分别设置为如下
                <img src="undefined"
                <img src="undefined"
        -->
        <!-- 支付宝打赏图案 -->
        <img src="/images/Alipay.jpg" alt="支付宝打赏">
        <!-- 微信打赏图案 -->
        <img src="/images/WeChatpay.jpg" alt="微信打赏">
    </div>
    <script type="text/javascript">
        document.getElementById('btn_donate').onclick = function(){
            $('#donate_board').addClass('hidden');
            $('#donate_guide').removeClass('hidden');
        }
    </script>
</div>

<! -- 添加捐赠图标 -->



<section class="read-more">
     
        
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2020/08/08/20200808iOSinterviewAnswers/" title="阿里、字节：一套高效的iOS面试题之我整理的答案之runtime相关问题2">阿里、字节：一套高效的iOS面试题之我整理的答案之runtime相关问题2</a></h2>
                <p class="excerpt">
                
                
前言

本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.

本篇我们来讲一下 阿里、字节
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-08-08T06:54:07.000Z" class="post-list__meta--date date">2020-08-08</time>
 &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/iOS面试系列/">iOS面试系列</a>

</span><a class="btn-border-small" href="/2020/08/08/20200808iOSinterviewAnswers/">继续阅读</a></div>

            </div>
        

        
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2020/04/10/20200410CocoapodsProblems/" title="Cocoapods清华镜像">Cocoapods清华镜像</a></h2>
                <p class="excerpt">
                
                前言
本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.
Cocoapod疑难杂症
这几天开
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-04-09T23:13:59.000Z" class="post-list__meta--date date">2020-04-10</time>
 &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/macOS开发/">macOS开发</a>

</span><a class="btn-border-small" href="/2020/04/10/20200410CocoapodsProblems/">继续阅读</a></div>

            </div>
        
   
</section>



  <div id="gitalk-container" style="padding: 0px 30px 0px 30px;"></div> 

  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script type="text/javascript">

  if(true){
    var gitalk = new Gitalk({
      clientID: '15c55ed469ea673ae332',
      clientSecret: '1801dbf9b1589c256260c85d779eb51d0cf40885',
      repo: 'gitment-comments',
      owner: 'sunyazhou13',
      admin: ['sunyazhou13'],
      id: 'Mon Jul 06 2020 09:52:47 GMT+0800',
      distractionFreeMode: 'true'
  })
  gitalk.render('gitalk-container') 
  }
  </script>




            <footer class="footer">
    <span class="footer__copyright">
        本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 和 Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2020 - 本站由 <a href="/">@sunyazhou13</a> 创建,
        使用<a href="https://github.com/lenbo-ma/hexo-theme-vno">hexo-theme-vno</a>主题,
        修改自<a href="https://github.com/onevcat/vno" target="_blank">喵神的vno</a>
    </span>
</footer>

        </div>
    </div>

    <script src="https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>

     




    


    

<script type="text/javascript">

// var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
// document.write(unescape("%3Cspan id='cnzz_stat_icon_1274885345'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1274885345%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));

var cnzz_s_tag = document.createElement('script');
cnzz_s_tag.type = 'text/javascript';
cnzz_s_tag.async = true;
cnzz_s_tag.charset = "utf-8";
cnzz_s_tag.src = src="https://s13.cnzz.com/z_stat.php?id=1274885345&web_id=1274885345&async=1";
var root_s = document.getElementsByTagName('script')[0];
root_s.parentNode.insertBefore(cnzz_s_tag, root_s);

</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
