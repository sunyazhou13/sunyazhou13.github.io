<!DOCTYPE html><html lang="zh-Hans" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.5.1"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="阿里、字节：一套高效的iOS面试题之runtime相关问题2" /><meta name="author" content="孙亚洲" /><meta property="og:locale" content="zh_Hans" /><meta name="description" content="嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者." /><meta property="og:description" content="嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者." /><link rel="canonical" href="https://www.sunyazhou.com/2020/08/iOSinterviewAnswers2/" /><meta property="og:url" content="https://www.sunyazhou.com/2020/08/iOSinterviewAnswers2/" /><meta property="og:site_name" content="迈腾大队长" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-08-08T14:54:07+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="阿里、字节：一套高效的iOS面试题之runtime相关问题2" /><meta name="twitter:site" content="@sunyazhou" /><meta name="twitter:creator" content="@孙亚洲" /><meta name="google-site-verification" content="Xo29j227HYVdC-vDA_-qJwvDP3PIo-lC78CFeBvhrDA" /> <script type="application/ld+json"> {"@type":"BlogPosting","url":"https://www.sunyazhou.com/2020/08/iOSinterviewAnswers2/","author":{"@type":"Person","name":"孙亚洲"},"headline":"阿里、字节：一套高效的iOS面试题之runtime相关问题2","dateModified":"2020-08-08T14:54:07+00:00","datePublished":"2020-08-08T14:54:07+00:00","description":"嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者.","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sunyazhou.com/2020/08/iOSinterviewAnswers2/"},"@context":"https://schema.org"}</script><title>阿里、字节：一套高效的iOS面试题之runtime相关问题2 | 迈腾大队长</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/images/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">迈腾大队长</a></div><div class="site-subtitle font-italic">不斷學習,與時俱進.求真務實,實事求是.</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3"></i> <span>主页</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3"></i> <span>归档</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3"></i> <span>分类</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3"></i> <span>标签</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/projects/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-paint-brush ml-xl-3 mr-xl-3"></i> <span>作品</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3"></i> <span>关于</span> </a></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } get isResolvedDarkMode() { if (this.isLightMode) { return false; } return this.isSysDarkPrefer; } updateCommentStyle() { var theme = "github-light"; if (this.isResolvedDarkMode) { theme = "photon-dark"; } let comment = document.querySelector("iframe.utterances-frame"); if (comment == null) { return; } comment.contentWindow.postMessage( { type: "set-theme", theme: theme }, "https://utteranc.es/" ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateCommentStyle(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/sunyazhou13" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/sunyazhou" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="https://www.weibo.com/sunyazhou13" aria-label="" target="_blank" rel="noopener"> <i class="fab fa-weibo"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sunyazhou','111.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 主页 </a> </span> <span>阿里、字节：一套高效的iOS面试题之runtime相关问题2</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>阿里、字节：一套高效的iOS面试题之runtime相关问题2</h1><div class="post-meta text-muted d-flex flex-column"><div> 　由 <span class="author"> 孙亚洲 </span> 发布于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Aug 8, 2020, 2:54 PM +0000" > 2020-08-08 <i class="unloaded">2020-08-08T14:54:07+00:00</i> </span></div><div> 最后更新: <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Apr 2, 2023, 4:42 PM +0800" > 2023-04-02 <i class="unloaded">2023-04-02T08:42:51+00:00</i> </span></div></div><div class="post-content"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.webp" alt="" /></p><h1 id="前言">前言</h1><blockquote><p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p></blockquote><p>本篇我们来讲一下 <a href="https://mp.weixin.qq.com/s/bDnsaD__ZpdHIk3_So382w">阿里、字节：一套高效的iOS面试题</a> 中的runtime相关问题部分的内存管理相关的内容.</p><h1 id="runtime相关问题之-内存管理">runtime相关问题之 内存管理</h1><p>基本内容包括:</p><ul><li>weak的实现原理？SideTable的结构是什么样的<li>关联对象的应用？系统如何实现关联对象的<li>关联对象的如何进行内存管理的？关联对象如何实现weak属性<li>Autoreleasepool的原理？所使用的的数据结构是什么<li>ARC的实现原理？ARC下对retain, release做了哪些优化<li>ARC下哪些情况会造成内存泄漏</ul><h2 id="weak的实现原理sidetable的结构是什么样的">weak的实现原理？SideTable的结构是什么样的</h2><p>先说结论:</p><ul><li><code class="language-plaintext highlighter-rouge">weak表</code>其实是一个hash(哈西)表.<code class="language-plaintext highlighter-rouge">Key</code>是所指对象的地址，<code class="language-plaintext highlighter-rouge">Value</code>是<code class="language-plaintext highlighter-rouge">weak</code>指针的地址数组.实现原理是通过新旧表的更新指针方式,对weak对象单独存储于<code class="language-plaintext highlighter-rouge">SideTable</code>中的<code class="language-plaintext highlighter-rouge">weak_table_t</code>(类型) <code class="language-plaintext highlighter-rouge">weak_table</code>表中,通过函数<code class="language-plaintext highlighter-rouge">objc_initWeak()</code>-&gt;<code class="language-plaintext highlighter-rouge">storeWeak()</code>函数中的新旧<code class="language-plaintext highlighter-rouge">SideTable</code>(结构体)表来实现<li><code class="language-plaintext highlighter-rouge">SideTable</code>是一个结构体，内部主要有引用计数表和弱引用表两个成员，内存存储的其实都是对象的地址和引用计数和weak变量的地址，而不是对象本身的数据,它的结构如下</ul><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">SideTable</span> <span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">slock</span><span class="p">;</span>
    <span class="n">RefcountMap</span> <span class="n">refcnts</span><span class="p">;</span>
    <span class="n">weak_table_t</span> <span class="n">weak_table</span><span class="p">;</span>
    <span class="n">SideTable</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">weak_table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">weak_table</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">SideTable</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">_objc_fatal</span><span class="p">(</span><span class="s">"Do not delete SideTable."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">lock</span><span class="p">()</span> <span class="p">{</span> <span class="n">slock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">unlock</span><span class="p">()</span> <span class="p">{</span> <span class="n">slock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">forceReset</span><span class="p">()</span> <span class="p">{</span> <span class="n">slock</span><span class="p">.</span><span class="n">forceReset</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// Address-ordered lock discipline for a pair of side tables.</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">HaveOld</span><span class="p">,</span> <span class="n">HaveNew</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">lockTwo</span><span class="p">(</span><span class="n">SideTable</span> <span class="o">*</span><span class="n">lock1</span><span class="p">,</span> <span class="n">SideTable</span> <span class="o">*</span><span class="n">lock2</span><span class="p">);</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">HaveOld</span><span class="p">,</span> <span class="n">HaveNew</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">unlockTwo</span><span class="p">(</span><span class="n">SideTable</span> <span class="o">*</span><span class="n">lock1</span><span class="p">,</span> <span class="n">SideTable</span> <span class="o">*</span><span class="n">lock2</span><span class="p">);</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="weak实现原理">weak实现原理</h3><p>实现原理概括分为3个时机</p><ul><li>1.初始化<li>2.添加引用<li>3.释放</ul><h4 id="1初始化时候">1.初始化时候</h4><p><code class="language-plaintext highlighter-rouge">runtime</code>会调用<code class="language-plaintext highlighter-rouge">objc_initWeak</code>函数，初始化一个新的<code class="language-plaintext highlighter-rouge">weak</code>指针指向对象的地址.</p><p>我们引入一段测试代码</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">NSObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
<span class="n">id</span> <span class="n">__weak</span> <span class="n">obj1</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</pre></table></code></div></div><p>当我们初始化一个weak变量时，<code class="language-plaintext highlighter-rouge">runtime</code>会调用<code class="language-plaintext highlighter-rouge">NSObject.mm</code>中的<code class="language-plaintext highlighter-rouge">objc_initWeak()</code>函数。这个函数在Clang中的声明如下：</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">id</span> <span class="nf">objc_initWeak</span><span class="p">(</span><span class="n">id</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="n">id</span> <span class="n">newObj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newObj</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 查看对象实例是否有效 无效对象直接导致指针释放</span>
        <span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 这里传递了三个 bool 数值 old, new, crash.使用 template 进行常量参数传递是为了优化性能</span>
    <span class="k">return</span> <span class="n">storeWeak</span><span class="o">&lt;</span><span class="n">DontHaveOld</span><span class="p">,</span> <span class="n">DoHaveNew</span><span class="p">,</span> <span class="n">DontCrashIfDeallocating</span><span class="o">&gt;</span>
        <span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="p">(</span><span class="n">objc_object</span><span class="o">*</span><span class="p">)</span><span class="n">newObj</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>可以看出，这个函数仅仅是一个深层函数的调用入口，而一般的入口函数中，都会做一些简单的判断（例如 <code class="language-plaintext highlighter-rouge">objc_msgSend</code> 中的缓存判断），这里判断了其指针指向的类对象是否有效，无效直接释放，不再往深层调用函数。否则，object将被注册为一个指向value的<code class="language-plaintext highlighter-rouge">__weak</code>对象。而这事应该是<code class="language-plaintext highlighter-rouge">objc_storeWeak</code>函数干的.</p><blockquote><p>注意： <code class="language-plaintext highlighter-rouge">objc_initWeak</code>函数有一个前提条件：就是object必须是一个没有被注册为<code class="language-plaintext highlighter-rouge">__weak</code>对象的有效指针。而value则可以是null，或者指向一个有效的对象.</p></blockquote><h4 id="2添加引用时">2.添加引用时</h4><p><code class="language-plaintext highlighter-rouge">objc_initWeak</code>函数会调用 <code class="language-plaintext highlighter-rouge">objc_storeWeak() </code>函数,<code class="language-plaintext highlighter-rouge">objc_storeWeak() </code>则会调用<code class="language-plaintext highlighter-rouge">storeWeak()</code>函数， <code class="language-plaintext highlighter-rouge">storeWeak()</code>的作用是更新指针指向，创建对应的弱引用表</p><p>模板</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// HaveOld:  true - 变量有值 ,false - 需要被及时清理，当前值可能为 nil</span>
<span class="c1">// HaveNew:  true - 需要被分配的新值，当前值可能为nil, false - 不需要分配新值</span>
<span class="c1">// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停,false - 用 nil 替代存储</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">HaveOld</span> <span class="n">haveOld</span><span class="p">,</span> <span class="n">HaveNew</span> <span class="n">haveNew</span><span class="p">,</span><span class="n">CrashIfDeallocating</span> <span class="n">crashIfDeallocating</span><span class="o">&gt;</span>
</pre></table></code></div></div><p>weak实现函数 <strong>该过程用来更新弱引用指针的指向</strong>.</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">id</span> 
<span class="nf">storeWeak</span><span class="p">(</span><span class="n">id</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="n">objc_object</span> <span class="o">*</span><span class="n">newObj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ASSERT</span><span class="p">(</span><span class="n">haveOld</span>  <span class="o">||</span>  <span class="n">haveNew</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">haveNew</span><span class="p">)</span> <span class="n">ASSERT</span><span class="p">(</span><span class="n">newObj</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">);</span>  
    <span class="c1">// 初始化 previouslyInitializedClass 指针.</span>
    <span class="n">Class</span> <span class="n">previouslyInitializedClass</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="n">id</span> <span class="n">oldObj</span><span class="p">;</span>
    <span class="c1">// 声明两个 SideTable,① 新旧散列创建</span>
    <span class="n">SideTable</span> <span class="o">*</span><span class="n">oldTable</span><span class="p">;</span>
    <span class="n">SideTable</span> <span class="o">*</span><span class="n">newTable</span><span class="p">;</span>
    <span class="c1">//获得新值和旧值的锁存位置(用地址作为唯一标示),通过地址来建立索引标志,防止桶重复,下面指向的操作会改变旧值.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">haveOld</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">oldObj</span> <span class="o">=</span> <span class="o">*</span><span class="n">location</span><span class="p">;</span><span class="c1">// 更改指针，获得以 oldObj 为索引所存储的值地址</span>
        <span class="n">oldTable</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">SideTables</span><span class="p">()[</span><span class="nf">oldObj</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">oldTable</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">haveNew</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">newTable</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">SideTables</span><span class="p">()[</span><span class="nf">newObj</span><span class="p">];</span><span class="c1">// 更改新值指针，获得以 newObj 为索引所存储的值地址</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">newTable</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 加锁操作，防止多线程中竞争冲突</span>
    <span class="n">SideTable</span><span class="o">::</span><span class="n">lockTwo</span><span class="o">&lt;</span><span class="n">haveOld</span><span class="p">,</span> <span class="n">haveNew</span><span class="o">&gt;</span><span class="p">(</span><span class="n">oldTable</span><span class="p">,</span> <span class="n">newTable</span><span class="p">);</span>
	<span class="c1">// 避免线程冲突重处理,location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">haveOld</span>  <span class="o">&amp;&amp;</span>  <span class="o">*</span><span class="n">location</span> <span class="o">!=</span> <span class="n">oldObj</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SideTable</span><span class="o">::</span><span class="n">unlockTwo</span><span class="o">&lt;</span><span class="n">haveOld</span><span class="p">,</span> <span class="n">haveNew</span><span class="o">&gt;</span><span class="p">(</span><span class="n">oldTable</span><span class="p">,</span> <span class="n">newTable</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 防止弱引用间死锁,并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">haveNew</span>  <span class="o">&amp;&amp;</span>  <span class="n">newObj</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">newObj</span><span class="o">-&gt;</span><span class="n">getIsa</span><span class="p">();</span><span class="c1">// 获得新对象的 isa 指针</span>
        <span class="c1">// 判断 isa 非空且已经初始化</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cls</span> <span class="o">!=</span> <span class="n">previouslyInitializedClass</span>  <span class="o">&amp;&amp;</span>  
            <span class="o">!</span><span class="p">((</span><span class="n">objc_class</span> <span class="o">*</span><span class="p">)</span><span class="n">cls</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">())</span> 
        <span class="p">{</span> 
            <span class="n">SideTable</span><span class="o">::</span><span class="n">unlockTwo</span><span class="o">&lt;</span><span class="n">haveOld</span><span class="p">,</span> <span class="n">haveNew</span><span class="o">&gt;</span><span class="p">(</span><span class="n">oldTable</span><span class="p">,</span> <span class="n">newTable</span><span class="p">);</span><span class="o">/</span> <span class="err">解锁</span>
            <span class="n">class_initialize</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">newObj</span><span class="p">);</span> <span class="c1">//如果该类已经完成执行 +initialize 方法是最理想情况,如果该类 +initialize 在线程中,例如 +initialize 正在调用 storeWeak 方法,需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记</span>
            <span class="n">previouslyInitializedClass</span> <span class="o">=</span> <span class="n">cls</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span> <span class="c1">//重试</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ② 清除旧值</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">haveOld</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">weak_unregister_no_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldTable</span><span class="o">-&gt;</span><span class="n">weak_table</span><span class="p">,</span> <span class="n">oldObj</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
    <span class="p">}</span>
	 <span class="c1">// ③ 分配新值</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">haveNew</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">newObj</span> <span class="o">=</span> <span class="p">(</span><span class="n">objc_object</span> <span class="o">*</span><span class="p">)</span>
            <span class="n">weak_register_no_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newTable</span><span class="o">-&gt;</span><span class="n">weak_table</span><span class="p">,</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">newObj</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> 
                                  <span class="n">crashIfDeallocating</span><span class="p">);</span>
        <span class="c1">//如果弱引用被释放 weak_register_no_lock 方法返回 nil,在引用计数表中设置若引用标记位</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newObj</span>  <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">newObj</span><span class="o">-&gt;</span><span class="n">isTaggedPointer</span><span class="p">())</span> <span class="p">{</span>
	        <span class="c1">//弱引用位初始化操作,引用计数那张散列表的weak引用对象的引用计数中标识为weak引用</span>
            <span class="n">newObj</span><span class="o">-&gt;</span><span class="n">setWeaklyReferenced_nolock</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">//之前不要设置 location 对象，这里需要更改指针指向</span>
        <span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">newObj</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 没有新值，则无需更改</span>
    <span class="p">}</span>
    
    <span class="n">SideTable</span><span class="o">::</span><span class="n">unlockTwo</span><span class="o">&lt;</span><span class="n">haveOld</span><span class="p">,</span> <span class="n">haveNew</span><span class="o">&gt;</span><span class="p">(</span><span class="n">oldTable</span><span class="p">,</span> <span class="n">newTable</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">newObj</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h5 id="sidetable">SideTable</h5><p>SideTable就是一个结构体，内部主要有引用计数表和弱引用表两个成员，内存存储的其实都是对象的地址和引用计数和weak变量的地址，而不是对象本身的数据.</p><blockquote><p>主要用于管理对象的引用计数和 weak 表.</p></blockquote><p>我们来看图</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20200808iOSinterviewAnswers/SideTableStructure.webp" alt="" /></p><blockquote><p>操作系统维护64个SideTable，通过对象的地址位置hash之后模64(就是%64求余数)找到指定的SideTable 每个SideTable维护了一个RefcountMap的引用计数表，key就是对象地址，value就是此对象的引用计数</p></blockquote><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">SideTable</span> <span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">slock</span><span class="p">;</span> <span class="c1">//保证原子操作的自旋锁</span>
    <span class="n">RefcountMap</span> <span class="n">refcnts</span><span class="p">;</span> <span class="c1">//引用计数的 hash 表</span>
    <span class="n">weak_table_t</span> <span class="n">weak_table</span><span class="p">;</span> <span class="c1">//weak 引用全局 hash 表</span>
    <span class="p">...</span>
<span class="p">};</span>

</pre></table></code></div></div><ul><li>slock 防止竞争的自旋锁<li>refcnts 协助对象的 isa 指针的<code class="language-plaintext highlighter-rouge">extra_rc</code>共同引用计数的变量</ul><h5 id="weak表">weak表</h5><p>弱引用hash表,<code class="language-plaintext highlighter-rouge">weak_table_t</code>类型的结构体,存储某个实例对象相关的所有弱引用信息. 定义如下:</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">weak_table_t</span> <span class="p">{</span>
    <span class="n">weak_entry_t</span> <span class="o">*</span><span class="n">weak_entries</span><span class="p">;</span> <span class="c1">// 保存了所有指向指定对象的 weak 指针</span>
    <span class="kt">size_t</span>    <span class="n">num_entries</span><span class="p">;</span>		 <span class="c1">// 存储空间</span>
    <span class="kt">uintptr_t</span> <span class="n">mask</span><span class="p">;</span>     			<span class="c1">// 参与判断引用计数辅助量</span>
    <span class="kt">uintptr_t</span> <span class="n">max_hash_displacement</span><span class="p">;</span>     <span class="c1">// hash key 最大偏移值</span>
<span class="p">};</span>
</pre></table></code></div></div><p>这是一个全局弱引用hash表。使用不定类型对象的地址作为<code class="language-plaintext highlighter-rouge">key</code>，用<code class="language-plaintext highlighter-rouge">weak_entry_t</code>类型结构体对象作为<code class="language-plaintext highlighter-rouge">value</code>,其中的<code class="language-plaintext highlighter-rouge">weak_entries</code> 成员,即为弱引用表入口.</p><p>其中<code class="language-plaintext highlighter-rouge">weak_entry_t</code>是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。其定义如下：</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="n">DisguisedPtr</span><span class="o">&lt;</span><span class="n">objc_object</span> <span class="o">*&gt;</span> <span class="n">weak_referrer_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">weak_entry_t</span> <span class="p">{</span>
    <span class="n">DisguisedPtr</span><span class="o">&lt;</span><span class="n">objc_object</span><span class="o">&gt;</span> <span class="n">referent</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="n">weak_referrer_t</span> <span class="o">*</span><span class="n">referrers</span><span class="p">;</span>
            <span class="kt">uintptr_t</span>        <span class="n">out_of_line_ness</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
            <span class="kt">uintptr_t</span>        <span class="n">num_refs</span> <span class="o">:</span> <span class="n">PTR_MINUS_2</span><span class="p">;</span>
            <span class="kt">uintptr_t</span>        <span class="n">mask</span><span class="p">;</span>
            <span class="kt">uintptr_t</span>        <span class="n">max_hash_displacement</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="c1">// out_of_line_ness field is low bits of inline_referrers[1]</span>
            <span class="n">weak_referrer_t</span>  <span class="n">inline_referrers</span><span class="p">[</span><span class="nf">WEAK_INLINE_COUNT</span><span class="p">];</span>
        <span class="p">};</span>
    <span class="p">};</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></table></code></div></div><p>其中<code class="language-plaintext highlighter-rouge">DisguisedPtr</code>类型的<code class="language-plaintext highlighter-rouge">referent</code>变量是<strong>对泛型对象的指针的封装</strong>,通过这个<code class="language-plaintext highlighter-rouge">泛型类</code>来解决内存泄露的问题.</p><p>注释中有个很重要的<code class="language-plaintext highlighter-rouge">out_of_line</code>成员,它代表最低的有效位,当它为0的时候,<code class="language-plaintext highlighter-rouge">weak_referrer_t </code>成员将扩展为多行静态的<code class="language-plaintext highlighter-rouge">hask table</code>.</p><p>其中<code class="language-plaintext highlighter-rouge">weak_referrer_t </code> 是一个二维<code class="language-plaintext highlighter-rouge">objc_object</code>的别名(typedef),通过一个二维指针地址偏移,用下标作hash的<code class="language-plaintext highlighter-rouge">key</code>,做成了一个弱引用的散列。</p><p>那么<code class="language-plaintext highlighter-rouge">weak_entry_t</code>中的各成员<code class="language-plaintext highlighter-rouge">out_of_line</code>、<code class="language-plaintext highlighter-rouge">num_refs</code>、<code class="language-plaintext highlighter-rouge">mask</code> 、<code class="language-plaintext highlighter-rouge">max_hash_displacement</code> 在有效位未生效的时候有什么作用？</p><ul><li><code class="language-plaintext highlighter-rouge">out_of_line</code>:最低有效位，也是标志位。当标志位 0 时，增加引用表指针纬度。<li><code class="language-plaintext highlighter-rouge">num_refs</code>: 引用数值。这里记录弱引用表中引用有效数字，因为弱引用表使用的是静态 hash 结构，所以需要使用变量来记录数目。<li><code class="language-plaintext highlighter-rouge">mask</code>:计数辅助量。<li><code class="language-plaintext highlighter-rouge">max_hash_displacement</code>:<code class="language-plaintext highlighter-rouge">hash</code>元素上限阀值。</ul><blockquote><p>其实 <code class="language-plaintext highlighter-rouge">out_of_line</code> 的值通常情况下是等于零的，所以弱引用表总是一个<code class="language-plaintext highlighter-rouge">objc_objective</code>指针二维数组。一维 <code class="language-plaintext highlighter-rouge">objc_objective</code>指针可构成一张弱引用散列表，通过第三纬度实现了多张散列表，并且表数量为 <code class="language-plaintext highlighter-rouge">WEAK_INLINE_COUNT</code>.</p></blockquote><p>以上是weak表的实现原理.</p><h4 id="3释放">3.释放</h4><p>释放时，调用<code class="language-plaintext highlighter-rouge">clearDeallocating</code>函数。<code class="language-plaintext highlighter-rouge">clearDeallocating</code>函数首先根据对象地址获取所有<code class="language-plaintext highlighter-rouge">weak</code>指针地址的数组，然后遍历这个数组把其中的数据设为<code class="language-plaintext highlighter-rouge">nil</code>，最后把这个<code class="language-plaintext highlighter-rouge">entry</code>从<code class="language-plaintext highlighter-rouge">weak</code>表中删除，最后清理对象的记录.</p><h5 id="当weak引用指向的对象被释放时又是如何去处理weak指针的呢当释放对象时其基本流程如下">当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下:</h5><ul><li>1.调用<code class="language-plaintext highlighter-rouge">objc_release</code><li>2.因为对象的引用计数为0，所以执行<code class="language-plaintext highlighter-rouge">dealloc</code><li>3.在dealloc中，调用了<code class="language-plaintext highlighter-rouge">_objc_rootDealloc</code>函数<li>4.在<code class="language-plaintext highlighter-rouge">_objc_rootDealloc</code>中，调用了<code class="language-plaintext highlighter-rouge">object_dispose</code>函数<li>5.调用<code class="language-plaintext highlighter-rouge">objc_destructInstance</code><li>6.最后调用<code class="language-plaintext highlighter-rouge">objc_clear_deallocating</code></ul><p>重点看对象被释放时调用的<code class="language-plaintext highlighter-rouge">objc_clear_deallocating</code>函数。该函数实现如下:</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">objc_clear_deallocating</span><span class="p">(</span><span class="n">id</span> <span class="n">obj</span><span class="p">)</span>  
<span class="p">{</span>
    <span class="n">ASSERT</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">isTaggedPointer</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">clearDeallocating</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>调用了<code class="language-plaintext highlighter-rouge">clearDeallocating()</code>,点击源码进去追踪发现,它最终是使用了迭代器来取<code class="language-plaintext highlighter-rouge">weak</code>表的<code class="language-plaintext highlighter-rouge">value</code>,然后调用<code class="language-plaintext highlighter-rouge">weak_clear_no_lock()</code>查找对应<code class="language-plaintext highlighter-rouge">value</code>,将该<code class="language-plaintext highlighter-rouge">weak</code>指针置空.</p><p><code class="language-plaintext highlighter-rouge">weak_clear_no_lock()</code>函数的实现如下:</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">weak_clear_no_lock</span><span class="p">(</span><span class="n">weak_table_t</span> <span class="o">*</span><span class="n">weak_table</span><span class="p">,</span> <span class="n">id</span> <span class="n">referent_id</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">objc_object</span> <span class="o">*</span><span class="n">referent</span> <span class="o">=</span> <span class="p">(</span><span class="n">objc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">referent_id</span><span class="p">;</span>
    <span class="n">weak_entry_t</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">weak_entry_for_referent</span><span class="p">(</span><span class="n">weak_table</span><span class="p">,</span> <span class="n">referent</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">/// XXX shouldn't happen, but does with mismatched CF/objc</span>
        <span class="c1">//printf("XXX no entry for clear deallocating %p\n", referent);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// zero out references</span>
    <span class="n">weak_referrer_t</span> <span class="o">*</span><span class="n">referrers</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">out_of_line</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">referrers</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">referrers</span><span class="p">;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">TABLE_SIZE</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
    <span class="p">}</span> 
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">referrers</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">inline_referrers</span><span class="p">;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">WEAK_INLINE_COUNT</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">objc_object</span> <span class="o">**</span><span class="n">referrer</span> <span class="o">=</span> <span class="n">referrers</span><span class="p">[</span><span class="nf">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">referrer</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">referrer</span> <span class="o">==</span> <span class="n">referent</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">referrer</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">referrer</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">_objc_inform</span><span class="p">(</span><span class="s">"__weak variable at %p holds %p instead of %p. "</span>
                             <span class="s">"This is probably incorrect use of "</span>
                             <span class="s">"objc_storeWeak() and objc_loadWeak(). "</span>
                             <span class="s">"Break on objc_weak_error to debug.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> 
                             <span class="n">referrer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">referrer</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">referent</span><span class="p">);</span>
                <span class="n">objc_weak_error</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">weak_entry_remove</span><span class="p">(</span><span class="n">weak_table</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">objc_clear_deallocating()</code>该函数的动作如下：</p><ul><li>1.从weak表中获取废弃对象的地址为键值的记录<li>2.将包含在记录中的所有附有 weak修饰符变量的地址，赋值为nil<li>3.将weak表中该记录删除<li>4.从引用计数表中删除废弃对象的地址为键值的记录</ul><p><a href="https://www.jianshu.com/p/13c4fb1cedea">参考</a></p><h2 id="关联对象的应用系统如何实现关联对象的">关联对象的应用？系统如何实现关联对象的</h2><h3 id="关联对象的应用">关联对象的应用？</h3><p>一般应用在<code class="language-plaintext highlighter-rouge">category</code>(分类)中为 当前类 添加关联属性,因为不能直接添加成员变量，但是可以通过runtime的方式间接实现添加成员变量的效果。</p><p>当我们在<code class="language-plaintext highlighter-rouge">category</code>中声明如下代码:</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">@interface</span> <span class="nc">ClassA</span> <span class="p">:</span> <span class="nc">NSObject</span> <span class="p">(</span><span class="n">Category</span><span class="p">)</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">property</span><span class="p">;</span>
<span class="k">@end</span>
</pre></table></code></div></div><p>实际上<code class="language-plaintext highlighter-rouge">@property</code>这个objc标准库的内建关键字帮我们实现了 setter和 getter,但是在category中并不能帮我们声明成员变量 <code class="language-plaintext highlighter-rouge">property</code> 我们需要通过runtime提供的两个C函数的api间接实现 动态添加 成员变量<code class="language-plaintext highlighter-rouge">property</code>.</p><ul><li><code class="language-plaintext highlighter-rouge">objc_setAssociatedObject()</code><li><code class="language-plaintext highlighter-rouge">objc_getAssociatedObject()</code></ul><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#import "ClassA+Category.h"
#import &lt;objc/runtime.h&gt;
</span>
<span class="k">@implementation</span> <span class="nc">ClassA</span> <span class="p">(</span><span class="nl">Category</span><span class="p">)</span>

<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span> <span class="n">property</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setProperty</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">categoryProperty</span> <span class="p">{</span>
    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">property</span><span class="p">),</span> <span class="n">categoryProperty</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">@end</span>
</pre></table></code></div></div><p>看到上面的关联方法,我们来仔细研究一下下面经常使用的关联属性相关的API</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">objc_setAssociatedObject</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">id</span> <span class="n">value</span><span class="p">,</span> <span class="n">objc_AssociationPolicy</span> <span class="n">policy</span><span class="p">);</span>
<span class="n">id</span> <span class="nf">objc_getAssociatedObject</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">objc_removeAssociatedObjects</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">);</span>
</pre></table></code></div></div><ol><li><code class="language-plaintext highlighter-rouge">objc_setAssociatedObject()</code>以键值对形式添加关联对象<li><code class="language-plaintext highlighter-rouge">objc_getAssociatedObject()</code>根据 key 获取关联对象<li><code class="language-plaintext highlighter-rouge">objc_removeAssociatedObjects()</code>移除所有关联对象</ol><p><code class="language-plaintext highlighter-rouge">objc_setAssociatedObject()</code>的调用栈</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">id</span> <span class="n">value</span><span class="p">,</span> <span class="n">objc_AssociationPolicy</span> <span class="n">policy</span><span class="p">)</span>
<span class="err">└──</span> <span class="n">SetAssocHook</span><span class="p">.</span><span class="n">get</span><span class="p">()(</span><span class="n">object</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>
    <span class="err">└──</span> <span class="kt">void</span> <span class="n">_object_set_associative_reference</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">id</span> <span class="n">value</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">policy</span><span class="p">)</span>
</pre></table></code></div></div><p>上述调用栈中的<code class="language-plaintext highlighter-rouge">_object_set_associative_reference()</code>函数实际完成了设置关联对象的任务：</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">_object_set_associative_reference</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">id</span> <span class="n">value</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">value</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">getIsa</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">forbidsAssociatedObjects</span><span class="p">())</span>
        <span class="n">_objc_fatal</span><span class="p">(</span><span class="s">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">object_getClassName</span><span class="p">(</span><span class="n">object</span><span class="p">));</span>
    <span class="n">DisguisedPtr</span><span class="o">&lt;</span><span class="n">objc_object</span><span class="o">&gt;</span> <span class="n">disguised</span><span class="p">{(</span><span class="n">objc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">};</span>
    <span class="n">ObjcAssociation</span> <span class="n">association</span><span class="p">{</span><span class="n">policy</span><span class="p">,</span> <span class="n">value</span><span class="p">};</span>
    <span class="n">association</span><span class="p">.</span><span class="n">acquireValue</span><span class="p">();</span>
    <span class="p">{</span>
        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span>
        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">refs_result</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">try_emplace</span><span class="p">(</span><span class="n">disguised</span><span class="p">,</span> <span class="n">ObjectAssociationMap</span><span class="p">{});</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">refs_result</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">object</span><span class="o">-&gt;</span><span class="n">setHasAssociatedObjects</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">auto</span> <span class="o">&amp;</span><span class="n">refs</span> <span class="o">=</span> <span class="n">refs_result</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
            <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">refs</span><span class="p">.</span><span class="n">try_emplace</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">association</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">association</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">association</span><span class="p">.</span><span class="n">releaseHeldValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>省略的很多代码,上述代码中就是应用场景,上面调用的类<code class="language-plaintext highlighter-rouge">AssociationsManager</code>就是我们下面要讲的系统如何实现关联对象的原理.</p><h3 id="系统如何实现关联对象的关联对象实现原理">系统如何实现关联对象的(关联对象实现原理)</h3><p>实现关联对象技术的核心对象 有如下这么几个:</p><ol><li>AssociationsManager<li>AssociationsHashMap<li>ObjectAssociationMap<li>ObjcAssociation</ol><blockquote><p>其中Map同我们平时使用的字典类似。通过<code class="language-plaintext highlighter-rouge">key</code>-<code class="language-plaintext highlighter-rouge">value</code>的形式对应存值.</p></blockquote><p>下面我们通过源码来一探究竟</p><h4 id="objc_setassociatedobject函数"><code class="language-plaintext highlighter-rouge">objc_setAssociatedObject()</code>函数</h4><p>runtime源码</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>void objc_setAssociatedObject<span class="o">(</span><span class="nb">id </span>object, const void <span class="k">*</span>key, <span class="nb">id </span>value, objc_AssociationPolicy policy<span class="o">)</span>
<span class="o">{</span>
    _object_set_associative_reference<span class="o">(</span>object, key, value, policy<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p>源码调用过程有hook函数,有点长,这里我简化一下,直接调用核心的函数</p></blockquote><p>下面看下<code class="language-plaintext highlighter-rouge">_object_set_associative_reference()</code>函数的代码实现</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">_object_set_associative_reference</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">id</span> <span class="n">value</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">getIsa</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">forbidsAssociatedObjects</span><span class="p">())</span>
        <span class="n">_objc_fatal</span><span class="p">(</span><span class="s">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">object_getClassName</span><span class="p">(</span><span class="n">object</span><span class="p">));</span>
    <span class="n">DisguisedPtr</span><span class="o">&lt;</span><span class="n">objc_object</span><span class="o">&gt;</span> <span class="n">disguised</span><span class="p">{(</span><span class="n">objc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">};</span>
    <span class="n">ObjcAssociation</span> <span class="n">association</span><span class="p">{</span><span class="n">policy</span><span class="p">,</span> <span class="n">value</span><span class="p">};</span> <span class="c1">//4. 我们用到的ObjcAssociation</span>
    <span class="n">association</span><span class="p">.</span><span class="n">acquireValue</span><span class="p">();</span>
    <span class="p">{</span>
        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span> <span class="c1">//1. 我们用到的AssociationsManager</span>
        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">get</span><span class="p">());</span> <span class="c1">//2.我们上面列举的AssociationsHashMap</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">refs_result</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">try_emplace</span><span class="p">(</span><span class="n">disguised</span><span class="p">,</span> <span class="n">ObjectAssociationMap</span><span class="p">{});</span> <span class="c1">//3.我们用到的ObjectAssociationMap</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">refs_result</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">object</span><span class="o">-&gt;</span><span class="n">setHasAssociatedObjects</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">auto</span> <span class="o">&amp;</span><span class="n">refs</span> <span class="o">=</span> <span class="n">refs_result</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
            <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">refs</span><span class="p">.</span><span class="n">try_emplace</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">association</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">association</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">refs_it</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">disguised</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">refs_it</span> <span class="o">!=</span> <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="o">&amp;</span><span class="n">refs</span> <span class="o">=</span> <span class="n">refs_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
                <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">refs</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">refs</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">association</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
                    <span class="n">refs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">refs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">associations</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">refs_it</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">association</span><span class="p">.</span><span class="n">releaseHeldValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上述代码可以找到我们实现关联对象技术的核心对象. 下面我们分别介绍一下几个核心对象的内部实现.</p><h5 id="associationsmanager">AssociationsManager</h5><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="n">DenseMap</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">ObjcAssociation</span><span class="o">&gt;</span> <span class="n">ObjectAssociationMap</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">DenseMap</span><span class="o">&lt;</span><span class="n">DisguisedPtr</span><span class="o">&lt;</span><span class="n">objc_object</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ObjectAssociationMap</span><span class="o">&gt;</span> <span class="n">AssociationsHashMap</span><span class="p">;</span>
<span class="n">class</span> <span class="n">AssociationsManager</span> <span class="p">{</span>
    <span class="n">using</span> <span class="n">Storage</span> <span class="o">=</span> <span class="n">ExplicitInitDenseMap</span><span class="o">&lt;</span><span class="n">DisguisedPtr</span><span class="o">&lt;</span><span class="n">objc_object</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ObjectAssociationMap</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">Storage</span> <span class="n">_mapStorage</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">AssociationsManager</span><span class="p">()</span>   <span class="p">{</span> <span class="n">AssociationsManagerLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">AssociationsManager</span><span class="p">()</span>  <span class="p">{</span> <span class="n">AssociationsManagerLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">get</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_mapStorage</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">_mapStorage</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">AssociationsManager</code>内部有一个<code class="language-plaintext highlighter-rouge">get()</code>函数返回一个<code class="language-plaintext highlighter-rouge">AssociationsHashMap</code>对象</p><h5 id="associationshashmap">AssociationsHashMap</h5><p><code class="language-plaintext highlighter-rouge">AssociationsHashMap</code> 是<code class="language-plaintext highlighter-rouge">DenseMap</code>的typedef(可以理解为别名) 只不过它被定义成符合某些<code class="language-plaintext highlighter-rouge">元组</code>的条件的<code class="language-plaintext highlighter-rouge">DenseMap</code>类型</p><p>实际上 <code class="language-plaintext highlighter-rouge">AssociationsHashMap</code> 用与保存从对象的 <code class="language-plaintext highlighter-rouge">disguised_ptr_t </code>到 <code class="language-plaintext highlighter-rouge">ObjectAssociationMap</code>的映射,这个数据结构保存了当前对象对应的所有关联对象</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="n">DenseMap</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">ObjcAssociation</span><span class="o">&gt;</span> <span class="n">ObjectAssociationMap</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">DenseMap</span><span class="o">&lt;</span><span class="n">DisguisedPtr</span><span class="o">&lt;</span><span class="n">objc_object</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ObjectAssociationMap</span><span class="o">&gt;</span> <span class="n">AssociationsHashMap</span><span class="p">;</span>
</pre></table></code></div></div><p>这里的<code class="language-plaintext highlighter-rouge">ObjectAssociationMap </code>是另一类型的typedef,里面存着<code class="language-plaintext highlighter-rouge">ObjcAssociation</code>类型的对象指针的key,value形式.</p><p>下面再看下 <code class="language-plaintext highlighter-rouge">ObjcAssociation</code> ,这是一个C++的类对象,最关键的<code class="language-plaintext highlighter-rouge">ObjcAssociation</code>包含了<code class="language-plaintext highlighter-rouge">policy</code>以及<code class="language-plaintext highlighter-rouge">value</code>.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">ObjcAssociation</span> <span class="p">{</span>
    <span class="kt">uintptr_t</span> <span class="n">_policy</span><span class="p">;</span>
    <span class="n">id</span> <span class="n">_value</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">ObjcAssociation</span><span class="p">(</span><span class="kt">uintptr_t</span> <span class="n">policy</span><span class="p">,</span> <span class="n">id</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">),</span> <span class="n">_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">ObjcAssociation</span><span class="p">()</span> <span class="o">:</span> <span class="n">_policy</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_value</span><span class="p">(</span><span class="n">nil</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">ObjcAssociation</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjcAssociation</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">ObjcAssociation</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjcAssociation</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">ObjcAssociation</span><span class="p">(</span><span class="n">ObjcAssociation</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">ObjcAssociation</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">ObjcAssociation</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">_policy</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">_policy</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">_value</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">_value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kr">inline</span> <span class="kt">uintptr_t</span> <span class="n">policy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_policy</span><span class="p">;</span> <span class="p">}</span>
    <span class="kr">inline</span> <span class="n">id</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></table></code></div></div><h5 id="关联对象在内存中以什么形式存储的">关联对象在内存中以什么形式存储的？</h5><p>示例代码</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">NSObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSObject</span> <span class="nf">new</span><span class="p">];</span>
        <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">hello</span><span class="p">),</span> <span class="s">@"Hello"</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这个调用函数<code class="language-plaintext highlighter-rouge">objc_setAssociatedObject(OBJC_ASSOCIATION_RETAIN_NONATOMIC, @"Hello")</code>在内存中是这样的存储结构</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20200808iOSinterviewAnswers/AssociationOrder.webp" alt="" /></p><h5 id="objc_setassociatedobject"><code class="language-plaintext highlighter-rouge">objc_setAssociatedObject()</code></h5><p>我们回头来详细分解一下<code class="language-plaintext highlighter-rouge">objc_setAssociatedObject()</code>函数中的真实实现部分,<code class="language-plaintext highlighter-rouge">_object_set_associative_reference()</code></p><p>这个函数需要传入<code class="language-plaintext highlighter-rouge">(id object, const void *key, id value, uintptr_t policy)</code>,这么几个参数,我们拿第3个<code class="language-plaintext highlighter-rouge">value</code>参数来分解.</p><p>我们分解为2步</p><ol><li><code class="language-plaintext highlighter-rouge">value != nil</code> 设置或者更新关联对象的值<li><code class="language-plaintext highlighter-rouge">value == nil</code> 删除一个关联对象.</ol><p>下面是具体是代码解释 <strong>注意看代码注释!!!</strong></p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">_object_set_associative_reference</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">id</span> <span class="n">value</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">policy</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 判空</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">value</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

	<span class="c1">// 判断本类对象是否允许关联其他对象.如果允许则进入代码块</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">getIsa</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">forbidsAssociatedObjects</span><span class="p">())</span>
        <span class="n">_objc_fatal</span><span class="p">(</span><span class="s">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">object_getClassName</span><span class="p">(</span><span class="n">object</span><span class="p">));</span>

	<span class="c1">// 将被关联的对象封装成DisguisedPtr方便在后边hash表中的管理,它的作用就像是一个指针</span>
    <span class="n">DisguisedPtr</span><span class="o">&lt;</span><span class="n">objc_object</span><span class="o">&gt;</span> <span class="n">disguised</span><span class="p">{(</span><span class="n">objc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">};</span>
    <span class="c1">// 将需要关联的对象,封装成ObjcAssociation,方便管理</span>
    <span class="n">ObjcAssociation</span> <span class="n">association</span><span class="p">{</span><span class="n">policy</span><span class="p">,</span> <span class="n">value</span><span class="p">};</span>

    <span class="c1">// 处理policy为retain和copy的修饰情况,</span>
    <span class="n">association</span><span class="p">.</span><span class="n">acquireValue</span><span class="p">();</span>

    <span class="p">{</span>
    	<span class="c1">// 获取关联对象管理者对象</span>
        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span>
        <span class="c1">// 根据管理者对象获取对应关联表(HashMap)</span>
        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        	<span class="c1">// 如果这个disguised存在于ObjectAssociationMap()中,则替换,如果不存在则初始化后在插入</span>
        	<span class="c1">// 这里说明一下,我们关联的对象关系存在于ObjectAssociationMap中,而</span>
        	<span class="c1">//	ObjectAssociationMap有多个,所以,这一步是对ObjectAssociationMap的一个管理,下边才是对我们要关联的对象的操作</span>
            <span class="k">auto</span> <span class="n">refs_result</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">try_emplace</span><span class="p">(</span><span class="n">disguised</span><span class="p">,</span> <span class="n">ObjectAssociationMap</span><span class="p">{});</span>
            <span class="c1">// 如果这是此对象第一次被关联</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">refs_result</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
               <span class="c1">// 修改isa_t中的has_assoc字段,标记其被关联状态</span>
                <span class="n">object</span><span class="o">-&gt;</span><span class="n">setHasAssociatedObjects</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="c1">// 这里才是对我们要关联的对象操作</span>
            <span class="k">auto</span> <span class="o">&amp;</span><span class="n">refs</span> <span class="o">=</span> <span class="n">refs_result</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
            <span class="c1">// 想map中插入key value对</span>
            <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">refs</span><span class="p">.</span><span class="n">try_emplace</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">association</span><span class="p">));</span>
            <span class="c1">// 这里没有看懂,为什么没有第二个就要交换一下..</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">association</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        	<span class="c1">// value为空, 并且在associations中有记录,则进行擦除操作 </span>
            <span class="k">auto</span> <span class="n">refs_it</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">disguised</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">refs_it</span> <span class="o">!=</span> <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="o">&amp;</span><span class="n">refs</span> <span class="o">=</span> <span class="n">refs_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
                <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">refs</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">refs</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">association</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
                    <span class="n">refs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">refs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">associations</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">refs_it</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// release the old value (outside of the lock).</span>
    <span class="n">association</span><span class="p">.</span><span class="n">releaseHeldValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h5 id="objc_setassociatedobject函数的作用是什么"><code class="language-plaintext highlighter-rouge">objc_setAssociatedObject()</code>函数的作用是什么?</h5><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="kt">void</span>
<span class="n">objc_object</span><span class="o">::</span><span class="n">setHasAssociatedObjects</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isTaggedPointer</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

 <span class="nl">retry:</span>
    <span class="n">isa_t</span> <span class="n">oldisa</span> <span class="o">=</span> <span class="n">LoadExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
    <span class="n">isa_t</span> <span class="n">newisa</span> <span class="o">=</span> <span class="n">oldisa</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newisa</span><span class="p">.</span><span class="n">nonpointer</span>  <span class="o">||</span>  <span class="n">newisa</span><span class="p">.</span><span class="n">has_assoc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ClearExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">newisa</span><span class="p">.</span><span class="n">has_assoc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">StoreExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">oldisa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">newisa</span><span class="p">.</span><span class="n">bits</span><span class="p">))</span> <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>它会将<code class="language-plaintext highlighter-rouge">isa</code>结构体中的标记位<code class="language-plaintext highlighter-rouge">has_assoc</code>标记为<code class="language-plaintext highlighter-rouge">true</code>，也就是表示当前对象有关联对象，如下图<code class="language-plaintext highlighter-rouge">isa</code>中的各个标记位都是干什么的.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20200808iOSinterviewAnswers/isa.webp" alt="" /></p><h5 id="objc_getassociatedobject"><code class="language-plaintext highlighter-rouge">objc_getAssociatedObject()</code></h5><p>这个函数的调用栈如下</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">id </span>objc_getAssociatedObject<span class="o">(</span><span class="nb">id </span>object, const void <span class="k">*</span>key<span class="o">)</span>
└── <span class="nb">id </span>_object_get_associative_reference<span class="o">(</span><span class="nb">id </span>object, const void <span class="k">*</span>key<span class="o">)</span><span class="p">;</span>
</pre></table></code></div></div><p>通过上面我们介绍，理解这个函数相当简单了</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">id</span>
<span class="nf">_object_get_associative_reference</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ObjcAssociation</span> <span class="n">association</span><span class="p">{};</span>
    <span class="p">{</span>
        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span> <span class="c1">//1</span>
        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">get</span><span class="p">());</span> <span class="c1">//1</span>
        <span class="n">AssociationsHashMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">((</span><span class="n">objc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">);</span> <span class="c1">//2</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">ObjectAssociationMap</span> <span class="o">&amp;</span><span class="n">refs</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
            <span class="n">ObjectAssociationMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">j</span> <span class="o">=</span> <span class="n">refs</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">refs</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">association</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
                <span class="n">association</span><span class="p">.</span><span class="n">retainReturnedValue</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">association</span><span class="p">.</span><span class="n">autoreleaseReturnedValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><ol><li>通过<code class="language-plaintext highlighter-rouge">AssociationsManager</code>拿到<code class="language-plaintext highlighter-rouge">AssociationsHashMap</code>哈西表<li>通过哈西表寻找关联对象<li>剩下的就是更新对象是否初次创建等标记 然后返回对象</ol><h5 id="objc_removeassociatedobjects"><code class="language-plaintext highlighter-rouge">objc_removeAssociatedObjects()</code></h5><p>调用栈如下:</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>void objc_removeAssociatedObjects<span class="o">(</span><span class="nb">id </span>object<span class="o">)</span>
└── void _object_remove_assocations<span class="o">(</span><span class="nb">id </span>object<span class="o">)</span>
</pre></table></code></div></div><p>代码具体实现</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">objc_removeAssociatedObjects</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">&amp;&amp;</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">hasAssociatedObjects</span><span class="p">())</span> <span class="p">{</span> 
        <span class="n">_object_remove_assocations</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>check对象是否为nil 且 关联对象是否存在</p></blockquote><p>然后调用实现跟上边的get差不多</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">void</span>
<span class="nf">_object_remove_assocations</span><span class="p">(</span><span class="n">id</span> <span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ObjectAssociationMap</span> <span class="n">refs</span><span class="p">{};</span>
    <span class="p">{</span>
        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span>
        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
        <span class="n">AssociationsHashMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">((</span><span class="n">objc_object</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">refs</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
            <span class="n">associations</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// release everything (outside of the lock).</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">:</span> <span class="n">refs</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">releaseHeldValue</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>通过<code class="language-plaintext highlighter-rouge">AssociationsManager</code> -&gt; <code class="language-plaintext highlighter-rouge">AssociationsHashMap</code> -&gt; object 是否存在,如果存在就<strong>擦除</strong>.- &gt; releaseHeldValue()是否对象</p><h4 id="小结">小结</h4><p>关联对象的应用和系统如何实现关联对象的大概顺序如下:<br /> <code class="language-plaintext highlighter-rouge">AssociationsManager</code>关联对象管理器-&gt;<code class="language-plaintext highlighter-rouge">AssociationsHashMap</code>哈希映射表-&gt;<code class="language-plaintext highlighter-rouge">ObjectAssociationMap</code>关联对象指针-&gt;<code class="language-plaintext highlighter-rouge">ObjcAssociation</code>关联对象</p><h2 id="关联对象的如何进行内存管理的关联对象如何实现weak属性">关联对象的如何进行内存管理的？关联对象如何实现weak属性?</h2><h3 id="关联对象的如何进行内存管理的">关联对象的如何进行内存管理的？</h3><p>当我调用关联对象函数<code class="language-plaintext highlighter-rouge">objc_setAssociatedObject()</code>的时候会调用如下函数：</p><p><code class="language-plaintext highlighter-rouge">_object_set_associative_reference(id object, const void *key, id value, uintptr_t policy)</code>,这里面有个方法</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">ObjcAssociation</span> <span class="n">association</span><span class="p">{</span><span class="n">policy</span><span class="p">,</span> <span class="n">value</span><span class="p">};</span>
<span class="c1">// retain the new value (if any) outside the lock.</span>
<span class="n">association</span><span class="p">.</span><span class="n">acquireValue</span><span class="p">();</span>
</pre></table></code></div></div><p>这里的 <code class="language-plaintext highlighter-rouge">policy</code>就是具体绝对内存使用retain还是其它相关的内存枚举.</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="p">{</span>
    <span class="n">OBJC_ASSOCIATION_SETTER_ASSIGN</span>      <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">OBJC_ASSOCIATION_SETTER_RETAIN</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">OBJC_ASSOCIATION_SETTER_COPY</span>        <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>            <span class="c1">// NOTE:  both bits are set, so we can simply test 1 bit in releaseValue below.</span>
    <span class="n">OBJC_ASSOCIATION_GETTER_READ</span>        <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
    <span class="n">OBJC_ASSOCIATION_GETTER_RETAIN</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
    <span class="n">OBJC_ASSOCIATION_GETTER_AUTORELEASE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">};</span>
</pre></table></code></div></div><p>通过 acquireValue()函数判断使用那种内存关键字.</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">acquireValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">_policy</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">OBJC_ASSOCIATION_SETTER_RETAIN</span><span class="p">:</span>
            <span class="n">_value</span> <span class="o">=</span> <span class="n">objc_retain</span><span class="p">(</span><span class="n">_value</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">OBJC_ASSOCIATION_SETTER_COPY</span><span class="p">:</span>
            <span class="n">_value</span> <span class="o">=</span> <span class="p">((</span><span class="n">id</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">_value</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">copy</span><span class="p">));</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="关联对象如何实现weak属性">关联对象如何实现weak属性？</h3><p>首先说一下 这个问题问的非常有技术含量,完全考验iOS开发者对底层了解的程度.</p><p>在为NSObject对象绑定 associated object 时可以指定如下依赖关系：</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="nf">OBJC_ENUM</span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">,</span> <span class="n">objc_AssociationPolicy</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">OBJC_ASSOCIATION_ASSIGN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">//弱引用</span>
    <span class="n">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//强引用，非原子操作</span>
    <span class="n">OBJC_ASSOCIATION_COPY_NONATOMIC</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="c1">//先 copy，然后强引用</span>
    <span class="n">OBJC_ASSOCIATION_RETAIN</span> <span class="o">=</span> <span class="mo">01401</span><span class="p">,</span> <span class="c1">//强引用，原子操作</span>
    <span class="n">OBJC_ASSOCIATION_COPY</span> <span class="o">=</span> <span class="mo">01403</span> <span class="c1">//先 copy，然后强引用，原子操作</span>
<span class="p">};</span>
</pre></table></code></div></div><p>根据上述的枚举我们发现一个很奇怪的问题,这里的枚举中并没有<code class="language-plaintext highlighter-rouge">OBJC_ASSOCIATION_WEAK</code>这样的选项.</p><p>基于上述的代码介绍我们知道<code class="language-plaintext highlighter-rouge">Objective-C</code>在底层使用<code class="language-plaintext highlighter-rouge">AssociationsManager</code>统一管理各个对象的 <code class="language-plaintext highlighter-rouge">associated objects</code>关联对象.然后通过<code class="language-plaintext highlighter-rouge">static key</code>(一般是一个固定值)去访问对应的<code class="language-plaintext highlighter-rouge">associated object</code>关联对象.然后在<code class="language-plaintext highlighter-rouge">dealloc</code>的时候调用<code class="language-plaintext highlighter-rouge">擦除函数</code>(<code class="language-plaintext highlighter-rouge">associations.erase() </code>)来解除对这些关联对象的引用:</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>dealloc
    object_dispose
        objc_destructInstance
            _object_remove_assocations  // 移除必要的associated objects
</pre></table></code></div></div><p>也就是说,在<code class="language-plaintext highlighter-rouge">NSObject</code>对象的内存空间里，并没有为 <code class="language-plaintext highlighter-rouge">associated objects</code>(关联对象) 分配任何变量.</p><p>我们知道weak变量和 assign变量的区别是:weak指向的对象销毁的时候,<code class="language-plaintext highlighter-rouge">Objective-C</code>会自动帮我们设置<code class="language-plaintext highlighter-rouge">nil</code>,而<code class="language-plaintext highlighter-rouge">assign</code>却不能.</p><p>这个逻辑是如何实现的呢？</p><p><code class="language-plaintext highlighter-rouge">Runtime</code>在底层维护一个<code class="language-plaintext highlighter-rouge">weak</code>表(也就是本文开头讲的<code class="language-plaintext highlighter-rouge">SlideTable</code>中的<code class="language-plaintext highlighter-rouge">weak_table_t</code> <code class="language-plaintext highlighter-rouge">weak_tabl</code>)，每每分配一个<code class="language-plaintext highlighter-rouge">weak</code>指针并赋值有效对象的地址时，会将对象地址和<code class="language-plaintext highlighter-rouge">weak</code>指针地址注册到<code class="language-plaintext highlighter-rouge">weak</code>表中，其中对象地址作为<code class="language-plaintext highlighter-rouge">key</code>;当对象被废弃时,可根据对象地址快速寻找到指向它的所有<code class="language-plaintext highlighter-rouge">weak</code> 指针,这些<code class="language-plaintext highlighter-rouge">weak</code>指针会被赋值<code class="language-plaintext highlighter-rouge">0</code>(即<code class="language-plaintext highlighter-rouge">nil</code>）并移出`weak表。</p><p>所以,实现<code class="language-plaintext highlighter-rouge">weak</code>引用(而非<code class="language-plaintext highlighter-rouge">assign</code>引用)的前提是存在一个<code class="language-plaintext highlighter-rouge">__weak</code>指针指向到被引用对象的地址,只有这样,当对象被销毁时，指针才能被<code class="language-plaintext highlighter-rouge">runtime</code>找到然后被设置为<code class="language-plaintext highlighter-rouge">nil</code>；<code class="language-plaintext highlighter-rouge">NSObject</code>对象和其<code class="language-plaintext highlighter-rouge">associated object</code>关联对象的关系，并不存在指针这样的<strong>中间媒介</strong>，因此只存在<code class="language-plaintext highlighter-rouge">OBJC_ASSOCIATION_ASSIGN</code>选项，而不存在<code class="language-plaintext highlighter-rouge">OBJC_ASSOCIATION_WEAK</code>选项.</p><h4 id="那我们怎么解决为关联对象实现weak属性呢">那我们怎么解决为关联对象实现weak属性呢？</h4><p>可以通过曲线救国的方式声明一个<code class="language-plaintext highlighter-rouge">class</code>类 持有一个weak的成员变量,然后通过 实例化 我们自定义的class的实例,然后把这个实例作为关联对象即可.</p><p>声明封装weak对象的类</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">@interface</span> <span class="nc">WeakAssociatedObjectWrapper</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="n">id</span> <span class="n">object</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">WeakAssociatedObjectWrapper</span>
<span class="k">@end</span>
</pre></table></code></div></div><p>调用</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">@interface</span> <span class="nc">UIView</span> <span class="p">(</span><span class="nl">ViewController</span><span class="p">)</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="n">UIViewController</span> <span class="o">*</span><span class="n">vc</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">UIView</span> <span class="p">(</span><span class="nl">ViewController</span><span class="p">)</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setVc</span><span class="p">:(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">vc</span> <span class="p">{</span>
    <span class="n">WeakAssociatedObjectWrapper</span> <span class="o">*</span><span class="n">wrapper</span> <span class="o">=</span> <span class="p">[</span><span class="n">WeakAssociatedObjectWrapper</span> <span class="nf">new</span><span class="p">];</span>
    <span class="n">wrapper</span><span class="p">.</span><span class="n">object</span> <span class="o">=</span> <span class="n">vc</span><span class="p">;</span>
    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">vc</span><span class="p">),</span> <span class="n">wrapper</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">-</span> <span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">vc</span> <span class="p">{</span>
    <span class="n">WeakAssociatedObjectWrapper</span> <span class="o">*</span><span class="n">wrapper</span> <span class="o">=</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">wrapper</span><span class="p">.</span><span class="n">object</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></table></code></div></div><blockquote><p>看明白没有,曲线救国.代码引入自<a href="https://zhangbuhuai.com/post/weak-associated-object.html">Weak Associated Object</a></p></blockquote><p><a href="https://draveness.me/ao/">关联对象参考</a></p><h2 id="autoreleasepool的原理所使用的的数据结构是什么">Autoreleasepool的原理？所使用的的数据结构是什么？</h2><p>在ARC下我们使用<code class="language-plaintext highlighter-rouge">@autoreleasepool{}</code> 关键字 把需要自动管理的代码块圈起来 ,这个过程就是在使用一个<code class="language-plaintext highlighter-rouge">AutoReleasePool</code></p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">@autoreleasepool</span> <span class="p">{</span>
	 <span class="o">&lt;</span><span class="err">#</span><span class="n">statements</span><span class="err">#</span><span class="o">&gt;</span> <span class="c1">//代码块</span>
<span class="p">}</span>
</pre></table></code></div></div><p>以上代码编译器 最终会把它改写成下面的样子</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">();</span>
</pre></table></code></div></div><p>既然有压栈一定就有 出栈操作<code class="language-plaintext highlighter-rouge">objc_autoreleasePoolPop(context)</code>;</p><ul><li><code class="language-plaintext highlighter-rouge">objc_autoreleasePoolPush()</code><li><code class="language-plaintext highlighter-rouge">objc_autoreleasePoolPop()</code></ul><p>这俩函数都是对<code class="language-plaintext highlighter-rouge">AutoreleasePoolPage</code>的封装,自动释放机制的核心就是这个类</p><h3 id="autoreleasepoolpage"><code class="language-plaintext highlighter-rouge">AutoreleasePoolPage</code></h3><p><code class="language-plaintext highlighter-rouge">AutoreleasePoolPage</code>是个C++的类</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20200808iOSinterviewAnswers/autoreleasepoolpage.webp" alt="" /></p><ul><li><strong>AutoreleasePool</strong>并没有单独的结构,而是由若干个<code class="language-plaintext highlighter-rouge">AutoreleasePoolPage</code>以<code class="language-plaintext highlighter-rouge">双向链表</code>的形式组合成的,根据上图可以看出,这个双向链表有<code class="language-plaintext highlighter-rouge">前驱parent </code>和<code class="language-plaintext highlighter-rouge">后继child </code>.<li><strong>AutoreleasePool</strong>是按<code class="language-plaintext highlighter-rouge">线程</code>一一对应的(thread 成员变量)<li><strong>AutoreleasePoolPage</strong>就是自动释放池存储对象的数据结构每个Page占用<code class="language-plaintext highlighter-rouge">4KB</code>内存，本身的成员变量占用<code class="language-plaintext highlighter-rouge">56</code>字节，剩下的空间用来存放调用了<code class="language-plaintext highlighter-rouge">autorelease</code>方法的对象地址,同时将一个哨兵插入到Page中，这个哨兵其实就是一个空地址<li>当一个page被占满以后会新建一个新的<code class="language-plaintext highlighter-rouge">AutoreleasePoolPage</code>对象,并插入哨兵标记.  具体代码如下:</ul><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="n">class</span> <span class="n">AutoreleasePoolPage</span> <span class="p">{</span>
<span class="cp">#   define EMPTY_POOL_PLACEHOLDER ((id*)1)
#   define POOL_BOUNDARY nil
</span>    <span class="k">static</span> <span class="n">pthread_key_t</span> <span class="k">const</span> <span class="n">key</span> <span class="o">=</span> <span class="n">AUTORELEASE_POOL_KEY</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">uint8_t</span> <span class="k">const</span> <span class="n">SCRIBBLE</span> <span class="o">=</span> <span class="mh">0xA3</span><span class="p">;</span>  <span class="c1">// 0xA3A3A3A3 after releasing</span>
    <span class="k">static</span> <span class="kt">size_t</span> <span class="k">const</span> <span class="n">SIZE</span> <span class="o">=</span> 
<span class="cp">#if PROTECT_AUTORELEASEPOOL
</span>        <span class="n">PAGE_MAX_SIZE</span><span class="p">;</span>  <span class="c1">// must be multiple of vm page size</span>
<span class="cp">#else
</span>        <span class="n">PAGE_MAX_SIZE</span><span class="p">;</span>  <span class="c1">// size and alignment, power of 2</span>
<span class="cp">#endif
</span>    <span class="k">static</span> <span class="kt">size_t</span> <span class="k">const</span> <span class="n">COUNT</span> <span class="o">=</span> <span class="n">SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
    <span class="n">magic_t</span> <span class="k">const</span> <span class="n">magic</span><span class="p">;</span>
    <span class="n">id</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">pthread_t</span> <span class="k">const</span> <span class="kr">thread</span><span class="p">;</span>
    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span> <span class="k">const</span> <span class="n">parent</span><span class="p">;</span>
    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">depth</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">hiwat</span><span class="p">;</span>
<span class="p">};</span>

</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">magic</code> 检查校验完整性的变量<li><code class="language-plaintext highlighter-rouge">next</code> 指向新加入的autorelease对象<li><code class="language-plaintext highlighter-rouge">thread</code> page当前所在的线程，AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）<li><code class="language-plaintext highlighter-rouge">parent</code> 父节点 指向前一个page<li><code class="language-plaintext highlighter-rouge">child</code> 子节点 指向下一个page<li><code class="language-plaintext highlighter-rouge">depth</code> 链表的深度，节点个数<li><code class="language-plaintext highlighter-rouge">hiwat</code> high water mark 数据容纳的一个上限<li><code class="language-plaintext highlighter-rouge">EMPTY_POOL_PLACEHOLDER</code> 空池占位<li><code class="language-plaintext highlighter-rouge">POOL_BOUNDARY</code> 是一个边界对象 nil,之前的源代码变量名是 <code class="language-plaintext highlighter-rouge">POOL_SENTINEL</code>哨兵对象,用来区别每个page即每个 AutoreleasePoolPage 边界<li><code class="language-plaintext highlighter-rouge">PAGE_MAX_SIZE</code> = 4096, 为什么是4096呢？其实就是虚拟内存每个扇区4096个字节,4K对齐的说法。<li><code class="language-plaintext highlighter-rouge">COUNT</code> 一个page里对象数</ul><p>下面看下工作机制图</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20200808iOSinterviewAnswers/autoreleasepoolworkflow.gif" alt="" /></p><blockquote><p>这张图来自快手同事 周学运,如果大佬看到这张图的话希望能允许授权给我使用哈.</p></blockquote><p>根据上面的示意图我们大概明白, <code class="language-plaintext highlighter-rouge">AutoreleasePoolPage</code>是以栈的形式存在,并且内部对象通过进栈出栈来对应着<code class="language-plaintext highlighter-rouge">objc_autoreleasePoolPush</code>和<code class="language-plaintext highlighter-rouge">objc_autoreleasePoolPop</code></p><p>如果嵌套AutoreleasePool 就是通过<code class="language-plaintext highlighter-rouge">哨兵对象</code>来标识,每次更新链表的next和<code class="language-plaintext highlighter-rouge">前驱</code><code class="language-plaintext highlighter-rouge">后继</code>来完成表的创建销毁.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20200808iOSinterviewAnswers/autoreleasepoolpage1.webp" alt="" /></p><p>当我们对一个对象发送一条<code class="language-plaintext highlighter-rouge">autorelease</code>消息的时候实际上就是将这个对象加入到当前<code class="language-plaintext highlighter-rouge">AutoreleasePoolPage</code>的栈顶<code class="language-plaintext highlighter-rouge">next</code>指针指向的位置</p><blockquote><p>这里只拿了一张page举例.</p></blockquote><h4 id="小结-1">小结</h4><ul><li>自动释放池是有N张<code class="language-plaintext highlighter-rouge">AutoreleasePoolPage</code>组成,每张page 4K大小, AutoreleasePoolPage是c++的类, AutoreleasePoolPage以双向链表连接起来形成一个自动释放池<li>当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中<li>pop 时是传入边界对象(哨兵对象),然后对page 中的对象发送release 的消息</ul><p><a href="https://www.jianshu.com/p/0afda1f23782">自动释放池原理</a> <a href="https://juejin.im/post/6844903609428115470">AutoreleasePool底层实现原理</a></p><h2 id="arc的实现原理arc下对retain-release做了哪些优化">ARC的实现原理？ARC下对retain, release做了哪些优化</h2><p>ARC自动引用计数,是苹果objc4引入的编译器自动在适当位置 帮助实例对象进行 自动retain后者release的一套机制.</p><p>它的实现原理就是在编译层面插入相关代码,帮助补全MRC时代需要开发者手动填写的和管理的对象的相关内存操作的方法.</p><p>为了解释清楚具体实现原理 ,我找到一篇有代码示例的文章,从代码编译成汇编过程中 编译器做了很多优化工作. 更新<code class="language-plaintext highlighter-rouge">isa指针</code>的信息.</p><p><a href="https://juejin.im/post/6844903847622606861#heading-4">理解 ARC 实现原理</a></p><p>这里有个点需要跟大家说一下, 上文 中我们讲了SlideTable,但是还是有不懂得地方下面我们来通过isa串联起来</p><p>isa的组成</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">union</span> <span class="n">isa_t</span> 
<span class="p">{</span>
    <span class="n">Class</span> <span class="n">cls</span><span class="p">;</span>
    <span class="kt">uintptr_t</span> <span class="n">bits</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
         <span class="kt">uintptr_t</span> <span class="n">nonpointer</span>        <span class="o">:</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//-&gt;表示使用优化的isa指针</span>
         <span class="kt">uintptr_t</span> <span class="n">has_assoc</span>         <span class="o">:</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//-&gt;是否包含关联对象</span>
         <span class="kt">uintptr_t</span> <span class="n">has_cxx_dtor</span>      <span class="o">:</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//-&gt;是否设置了析构函数，如果没有，释放对象更快</span>
         <span class="kt">uintptr_t</span> <span class="n">shiftcls</span>          <span class="o">:</span> <span class="mi">33</span><span class="p">;</span> <span class="c1">// MACH_VM_MAX_ADDRESS 0x1000000000 -&gt;类的指针</span>
         <span class="kt">uintptr_t</span> <span class="n">magic</span>             <span class="o">:</span> <span class="mi">6</span><span class="p">;</span><span class="c1">//-&gt;固定值,用于判断是否完成初始化</span>
         <span class="kt">uintptr_t</span> <span class="n">weakly_referenced</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//-&gt;对象是否被弱引用</span>
         <span class="kt">uintptr_t</span> <span class="n">deallocating</span>      <span class="o">:</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//-&gt;对象是否正在销毁</span>
         <span class="kt">uintptr_t</span> <span class="n">has_sidetable_rc</span>  <span class="o">:</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//1-&gt;在extra_rc存储引用计数将要溢出的时候,借助Sidetable(散列表)存储引用计数,has_sidetable_rc设置成1</span>
        <span class="kt">uintptr_t</span> <span class="n">extra_rc</span>          <span class="o">:</span> <span class="mi">19</span><span class="p">;</span>  <span class="c1">//-&gt;存储引用计数</span>
    <span class="p">};</span>
<span class="p">};</span>

</pre></table></code></div></div><p>其中<code class="language-plaintext highlighter-rouge">nonpointer</code>、<code class="language-plaintext highlighter-rouge">weakly_referenced</code>、<code class="language-plaintext highlighter-rouge">has_sidetable_rc</code>和<code class="language-plaintext highlighter-rouge">extra_rc</code>都是 <code class="language-plaintext highlighter-rouge">ARC</code>有直接关系的成员变量，其他的大多也有涉及到。</p><h3 id="retainrelease做了哪些优化">retain,release做了哪些优化</h3><p>大概可以分为如下</p><ul><li>TaggedPointer 指针优化<li>!newisa.nonpointer：未优化的 isa 的情况下retain或者release<li>newisa.nonpointer：已优化的 isa ， 这其中又分 extra_rc 溢出区别 我把相关代码站在下面并且把结论输出出来.</ul><div class="table-wrapper"><table><thead><tr><th style="text-align: center">内存操作<th style="text-align: center">objc_retain<th style="text-align: center">objc_release<tbody><tr><td style="text-align: center">TaggedPointer<td style="text-align: center">值存在指针内，直接返回<td style="text-align: center">直接返回 false。<tr><td style="text-align: center">!nonpointer<td style="text-align: center">未优化的<code class="language-plaintext highlighter-rouge">isa</code>,使用<code class="language-plaintext highlighter-rouge">sidetable_retain()</code><td style="text-align: center">未优化的<code class="language-plaintext highlighter-rouge">isa</code>执行<code class="language-plaintext highlighter-rouge">sidetable_release</code><tr><td style="text-align: center">nonpointer<td style="text-align: center">已优化的<code class="language-plaintext highlighter-rouge">isa</code>,这其中又分<code class="language-plaintext highlighter-rouge">extra_rc</code>溢出和未溢出的两种情况<td style="text-align: center">已优化的<code class="language-plaintext highlighter-rouge">isa</code>,分下溢和未下溢两种情况</table></div><p>|nonpointer已优化isa的extra_rc | objc_retain | objc_release | | ——| —— | —— | | 未溢出时 |<code class="language-plaintext highlighter-rouge">isa.extra_rc</code>+1 | NA | |溢出时|将<code class="language-plaintext highlighter-rouge">isa.extra_rc</code>中一半值转移至<code class="language-plaintext highlighter-rouge">sidetable</code>中,然后将<code class="language-plaintext highlighter-rouge">isa.has_sidetable_rc</code>设置为<code class="language-plaintext highlighter-rouge">true</code>,表示使用了<code class="language-plaintext highlighter-rouge">sidetable</code>来计算引用次数|NA| |未下溢|NA|extra_rc–| |下溢|NA|从<code class="language-plaintext highlighter-rouge">sidetable</code>中借位给<code class="language-plaintext highlighter-rouge">extra_rc</code>达到半满,如果无法借位则说明引用计数归零需要进行释放,其中借位时可能保存失败会不断重试|</p><blockquote><p>NA -&gt; non available 不可获得</p></blockquote><p>下面我们看下retain源码</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="n">ALWAYS_INLINE</span> <span class="n">id</span> <span class="n">objc_object</span><span class="o">::</span><span class="n">rootRetain</span><span class="p">(</span><span class="n">bool</span> <span class="n">tryRetain</span><span class="p">,</span> <span class="n">bool</span> <span class="n">handleOverflow</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isTaggedPointer</span><span class="p">())</span> <span class="k">return</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">this</span><span class="p">;</span>     <span class="c1">// 如果是 TaggedPointer 直接返回</span>
    <span class="n">bool</span> <span class="n">sideTableLocked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">transcribeToSideTable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">isa_t</span> <span class="n">oldisa</span><span class="p">;</span>
    <span class="n">isa_t</span> <span class="n">newisa</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">transcribeToSideTable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">oldisa</span> <span class="o">=</span> <span class="n">LoadExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>  <span class="c1">// 获取 isa</span>
        <span class="n">newisa</span> <span class="o">=</span> <span class="n">oldisa</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="o">!</span><span class="n">newisa</span><span class="p">.</span><span class="n">nonpointer</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">ClearExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span><span class="c1">// 未优化的 isa 部分</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tryRetain</span> <span class="o">&amp;&amp;</span> <span class="n">sideTableLocked</span><span class="p">)</span> <span class="n">sidetable_unlock</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tryRetain</span><span class="p">)</span> <span class="k">return</span> <span class="n">sidetable_tryRetain</span><span class="p">()</span> <span class="p">?</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">this</span> <span class="p">:</span> <span class="nb">nil</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">return</span> <span class="n">sidetable_retain</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="n">tryRetain</span> <span class="o">&amp;&amp;</span> <span class="n">newisa</span><span class="p">.</span><span class="n">deallocating</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 正在被释放的处理</span>
            <span class="n">ClearExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tryRetain</span> <span class="o">&amp;&amp;</span> <span class="n">sideTableLocked</span><span class="p">)</span> <span class="n">sidetable_unlock</span><span class="p">();</span>
            <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// extra_rc 未溢出时引用计数++</span>
        <span class="kt">uintptr_t</span> <span class="n">carry</span><span class="p">;</span>
        <span class="n">newisa</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">addc</span><span class="p">(</span><span class="n">newisa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">RC_ONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">carry</span><span class="p">);</span>  <span class="c1">// extra_rc++</span>
        <span class="c1">// extra_rc 溢出</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="n">carry</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// newisa.extra_rc++ overflowed</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handleOverflow</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ClearExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">rootRetain_overflow</span><span class="p">(</span><span class="n">tryRetain</span><span class="p">);</span>   <span class="c1">// 重新调用该函数 入参 handleOverflow 为 true</span>
            <span class="p">}</span> 
            <span class="c1">// 保留一半引用计数,准备将另一半复制到 side table.</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tryRetain</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sideTableLocked</span><span class="p">)</span> <span class="n">sidetable_lock</span><span class="p">();</span>
            <span class="n">sideTableLocked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">transcribeToSideTable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">newisa</span><span class="p">.</span><span class="n">extra_rc</span> <span class="o">=</span> <span class="n">RC_HALF</span><span class="p">;</span>
            <span class="n">newisa</span><span class="p">.</span><span class="n">has_sidetable_rc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//  更新 isa 值</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="o">!</span><span class="n">StoreExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">oldisa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">newisa</span><span class="p">.</span><span class="n">bits</span><span class="p">)));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="n">transcribeToSideTable</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">sidetable_addExtraRC_nolock</span><span class="p">(</span><span class="n">RC_HALF</span><span class="p">);</span> <span class="c1">// 将另一半复制到 side table side table.</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="o">!</span><span class="n">tryRetain</span> <span class="o">&amp;&amp;</span> <span class="n">sideTableLocked</span><span class="p">))</span> <span class="n">sidetable_unlock</span><span class="p">();</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">release</code>源码</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre><td class="rouge-code"><pre><span class="n">ALWAYS_INLINE</span> <span class="n">bool</span> <span class="n">objc_object</span><span class="o">::</span><span class="n">rootRelease</span><span class="p">(</span><span class="n">bool</span> <span class="n">performDealloc</span><span class="p">,</span> <span class="n">bool</span> <span class="n">handleUnderflow</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isTaggedPointer</span><span class="p">())</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">sideTableLocked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">isa_t</span> <span class="n">oldisa</span><span class="p">;</span>
    <span class="n">isa_t</span> <span class="n">newisa</span><span class="p">;</span>
 <span class="nl">retry:</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">oldisa</span> <span class="o">=</span> <span class="n">LoadExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
        <span class="n">newisa</span> <span class="o">=</span> <span class="n">oldisa</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="o">!</span><span class="n">newisa</span><span class="p">.</span><span class="n">nonpointer</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">ClearExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span><span class="c1">// 未优化 isa</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sideTableLocked</span><span class="p">)</span> <span class="n">sidetable_unlock</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">sidetable_release</span><span class="p">(</span><span class="n">performDealloc</span><span class="p">);</span><span class="c1">// 入参是否要执行 Dealloc 函数，如果为 true 则执行 SEL_dealloc</span>
        <span class="p">}</span>
        <span class="n">newisa</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">subc</span><span class="p">(</span><span class="n">newisa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">RC_ONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">carry</span><span class="p">);</span>  <span class="c1">// extra_rc--</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="n">carry</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// donot ClearExclusive()</span>
            <span class="k">goto</span> <span class="n">underflow</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 更新 isa 值</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="o">!</span><span class="n">StoreReleaseExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> 
                                             <span class="n">oldisa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">newisa</span><span class="p">.</span><span class="n">bits</span><span class="p">)));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="n">sideTableLocked</span><span class="p">))</span> <span class="n">sidetable_unlock</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
 <span class="nl">underflow:</span>
 	<span class="c1">// 处理下溢，从 side table 中借位或者释放</span>
    <span class="n">newisa</span> <span class="o">=</span> <span class="n">oldisa</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="n">newisa</span><span class="p">.</span><span class="n">has_sidetable_rc</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 如果使用了 sidetable_rc</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handleUnderflow</span><span class="p">)</span> <span class="p">{</span>
        	<span class="n">ClearExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span><span class="c1">// 调用本函数处理下溢</span>
            <span class="k">return</span> <span class="n">rootRelease_underflow</span><span class="p">(</span><span class="n">performDealloc</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">size_t</span> <span class="n">borrowed</span> <span class="o">=</span> <span class="n">sidetable_subExtraRC_nolock</span><span class="p">(</span><span class="n">RC_HALF</span><span class="p">);</span> <span class="c1">// 从 sidetable 中借位引用计数给 extra_rc</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">borrowed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// extra_rc 是计算额外的引用计数，0 即表示被引用一次</span>
            <span class="n">newisa</span><span class="p">.</span><span class="n">extra_rc</span> <span class="o">=</span> <span class="n">borrowed</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// redo the original decrement too</span>
            <span class="n">bool</span> <span class="n">stored</span> <span class="o">=</span> <span class="n">StoreReleaseExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> 
                                                <span class="n">oldisa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">newisa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>                                    
            <span class="c1">// 保存失败，恢复现场，重试                                    </span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stored</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">isa_t</span> <span class="n">oldisa2</span> <span class="o">=</span> <span class="n">LoadExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
                <span class="n">isa_t</span> <span class="n">newisa2</span> <span class="o">=</span> <span class="n">oldisa2</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">newisa2</span><span class="p">.</span><span class="n">nonpointer</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">uintptr_t</span> <span class="n">overflow</span><span class="p">;</span>
                    <span class="n">newisa2</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> 
                        <span class="n">addc</span><span class="p">(</span><span class="n">newisa2</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">RC_ONE</span> <span class="o">*</span> <span class="p">(</span><span class="n">borrowed</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">overflow</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">overflow</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">stored</span> <span class="o">=</span> <span class="n">StoreReleaseExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">oldisa2</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> 
                                                       <span class="n">newisa2</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
		<span class="c1">// 如果还是保存失败，则还回 side table</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stored</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sidetable_addExtraRC_nolock</span><span class="p">(</span><span class="n">borrowed</span><span class="p">);</span>
                <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">sidetable_unlock</span><span class="p">();</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Side table is empty after all. Fall-through to the dealloc path.</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 没有使用 sidetable_rc ，或者 sidetable_rc 计数 == 0 的就直接释放</span>
    <span class="c1">// 如果已经是释放中，抛个过度释放错误</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="n">newisa</span><span class="p">.</span><span class="n">deallocating</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ClearExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sideTableLocked</span><span class="p">)</span> <span class="n">sidetable_unlock</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">overrelease_error</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// 更新 isa 状态</span>
    <span class="n">newisa</span><span class="p">.</span><span class="n">deallocating</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">StoreExclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">oldisa</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">newisa</span><span class="p">.</span><span class="n">bits</span><span class="p">))</span> <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slowpath</span><span class="p">(</span><span class="n">sideTableLocked</span><span class="p">))</span> <span class="n">sidetable_unlock</span><span class="p">();</span>
	<span class="c1">// 执行 SEL_dealloc 事件</span>
    <span class="n">__sync_synchronize</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">performDealloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">objc_object</span> <span class="o">*</span><span class="p">,</span> <span class="n">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">this</span><span class="p">,</span> <span class="n">SEL_dealloc</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="小结-2">小结</h3><p>到这里可以知道 引用计数分别保存在<code class="language-plaintext highlighter-rouge">isa.extra_rc</code>和<code class="language-plaintext highlighter-rouge">sidetable</code>中，当<code class="language-plaintext highlighter-rouge">isa.extra_rc</code>溢出时，将一半计数转移至<code class="language-plaintext highlighter-rouge">sidetable</code>中，而当其下溢时，又会将计数转回。当二者都为空时，会执行释放流程</p><h2 id="arc下哪些情况会造成内存泄漏">ARC下哪些情况会造成内存泄漏</h2><ul><li>block中的循环引用<li>NSTimer的循环引用<li>addObserver的循环引用<li>delegate的强引用<li>大次数循环内存爆涨<li>非OC对象的内存处理（需手动释放）</ul><h1 id="总结">总结</h1><p>以上就是我们讨论上述一套面试题的 runtime相关问题之 内存管理部分,下一篇讲把剩余的问题收一下尾 感谢各位支持</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/ios/'>iOS</a>, <a href='/categories/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E5%AE%9E%E8%B7%B5/'>系统理论实践</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >Algorithm</a> <a href="/tags/objective-c/" class="post-tag no-text-decoration" >Objective-C</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 该博客文章由作者通过 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a> 进行授权。</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=阿里、字节：一套高效的iOS面试题之runtime相关问题2 - 迈腾大队长&url=https://www.sunyazhou.com/2020/08/iOSinterviewAnswers2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=阿里、字节：一套高效的iOS面试题之runtime相关问题2 - 迈腾大队长&u=https://www.sunyazhou.com/2020/08/iOSinterviewAnswers2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=阿里、字节：一套高效的iOS面试题之runtime相关问题2 - 迈腾大队长&url=https://www.sunyazhou.com/2020/08/iOSinterviewAnswers2/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="http://service.weibo.com/share/share.php?title=阿里、字节：一套高效的iOS面试题之runtime相关问题2 - 迈腾大队长&url=https://www.sunyazhou.com/2020/08/iOSinterviewAnswers2/" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/2024/03/masonryrelayoutviews/">使用Masonry高阶方法对子视图统一布局</a><li><a href="/2020/04/MasonryTricks/">使用Masonry处理UIView的safeArea边界布局问题</a><li><a href="/2019/09/MasonryPanViewDemo/">使用Masonry约束实现简单的高级拖拽视图</a><li><a href="/2024/02/MotionShake/">运动传感器摇晃检测</a><li><a href="/2019/04/WindowsResources/">Windows装机教程</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/objective-c/">Objective C</a> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/macos/">macOS</a> <a class="post-tag" href="/tags/skills/">skills</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/swift/">Swift</a> <a class="post-tag" href="/tags/c++/">C++</a> <a class="post-tag" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a> <a class="post-tag" href="/tags/swiftui/">SwiftUI</a> <a class="post-tag" href="/tags/avfoundation/">AVFoundation</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章目录</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>接下来阅读</h3><div class="card-deck mb-4"><div class="card"> <a href="/2020/07/iOSinterviewAnswers1/"><div class="card-body"> <span class="timeago small" > 2020-07-06 <i class="unloaded">2020-07-06T09:52:47+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>阿里、字节：一套高效的iOS面试题之runtime相关问题1</h3><div class="text-muted small"><p> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 记得过年时候 有一个微信公众号 的面试题引起了我的关注,但是只有问题没有答案,由于最近半年时间太忙了,博客几乎停...</p></div></div></a></div><div class="card"> <a href="/2020/08/iOSinterviewAnswers3/"><div class="card-body"> <span class="timeago small" > 2020-08-31 <i class="unloaded">2020-08-31T16:52:25+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>阿里、字节：一套高效的iOS面试题之runtime相关问题3</h3><div class="text-muted small"><p> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. runtime相关问题之内存部分的关联属性或者hook相关的Method Swizzle 经过前两期内容 我们这期来...</p></div></div></a></div><div class="card"> <a href="/2020/09/iOSinterviewAnswers4/"><div class="card-body"> <span class="timeago small" > 2020-09-01 <i class="unloaded">2020-09-01T10:15:27+00:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>阿里、字节：一套高效的iOS面试题之NSNotification相关</h3><div class="text-muted small"><p> 前言 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 前3篇中已经讲完了内存管理,今天我们继续完成阿里、字节：一套高效的iOS面试题的通知部分. 主要内容包含如下: ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/2020/07/iOSinterviewAnswers1/" class="btn btn-outline-primary"><p>阿里、字节：一套高效的iOS面试题之runtime相关问题1</p></a> <a href="/2020/08/iOSinterviewAnswers3/" class="btn btn-outline-primary"><p>阿里、字节：一套高效的iOS面试题之runtime相关问题3</p></a></div><div class="utterances-container"> <script src="https://utteranc.es/client.js" repo="sunyazhou13/gitment-comments" issue-term="pathname" theme="photon-dark" crossorigin="anonymous" async> </script></div><script type="text/javascript"> $(function() { window.onmessage = evt => { if (evt.origin === 'https://utteranc.es') { toggle.updateCommentStyle(); window.onmessage = null; } } }); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/sunyazhou13">sunyazhou</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，否则本网站上的博客文章均由作者根据知识共享许可协议 - 署名标示 4.0（CC BY 4.0）进行授权许可。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本博客由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，使用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> 作为主题</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/objective-c/">Objective C</a> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/macos/">macOS</a> <a class="post-tag" href="/tags/skills/">skills</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/swift/">Swift</a> <a class="post-tag" href="/tags/c++/">C++</a> <a class="post-tag" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a> <a class="post-tag" href="/tags/swiftui/">SwiftUI</a> <a class="post-tag" href="/tags/avfoundation/">AVFoundation</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sunyazhou.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
