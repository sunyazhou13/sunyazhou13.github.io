<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>(转)深度理解 NSURLProtocol | 迈腾大队长</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="(转)深度理解 NSURLProtocol | 迈腾大队长">
    <meta name="twitter:description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="(转)深度理解 NSURLProtocol | 迈腾大队长">
    <meta property="og:description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    
    <meta name="author" content="sunyazhou">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//apps.bdimg.com/libs/fontawesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/favicon.ico">
    

    
    <link rel="apple-touch-icon" href="/images/logo.jpg">
    
    
    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="迈腾大队长" href="/atom.xml">
    

    <link rel="canonical" href="https://www.sunyazhou.com/2020/03/20/20200320NSURLProtocol/"/>

    
    <link rel="author" href="https://plus.google.com/107423989995616646161"/>
    
    <!-- fancybox support -->
    
        <script src="/lib/jquery-3.3.1.min.js"></script>
        <link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.min.css">
        <script src="/lib/fancybox/dist/jquery.fancybox.min.js"></script>
        <script src="/js/wrapImage.js"></script>
    
</head>

<body class="home-template no-js">

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 迈腾大队长 的主页"><img src="/images/logo2.jpg" width="80" alt="迈腾大队长 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 迈腾大队长">迈腾大队长</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">不断学习, 与时俱进. - 始于2017</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">文章</a></li>
            
              <li class="navigation__item"><a href="/archives">归档</a></li>
            
              <li class="navigation__item"><a href="/projects">作品</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/sunyazhou13" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/sunyazhou13" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  
  <li class="navigation__item">
    <a href="https://plus.google.com/107423989995616646161" title="Google+" target="_blank">
      <i class='social fa fa-google-plus-square'></i>
      <span class="label">Google+</span>
    </a>
  </li>


<!-- Facebook -->


<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/sunyazhou" title="上Twitter找我" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

<!-- instagram -->


  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>


  <li class="navigation__item">
    <a href="mailto:sunyazhou13@163.com" title="邮件联系我" target="_blank">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-red"></div>
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2020-03-20T03:34:22.000Z" class="post-list__meta--date date">2020-03-20</time>
 &#8226; <span class="post-meta__tags tags">分类&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/知识小集/">知识小集</a>

</span>
    </div>
    <h1 class="post-title">(转)深度理解 NSURLProtocol</h1>
  </header>

  <section class="post">
    <p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200320NSURLProtocol/NSURLProtocol.png"></p>
<h1 id="前言">前言</h1>
<p>本文经由微信<code>知识小集</code>公众号授权并转载自<a href="https://blog.fiteen.top/2020/hijacking-webview-request-with-nsprotocol" target="_blank" rel="noopener">FiTeen博客</a>,如果版权问题请与我联系sunyazhou13@163.com.转载此文目的是为了记录iOS开发中的重要知识点,防止原文博客寻找起来麻烦.</p>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="nsurlprotocol-是什么">NSURLProtocol 是什么</h2>
<p>NSURLProtocol 是 Foundation 框架中<a href="https://developer.apple.com/documentation/foundation/url_loading_system?language=objc" target="_blank" rel="noopener">URL Loading System</a>的一部分。它可以让开发者可以在不修改应用内原始请求代码的情况下，去改变 URL 加载的全部细节。换句话说，NSURLProtocol 是一个被 Apple 默许的中间人攻击。</p>
<p>虽然 NSURLProtocol 叫<code>Protocol</code>，却不是协议，而是一个<strong>抽象类</strong>。</p>
<p>既然 NSURLProtocol 是一个抽象类，说明它无法被实例化，那么它又是如何实现网络请求拦截的？</p>
<p>答案就是通过<strong>子类化</strong>来定义新的或是已经存在的 URL 加载行为。如果当前的网络请求是可以被拦截的，那么开发者只需要将一个自定义的 NSURLProtocol 子类注册到 App 中，在这个子类中就可以拦截到所有请求并进行修改。</p>
<p>那么到底哪些网络请求可以被拦截？</p>
<h2 id="nsurlprotocol-使用场景">NSURLProtocol 使用场景</h2>
<p>前面已经说了，NSURLProtocol 是 URL Loading System 的一部分，所以它可以拦截所有基于 URL Loading System 的网络请求：</p>
<ul>
<li>NSURLSession<br>
</li>
<li>NSURLConnection<br>
</li>
<li>NSURLDownload<br>
</li>
<li>NSURLResponse
<ul>
<li>NSHTTPURLResponse<br>
</li>
</ul></li>
<li>NSURLRequest
<ul>
<li>NSMutableURLRequest</li>
</ul></li>
</ul>
<p>相应的，基于它们实现的第三方网络框架<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>和<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>的网络请求，也可以被 NSURLProtocol 拦截到。</p>
<p>但早些年基于 CFNetwork 实现的，比如<a href="https://github.com/pokeb/asi-http-request" target="_blank" rel="noopener">ASIHTTPRequest</a>，其网络请求就无法被拦截。</p>
<p>另外，<strong>UIWebView也是可以被NSURLProtocol拦截的,但WKWebView不可以</strong>。（因为 WKWebView 是基于 WebKit，并不走 C socket。）</p>
<p>因此，在实际应用中，它的功能十分强大，比如：</p>
<ul>
<li>重定向网络请求，解决 DNS 域名劫持的问题</li>
<li>进行全局或局部的网络请求设置，比如修改请求地址、header 等</li>
<li>忽略网络请求，使用 H5 离线包或是缓存数据等</li>
<li>自定义网络请求的返回结果，比如过滤敏感信息</li>
</ul>
<p>下面来看一下 NSURLProtocol 的相关方法。</p>
<h2 id="nsurlprotocol-的相关方法">NSURLProtocol 的相关方法</h2>
<h3 id="创建协议对象">创建协议对象</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 URL 协议实例来处理 request 请求</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request cachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse client:(<span class="keyword">id</span>&lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client;</span><br><span class="line"><span class="comment">// 创建一个 URL 协议实例来处理 session task 请求</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTask:(<span class="built_in">NSURLSessionTask</span> *)task cachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse client:(<span class="keyword">id</span>&lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client;</span><br></pre></td></tr></table></figure>
<h3 id="注册和注销协议类">注册和注销协议类</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试注册 NSURLProtocol 的子类，使之在 URL 加载系统中可见</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)registerClass:(Class)protocolClass;</span><br><span class="line"><span class="comment">// 注销 NSURLProtocol 的指定子类</span></span><br><span class="line">+ (<span class="keyword">void</span>)unregisterClass:(Class)protocolClass;</span><br></pre></td></tr></table></figure>
<h3 id="确定子类是否可以处理请求">确定子类是否可以处理请求</h3>
<p>子类化 NSProtocol 的首要任务就是告知它，需要控制什么类型的网络请求。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确定协议子类是否可以处理指定的 request 请求，如果返回 YES，请求会被其控制，返回 NO 则直接跳入下一个 protocol</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"><span class="comment">// 确定协议子类是否可以处理指定的 task 请求</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithTask:(<span class="built_in">NSURLSessionTask</span> *)task;</span><br></pre></td></tr></table></figure>
<h3 id="获取和设置请求属性">获取和设置请求属性</h3>
<p>NSURLProtocol 允许开发者去获取、添加、删除 request 对象的任意元数据。这几个方法常用来处理请求无限循环的问题。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定的请求中获取与指定键关联的属性</span></span><br><span class="line">+ (<span class="keyword">id</span>)propertyForKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"><span class="comment">// 设置与指定请求中的指定键关联的属性</span></span><br><span class="line">+ (<span class="keyword">void</span>)setProperty:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSMutableURLRequest</span> *)request;</span><br><span class="line"><span class="comment">// 删除与指定请求中的指定键关联的属性</span></span><br><span class="line">+ (<span class="keyword">void</span>)removePropertyForKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSMutableURLRequest</span> *)request;</span><br></pre></td></tr></table></figure>
<h3 id="提供请求的规范版本">提供请求的规范版本</h3>
<p>如果你想要用特定的某个方式来修改请求，可以用下面这个方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回指定请求的规范版本</span></span><br><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br></pre></td></tr></table></figure>
<h3 id="确定请求是否相同">确定请求是否相同</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断两个请求是否相同，如果相同可以使用缓存数据，通常只需要调用父类的实现</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b;</span><br></pre></td></tr></table></figure>
<h3 id="启动和停止加载">启动和停止加载</h3>
<p>这是子类中最重要的两个方法，不同的自定义子类在调用这两个方法时会传入不同的内容，但共同点都是围绕 <code>protocol</code> 客户端进行操作.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始加载</span></span><br><span class="line">- (<span class="keyword">void</span>)startLoading;  </span><br><span class="line"><span class="comment">// 停止加载  </span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading;</span><br></pre></td></tr></table></figure>
<h3 id="获取协议属性">获取协议属性</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取协议接收者的缓存</span></span><br><span class="line">- (<span class="built_in">NSCachedURLResponse</span> *)cachedResponse;</span><br><span class="line"><span class="comment">// 接受者用来与 URL 加载系统通信的对象，每个 NSProtocol 的子类实例都拥有它</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client;</span><br><span class="line"><span class="comment">// 接收方的请求</span></span><br><span class="line">- (<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"><span class="comment">// 接收方的任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionTask</span> *)task;</span><br></pre></td></tr></table></figure>
<p>NSURLProtocol 在实际应用中，主要是完成两步：拦截 URL 和 URL 转发。先来看如何拦截网络请求。</p>
<h2 id="如何利用-nsprotocol-拦截网络请求">如何利用 NSProtocol 拦截网络请求</h2>
<h3 id="创建-nsurlprotocol-子类">创建 NSURLProtocol 子类</h3>
<p>这里创建一个名为<code>HTCustomURLProtocol</code>的子类。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTCustomURLProtocol</span> : <span class="title">NSURLProtocol</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="注册-nsurlprotocol-的子类">注册 NSURLProtocol 的子类</h3>
<p>在合适的位置注册这个子类。对基于 NSURLConnection 或者使用<code>[NSURLSession sharedSession]</code>初始化对象创建的网络请求，调用 <code>registerClass</code> 方法即可。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSURLProtocol</span> registerClass:[<span class="built_in">NSClassFromString</span>(<span class="string">@"HTCustomURLProtocol"</span>) <span class="keyword">class</span>]];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// [NSURLProtocol registerClass:[HTCustomURLProtocol class]];</span></span><br></pre></td></tr></table></figure>
<p>如果需要全局监听，可以设置在 <code>AppDelegate.m</code> 的 <code>didFinishLaunchingWithOptions:</code> 方法中。如果只需要在单个 UIViewController 中使用，记得在合适的时机注销监听：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSURLProtocol</span> unregisterClass:[<span class="built_in">NSClassFromString</span>(<span class="string">@"HTCustomURLProtocol"</span>) <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure>
<p>如果是基于 NSURLSession 的网络请求，且不是通过<code>[NSURLSession sharedSession]</code>方式创建的，就得配置 NSURLSessionConfiguration 对象的 <code>protocolClasses</code> 属性。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">sessionConfiguration.protocolClasses = @[[<span class="built_in">NSClassFromString</span>(<span class="string">@"HTCustomURLProtocol"</span>) <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure>
<h3 id="实现-nsurlprotocol-子类">实现 NSURLProtocol 子类</h3>
<p>实现子类分为五个步骤：</p>
<blockquote>
<p>注册 → 拦截 → 转发 → 回调 → 结束</p>
</blockquote>
<p>以拦截 UIWebView 为例，这里需要重写父类的这五个核心方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个协议 key</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> HTCustomURLProtocolHandledKey = <span class="string">@"HTCustomURLProtocolHandledKey"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拓展中定义一个 NSURLConnection 属性。通过 NSURLSession 也可以拦截，这里只是以 NSURLConnection 为例。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLConnection</span> *connection;</span><br><span class="line"><span class="comment">// 定义一个可变的请求返回值，</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableData</span> *responseData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 1：在拦截到网络请求后会调用这一方法，可以再次处理拦截的逻辑，比如设置只针对 http 和 https 的请求进行处理。</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="comment">// 只处理 http 和 https 请求</span></span><br><span class="line">    <span class="built_in">NSString</span> *scheme = [[request URL] scheme];</span><br><span class="line">    <span class="keyword">if</span> ( ([scheme caseInsensitiveCompare:<span class="string">@"http"</span>] == <span class="built_in">NSOrderedSame</span> ||</span><br><span class="line">          [scheme caseInsensitiveCompare:<span class="string">@"https"</span>] == <span class="built_in">NSOrderedSame</span>)) &#123;</span><br><span class="line">        <span class="comment">// 看看是否已经处理过了，防止无限循环</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey:HTCustomURLProtocolHandledKey inRequest:request]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还需要截取 DNS 解析请求中的链接，可以继续加判断，是否为拦截域名请求的链接，如果是返回 NO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 2：【关键方法】可以在此对 request 进行处理，比如修改地址、提取请求信息、设置请求头等。</span></span><br><span class="line">+ (<span class="built_in">NSURLRequest</span> *) canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="comment">// 可以打印出所有的请求链接包括 CSS 和 Ajax 请求等</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"request.URL.absoluteString = %@"</span>,request.URL.absoluteString);</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 3：【关键方法】在这里设置网络代理，重新创建一个对象将处理过的 request 转发出去。这里对应的回调方法对应 &lt;NSURLProtocolClient&gt; 协议方法</span></span><br><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">    <span class="comment">// 可以修改 request 请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="keyword">self</span> request] mutableCopy];</span><br><span class="line">    <span class="comment">// 打 tag，防止递归调用</span></span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES forKey:HTCustomURLProtocolHandledKey inRequest:mutableRequest];</span><br><span class="line">    <span class="comment">// 也可以在这里检查缓存</span></span><br><span class="line">    <span class="comment">// 将 request 转发，对于 NSURLConnection 来说，就是创建一个 NSURLConnection 对象；对于 NSURLSession 来说，就是发起一个 NSURLSessionTask。</span></span><br><span class="line">    <span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:mutableRequest delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 4：主要判断两个 request 是否相同，如果相同的话可以使用缓存数据，通常只需要调用父类的实现。</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> requestIsCacheEquivalent:a toRequest:b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 5：处理结束后停止相应请求，清空 connection 或 session</span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.connection != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">        <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照在上面的方法中做的自定义需求，看情况对转发出来的请求在恰当的时机进行回调处理。</span></span><br><span class="line"><span class="meta">#pragma mark- NSURLConnectionDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSURLConnectionDataDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当接收到服务器的响应（连通了服务器）时会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    <span class="keyword">self</span>.responseData = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">    <span class="comment">// 可以处理不同的 statusCode 场景</span></span><br><span class="line">    <span class="comment">// NSInteger statusCode = [(NSHTTPURLResponse *)response statusCode];</span></span><br><span class="line">    <span class="comment">// 可以设置 Cookie</span></span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到服务器的数据时会调用，可能会被调用多次，每次只传递部分数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    [<span class="keyword">self</span>.responseData appendData:data];</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器的数据加载完毕后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求错误（失败）的时候调用，比如出现请求超时、断网，一般指客户端错误</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面用到的一些 NSURLProtocolClient 方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLProtocolClient</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">// 请求重定向</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol wasRedirectedToRequest:(<span class="built_in">NSURLRequest</span> *)request redirectResponse:(<span class="built_in">NSURLResponse</span> *)redirectResponse;</span><br><span class="line"><span class="comment">// 响应缓存是否合法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol cachedResponseIsValid:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse;</span><br><span class="line"><span class="comment">// 刚接收到 response 信息</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response cacheStoragePolicy:(<span class="built_in">NSURLCacheStoragePolicy</span>)policy;</span><br><span class="line"><span class="comment">// 数据加载成功</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didLoadData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line"><span class="comment">// 数据完成加载</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocolDidFinishLoading:(<span class="built_in">NSURLProtocol</span> *)protocol;</span><br><span class="line"><span class="comment">// 数据加载失败</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didFailWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="comment">// 为指定的请求启动验证</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge;</span><br><span class="line"><span class="comment">// 为指定的请求取消验证</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didCancelAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="补充内容">补充内容</h2>
<h3 id="使用-nsurlsession-时的注意事项">使用 NSURLSession 时的注意事项</h3>
<p>如果在 NSURLProtocol 中使用 NSURLSession，需要注意：</p>
<ul>
<li><p>拦截到的 request 请求的 HTTPBody 为 nil，但可以借助 HTTPBodyStream 来获取 body；</p></li>
<li><p>如果要用 <code>registerClass</code> 注册，只能通过 <code>[NSURLSession sharedSession]</code> 的方式创建网络请求。</p></li>
</ul>
<h3 id="注册多个-nsurlprotocol-子类">注册多个 NSURLProtocol 子类</h3>
<p>当有多个自定义 NSURLProtocol 子类注册到系统中的话，会按照他们注册的反向顺序依次调用 URL 加载流程，也就是最后注册的 NSURLProtocol 会被优先判断。</p>
<p>对于通过配置 NSURLSessionConfiguration 对象的 <code>protocolClasses</code> 属性来注册的情况，<code>protocolClasses</code> 数组中只有第一个 NSURLProtocol 会起作用，后续的 NSURLProtocol 就无法拦截到了。</p>
<p>所以 <a href="https://github.com/AliSoftware/OHHTTPStubs" target="_blank" rel="noopener">OHHTTPStubs</a> 在注册 NSURLProtocol 子类的时候是这样处理的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)setEnabled:(<span class="built_in">BOOL</span>)enable forSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span>*)sessionConfig</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Runtime check to make sure the API is available on this version</span></span><br><span class="line">    <span class="keyword">if</span> ([sessionConfig respondsToSelector:<span class="keyword">@selector</span>(protocolClasses)]</span><br><span class="line">        &amp;&amp; [sessionConfig respondsToSelector:<span class="keyword">@selector</span>(setProtocolClasses:)])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> * urlProtocolClasses = [<span class="built_in">NSMutableArray</span> arrayWithArray:sessionConfig.protocolClasses];</span><br><span class="line">        Class protoCls = HTTPStubsProtocol.class;</span><br><span class="line">        <span class="keyword">if</span> (enable &amp;&amp; ![urlProtocolClasses containsObject:protoCls])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将自己的 NSURLProtocol 插入到 protocolClasses 的第一个，进行拦截</span></span><br><span class="line">            [urlProtocolClasses insertObject:protoCls atIndex:<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!enable &amp;&amp; [urlProtocolClasses containsObject:protoCls])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 拦截完成后移除</span></span><br><span class="line">            [urlProtocolClasses removeObject:protoCls];</span><br><span class="line">        &#125;</span><br><span class="line">        sessionConfig.protocolClasses = urlProtocolClasses;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"[OHHTTPStubs] %@ is only available when running on iOS7+/OSX9+. "</span></span><br><span class="line">              <span class="string">@"Use conditions like 'if ([NSURLSessionConfiguration class])' to only call "</span></span><br><span class="line">              <span class="string">@"this method if the user is running iOS7+/OSX9+."</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何拦截-wkwebview">如何拦截 WKWebView</h2>
<p>虽然 NSURLProtocol 无法直接拦截 WKWebView，但其实还是有解决方案的。就是使用 <code>WKBrowsingContextController</code> 和 <code>registerSchemeForCustomProtocol</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册 scheme</span></span><br><span class="line">Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"WKBrowsingContextController"</span>);</span><br><span class="line">SEL sel = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"registerSchemeForCustomProtocol:"</span>);</span><br><span class="line"><span class="keyword">if</span> ([cls respondsToSelector:sel]) &#123;</span><br><span class="line">    <span class="comment">// 通过 http 和 https 的请求，同理可通过其他的 Scheme 但是要满足 URL Loading System</span></span><br><span class="line">    [cls performSelector:sel withObject:<span class="string">@"http"</span>];</span><br><span class="line">    [cls performSelector:sel withObject:<span class="string">@"https"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但由于这涉及到了私有方法，直接引用无法过苹果的机审，所以使用的时候需要对字符串做下处理，比如对方法名进行算法加密处理等，实测也是可以通过审核的。</p>
<p>总之，NSURLProtocol 非常强大，无论是优化 App 的性能，还是拓展功能，都具有很强的可塑空间，但在使用的同时，又要多关注它带来的问题。尽管它在很多框架或者知名项目中都已经得以应用，其奥义依然值得开发者们去深入研究。</p>
<h1 id="总结">总结</h1>
<p>我认真看了作者的文章 强烈推荐iOS开发小伙伴学习一下.</p>

  </section>

</article>


    <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           ↑<br>
           欣赏此文？求鼓励，求支持！
        </span>
        <br>
    </div>  
    <div id="donate_guide" class="donate_bar center hidden" >
        <!-- 方式一： 
            ![](/img/Alipay.jpg)
            ![](/img/WeChatpay.jpg)
        -->
        <!-- 方式二；
            step1：在_config.yml中添加配置
                Alipay: /img/Alipay.jpg
                WeChatpay: /img/WeChatpay.jpg
            step2：此处两张图片的路径分别设置为如下
                <img src="undefined"
                <img src="undefined"
        -->
        <!-- 支付宝打赏图案 -->
        <img src="/images/Alipay.jpg" alt="支付宝打赏">
        <!-- 微信打赏图案 -->
        <img src="/images/WeChatpay.jpg" alt="微信打赏">
    </div>
    <script type="text/javascript">
        document.getElementById('btn_donate').onclick = function(){
            $('#donate_board').addClass('hidden');
            $('#donate_guide').removeClass('hidden');
        }
    </script>
</div>

<! -- 添加捐赠图标 -->



<section class="read-more">
     
        
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2020/04/07/20200407MasonryTricks/" title="使用Masonry处理UIView的safeArea边界布局问题">使用Masonry处理UIView的safeArea边界布局问题</a></h2>
                <p class="excerpt">
                
                前言
本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.
背景
iOS11之后推出的safe
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-04-07T03:54:39.000Z" class="post-list__meta--date date">2020-04-07</time>
 &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/Masonry/">Masonry</a>, <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>

</span><a class="btn-border-small" href="/2020/04/07/20200407MasonryTricks/">继续阅读</a></div>

            </div>
        

        
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2020/02/07/20200207SunyazhouTheory/" title="《孙亚洲理论》的诞生">《孙亚洲理论》的诞生</a></h2>
                <p class="excerpt">
                
                前言
由于基础知识薄弱，我所做到的内容仅限于学习和观察到的一些事实，未能上升为理论学说.
非著名的《The Sunyazhou Theory》
国家要想发展必须从提高生产力上入手，技术是目前为止人类发现唯一解决生产力问题的有力工具。 所以我把生产力分为三个阶段:

解放生产力

提高生产力

突破生
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-02-06T20:59:11.000Z" class="post-list__meta--date date">2020-02-07</time>
 &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/macOS开发/">macOS开发</a>

</span><a class="btn-border-small" href="/2020/02/07/20200207SunyazhouTheory/">继续阅读</a></div>

            </div>
        
   
</section>



  <div id="gitalk-container" style="padding: 0px 30px 0px 30px;"></div> 

  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script type="text/javascript">

  if(true){
    var gitalk = new Gitalk({
      clientID: '15c55ed469ea673ae332',
      clientSecret: '1801dbf9b1589c256260c85d779eb51d0cf40885',
      repo: 'gitment-comments',
      owner: 'sunyazhou13',
      admin: ['sunyazhou13'],
      id: 'Fri Mar 20 2020 11:34:22 GMT+0800',
      distractionFreeMode: 'true'
  })
  gitalk.render('gitalk-container') 
  }
  </script>




            <footer class="footer">
    <span class="footer__copyright">
        本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 和 Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2020 - 本站由 <a href="/">@sunyazhou13</a> 创建,
        使用<a href="https://github.com/lenbo-ma/hexo-theme-vno">hexo-theme-vno</a>主题,
        修改自<a href="https://github.com/onevcat/vno" target="_blank">喵神的vno</a>
    </span>
</footer>

        </div>
    </div>

    <script src="https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>

     




    


    

<script type="text/javascript">

// var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
// document.write(unescape("%3Cspan id='cnzz_stat_icon_1274885345'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1274885345%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));

var cnzz_s_tag = document.createElement('script');
cnzz_s_tag.type = 'text/javascript';
cnzz_s_tag.async = true;
cnzz_s_tag.charset = "utf-8";
cnzz_s_tag.src = src="https://s13.cnzz.com/z_stat.php?id=1274885345&web_id=1274885345&async=1";
var root_s = document.getElementsByTagName('script')[0];
root_s.parentNode.insertBefore(cnzz_s_tag, root_s);

</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
