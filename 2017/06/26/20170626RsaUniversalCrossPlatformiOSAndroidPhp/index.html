<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>iOS Android Php RSA加密解密通配方案 | 東引甌越</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="iOS Android Php RSA加密解密通配方案 | 東引甌越">
    <meta name="twitter:description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="iOS Android Php RSA加密解密通配方案 | 東引甌越">
    <meta property="og:description" content="我是孙亚洲(@sunyazhou13),一名来自北国冰城的iOS开发者,走在成为圣贤的路上.">

    
    <meta name="author" content="sunyazhou">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//apps.bdimg.com/libs/fontawesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/favicon.ico">
    

    
    <link rel="apple-touch-icon" href="/images/logo.jpg">
    
    
    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="東引甌越" href="/atom.xml">
    

    <link rel="canonical" href="https://www.sunyazhou.com/2017/06/26/20170626RsaUniversalCrossPlatformiOSAndroidPhp/"/>

    
    <link rel="author" href="https://plus.google.com/107423989995616646161"/>
    
    <!-- fancybox support -->
    
        <script src="/lib/jquery-3.3.1.min.js"></script>
        <link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.min.css">
        <script src="/lib/fancybox/dist/jquery.fancybox.min.js"></script>
        <script src="/js/wrapImage.js"></script>
    
</head>

<body class="home-template no-js">

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 東引甌越 的主页"><img src="/images/logo2.jpg" width="80" alt="東引甌越 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 東引甌越">東引甌越</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">不断学习, 与时俱进. - 始于2017</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">文章</a></li>
            
              <li class="navigation__item"><a href="/archives">归档</a></li>
            
              <li class="navigation__item"><a href="/projects">作品</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/sunyazhou13" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/sunyazhou13" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  
  <li class="navigation__item">
    <a href="https://plus.google.com/107423989995616646161" title="Google+" target="_blank">
      <i class='social fa fa-google-plus-square'></i>
      <span class="label">Google+</span>
    </a>
  </li>


<!-- Facebook -->


<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/sunyazhou" title="上Twitter找我" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

<!-- instagram -->


  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>


  <li class="navigation__item">
    <a href="mailto:sunyazhou13@163.com" title="邮件联系我" target="_blank">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-red"></div>
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-06-26T02:42:47.000Z" class="post-list__meta--date date">2017-06-26</time>
 &#8226; <span class="post-meta__tags tags">分类&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/macOS开发/">macOS开发</a>, <a class="tag-link" href="/tags/安全/">安全</a>

</span>
    </div>
    <h1 class="post-title">iOS Android Php RSA加密解密通配方案</h1>
  </header>

  <section class="post">
    <p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/rsa-universal-cross-platform-ios-android-php/rsa-red-logo.png"></p>
<h1 id="前言">前言</h1>
<p>先膜拜一下 RSA的作者</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/rsa-universal-cross-platform-ios-android-php/rsa-team.jpg"></p>
<p>RSA非对称加密 原理 各种。。。 请自行百度</p>
<h2 id="弯路">弯路</h2>
<p>最近开发涉及到如何使用RSA进行鉴权 等技术。。。老实说 我找了一圈根本就找到一个真正能在 iOS、Android、web跑通的代码. 浪费了好几天开发时间 就没有一个靠谱能好使的 所以我必须发一篇博客 把真正 好使的代码拿出来 share一下 (当时我真的 想骂娘了 我擦 百度搜出来的 一堆垃圾)</p>
<h1 id="代码实现">代码实现</h1>
<h2 id="第一步-生成公私钥对">第一步 生成公私钥对</h2>
<h3 id="命令生成原始-rsa私钥文件-rsa_private_key.pem">命令生成原始 RSA私钥文件 rsa_private_key.pem</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out rsa_private_key.pem 1024</span><br></pre></td></tr></table></figure>
<h3 id="命令将原始-rsa私钥转换为-pkcs8格式">命令将原始 RSA私钥转换为 pkcs8格式</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -inform PEM -<span class="keyword">in</span> rsa_private_key.pem -outform PEM -nocrypt -out private_key.pem</span><br></pre></td></tr></table></figure>
<h3 id="生成rsa公钥-rsa_public_key.pem">生成RSA公钥 rsa_public_key.pem</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> rsa_private_key.pem -pubout -out rsa_public_key.pem</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面看出通过私钥能生成对应的公钥，因此我们将私钥<code>private_key.pem</code>用在<em>服务器端</em>，<em>公钥</em>发放给<code>android</code>跟<code>ios</code>等前端</p>
</blockquote>
<h2 id="第二步-php代码实现">第二步 php代码实现</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunyazhou (http://www.sunyazhou.com/)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@created</span> 2017-6-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rsa</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> $PRIVATE_KEY = <span class="string">'-----BEGIN PRIVATE KEY-----</span></span><br><span class="line"><span class="string">xxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="string">/xxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="string">y4dDpCOn</span></span><br><span class="line"><span class="string">A4tBsIdpMMoT+w==</span></span><br><span class="line"><span class="string">-----END PRIVATE KEY-----'</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *返回对应的私钥</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getPrivateKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        $privKey = <span class="keyword">self</span>::$PRIVATE_KEY;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> openssl_pkey_get_private($privKey);      </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥加密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">privEncrypt</span><span class="params">($data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_string($data))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;           </span><br><span class="line">        <span class="keyword">return</span> openssl_private_encrypt($data,$encrypted,<span class="keyword">self</span>::getPrivateKey())? base64_encode($encrypted) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">privDecrypt</span><span class="params">($encrypted)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_string($encrypted))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (openssl_private_decrypt(base64_decode($encrypted), $decrypted, <span class="keyword">self</span>::getPrivateKey()))? $decrypted : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开<code>private_key.pem</code>，将上面的$PRIVATE_KEY，替换成private_key.pem的内容即可，服务器端我们只需要使用私钥来加密解密。</p>
<h2 id="第三步-android端-代码实现">第三步 android端 代码实现</h2>
<p>使用java的Cipher类来实现加密解密类，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.util.Base64;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> alun (http://alunblog.duapp.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@created</span> 2013-5-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rsa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RSA_PUBLICE =</span><br><span class="line">            <span class="string">"xxxxxxxxxxxxxxxxC"</span> + <span class="string">"\r"</span> +</span><br><span class="line">            <span class="string">"Qf/xxxxxxxhVuwdNH6aRFE0ms3bkpp/WL4cfVDgnCO"</span> + <span class="string">"\r"</span> +</span><br><span class="line">            <span class="string">"+W9J6vRVpuTuD/xxxxxxxxbJeO74fYnYqo/mmyJSeLE5iZg4I"</span> + <span class="string">"\r"</span> +</span><br><span class="line">            <span class="string">"Zm5LPWBZWUp3ULCAZQIDAQAB"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"RSA"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bysKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKeyFromX509</span><span class="params">(String algorithm,</span></span></span><br><span class="line"><span class="function"><span class="params">            String bysKey)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] decodedKey = Base64.decode(bysKey,Base64.DEFAULT);</span><br><span class="line">        X509EncodedKeySpec x509 = <span class="keyword">new</span> X509EncodedKeySpec(decodedKey);</span><br><span class="line"> </span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePublic(x509);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用公钥加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptByPublic</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PublicKey pubkey = getPublicKeyFromX509(ALGORITHM, RSA_PUBLICE);</span><br><span class="line"> </span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"RSA/ECB/PKCS1Padding"</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, pubkey);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">byte</span> plaintext[] = content.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] output = cipher.doFinal(plaintext);</span><br><span class="line"> </span><br><span class="line">            String s = <span class="keyword">new</span> String(Base64.encode(output,Base64.DEFAULT));</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用公钥解密</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> content 密文</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 商户私钥</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 解密后的字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decryptByPublic</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PublicKey pubkey = getPublicKeyFromX509(ALGORITHM, RSA_PUBLICE);</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"RSA/ECB/PKCS1Padding"</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, pubkey);</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> ByteArrayInputStream(Base64.decode(content,Base64.DEFAULT));</span><br><span class="line">            ByteArrayOutputStream writer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span>];</span><br><span class="line">            <span class="keyword">int</span> bufl;</span><br><span class="line">            <span class="keyword">while</span> ((bufl = ins.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] block = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (buf.length == bufl) &#123;</span><br><span class="line">                block = buf;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                block = <span class="keyword">new</span> <span class="keyword">byte</span>[bufl];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bufl; i++) &#123;</span><br><span class="line">                    block[i] = buf[i];</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                writer.write(cipher.doFinal(block));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(writer.toByteArray(), <span class="string">"utf-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__<em>注意:</em>__在初始化<code>Cipher</code>对象时，一定要指明使用<code>"RSA/ECB/PKCS1Padding"</code>格式如<code>Cipher.getInstance("RSA/ECB/PKCS1Padding");</code> 打开<code>rsa_public_key.pem</code>文件，将上面代码的<code>RSA_PUBLICE</code>替换成其中内容即可.</p>
<h2 id="第四步-ios端代码实现">第四步 iOS端代码实现</h2>
<p>iOS上没有直接处理RSA加密的API，网上说的大多数也是处理X.509的证书的方法来实现，不过X.509证书是带签名的，在php端<code>openssl_pkey_get_private</code>方法获取密钥时，第二个参数需要传签名，而android端实现X.509证书加密解密较为不易，在这里我们利用ios兼容c程序的特点，利用openssl的api实现rsa的加密解密，代码如下：</p>
<p>CRSA.h代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CRSA.h</span></span><br><span class="line"><span class="comment">//  RSA_C_demo</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by sunyazhou on 2017/6/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017年 Kingsoft, Inc. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;openssl/err.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    KeyTypePublic,</span><br><span class="line">    KeyTypePrivate</span><br><span class="line">&#125;KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    RSA_PADDING_TYPE_NONE       = RSA_NO_PADDING,</span><br><span class="line">    RSA_PADDING_TYPE_PKCS1      = RSA_PKCS1_PADDING,</span><br><span class="line">    RSA_PADDING_TYPE_SSLV23     = RSA_SSLV23_PADDING</span><br><span class="line">&#125;RSA_PADDING_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CRSA</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    RSA *_rsa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)<span class="built_in">NSString</span> *rsaKeyPath; <span class="comment">//证书路径</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)shareInstance;</span><br><span class="line">- (<span class="built_in">BOOL</span>)importRSAKeyFromeStringWithType:(KeyType)type andKey:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="built_in">BOOL</span>)importRSAKeyWithType:(KeyType)type;</span><br><span class="line">- (<span class="keyword">int</span>)getBlockSizeWithRSA_PADDING_TYPE:(RSA_PADDING_TYPE)padding_type;</span><br><span class="line">- (<span class="built_in">NSString</span> *)encryptByRsa:(<span class="built_in">NSString</span>*)content withKeyType:(KeyType)keyType;</span><br><span class="line">- (<span class="built_in">NSString</span> *)decryptByRsa:(<span class="built_in">NSString</span>*)content withKeyType:(KeyType)keyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>CRSA.m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//  CRSA.m</span><br><span class="line">//  RSA_C_demo</span><br><span class="line">//</span><br><span class="line">//  Created by sunyazhou on 2017/6/25.</span><br><span class="line">//  Copyright © 2017年 Kingsoft, Inc. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;CRSA.h&quot;</span><br><span class="line"></span><br><span class="line">#define BUFFSIZE  1024</span><br><span class="line">//#import &quot;NSString+Base64.h&quot;</span><br><span class="line">//#import &quot;NSData+Base64.h&quot;</span><br><span class="line"></span><br><span class="line">#define PADDING RSA_PADDING_TYPE_PKCS1</span><br><span class="line">@implementation CRSA</span><br><span class="line"></span><br><span class="line">+ (id)shareInstance</span><br><span class="line">&#123;</span><br><span class="line">    static KSYCRSA *_crsa = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _crsa = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _crsa;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)importRSAKeyWithType:(KeyType)type</span><br><span class="line">&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    NSString *keyName = type == KeyTypePublic ? @&quot;public_key&quot; : @&quot;private_key&quot;;</span><br><span class="line">    NSString *keyPath = [[NSBundle mainBundle] pathForResource:keyName ofType:@&quot;pem&quot;];</span><br><span class="line">    </span><br><span class="line">    file = fopen([keyPath UTF8String], &quot;rb&quot;);</span><br><span class="line">    </span><br><span class="line">    if (NULL != file)</span><br><span class="line">    &#123;</span><br><span class="line">        if (type == KeyTypePublic)</span><br><span class="line">        &#123;</span><br><span class="line">            _rsa = PEM_read_RSA_PUBKEY(file, NULL, NULL, NULL);</span><br><span class="line">            assert(_rsa != NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            _rsa = PEM_read_RSAPrivateKey(file, NULL, NULL, NULL);</span><br><span class="line">            assert(_rsa != NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fclose(file);</span><br><span class="line">        </span><br><span class="line">        return (_rsa != NULL) ? YES : NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)importRSAKeyWithPath:(KeyType)type</span><br><span class="line">&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    NSString *keyName = type == KeyTypePublic ? @&quot;public_key.pem&quot; : @&quot;private_key.pem&quot;;</span><br><span class="line">    NSString *keyPath = [self.rsaKeyPath stringByAppendingPathComponent:keyName];</span><br><span class="line">    file = fopen([keyPath UTF8String], &quot;rb&quot;);</span><br><span class="line">    </span><br><span class="line">    if (NULL != file)</span><br><span class="line">    &#123;</span><br><span class="line">        if (type == KeyTypePublic)</span><br><span class="line">        &#123;</span><br><span class="line">            _rsa = PEM_read_RSA_PUBKEY(file, NULL, NULL, NULL);</span><br><span class="line">            assert(_rsa != NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            _rsa = PEM_read_RSAPrivateKey(file, NULL, NULL, NULL);</span><br><span class="line">            assert(_rsa != NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fclose(file);</span><br><span class="line">        </span><br><span class="line">        return (_rsa != NULL) ? YES : NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (BOOL)importRSAKeyFromeStringWithType:(KeyType)type andKey:(NSString *)key&#123;</span><br><span class="line">    if (key.length == 0) &#123; return NO; &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    BIO *keybio ;</span><br><span class="line">    keybio = BIO_new_mem_buf((__bridge void *)(key), -1);</span><br><span class="line">    if (keybio==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf( &quot;Failed to create key BIO&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(type == KeyTypePublic)</span><br><span class="line">    &#123;</span><br><span class="line">        _rsa = PEM_read_bio_RSA_PUBKEY(keybio, &amp;_rsa,NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        _rsa = PEM_read_bio_RSAPrivateKey(keybio, &amp;_rsa,NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    BIO_free(keybio);</span><br><span class="line">    return (_rsa != NULL) ? YES : NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *) encryptByRsa:(NSString*)content withKeyType:(KeyType)keyType</span><br><span class="line">&#123;</span><br><span class="line">    if (![self importRSAKeyWithPath:keyType])</span><br><span class="line">        return nil;</span><br><span class="line">//    if (![self importRSAKeyWithType:keyType])</span><br><span class="line">//        return nil;</span><br><span class="line">    </span><br><span class="line">    int status;</span><br><span class="line">    NSUInteger length  = [content length];</span><br><span class="line">    unsigned char input[length + 1];</span><br><span class="line">    bzero(input, length + 1);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        input[i] = [content characterAtIndex:i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSInteger  flen = [self getBlockSizeWithRSA_PADDING_TYPE:PADDING];</span><br><span class="line">    </span><br><span class="line">    char *encData = (char*)malloc(flen);</span><br><span class="line">    bzero(encData, flen);</span><br><span class="line">    </span><br><span class="line">    switch (keyType) &#123;</span><br><span class="line">        case KeyTypePublic:</span><br><span class="line">            status = RSA_public_encrypt(length, (unsigned char*)input, (unsigned char*)encData, _rsa, PADDING);</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        default:</span><br><span class="line">            status = RSA_private_encrypt(length, (unsigned char*)input, (unsigned char*)encData, _rsa, PADDING);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (status)</span><br><span class="line">    &#123;</span><br><span class="line">        NSData *returnData = [NSData dataWithBytes:encData length:status];</span><br><span class="line">        free(encData);</span><br><span class="line">        encData = NULL;</span><br><span class="line">        </span><br><span class="line">        NSString *ret = [self base64EncodedStringForData:returnData ];</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(encData);</span><br><span class="line">    encData = NULL;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *) decryptByRsa:(NSString*)content withKeyType:(KeyType)keyType</span><br><span class="line">&#123;</span><br><span class="line">    if (![self importRSAKeyWithPath:keyType])</span><br><span class="line">        return nil;</span><br><span class="line">//    if (![self importRSAKeyWithType:keyType])</span><br><span class="line">//        return nil;</span><br><span class="line">    </span><br><span class="line">    int status;</span><br><span class="line">    </span><br><span class="line">    NSData *data = [self base64DecodedDataForString:content];</span><br><span class="line">    NSUInteger length = [data length];</span><br><span class="line">    </span><br><span class="line">    NSInteger flen = [self getBlockSizeWithRSA_PADDING_TYPE:PADDING];</span><br><span class="line">    char *decData = (char*)malloc(flen);</span><br><span class="line">    bzero(decData, flen);</span><br><span class="line">    </span><br><span class="line">    switch (keyType) &#123;</span><br><span class="line">        case KeyTypePublic:</span><br><span class="line">            status = RSA_public_decrypt(length, (unsigned char*)[data bytes], (unsigned char*)decData, _rsa, PADDING);</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        default:</span><br><span class="line">            status = RSA_private_decrypt(length, (unsigned char*)[data bytes], (unsigned char*)decData, _rsa, PADDING);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (status)</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableString *decryptString = [[NSMutableString alloc] initWithBytes:decData length:strlen(decData) encoding:NSASCIIStringEncoding];</span><br><span class="line">        free(decData);</span><br><span class="line">        decData = NULL;</span><br><span class="line">        </span><br><span class="line">        return decryptString;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(decData);</span><br><span class="line">    decData = NULL;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)getBlockSizeWithRSA_PADDING_TYPE:(RSA_PADDING_TYPE)padding_type</span><br><span class="line">&#123;</span><br><span class="line">    int len = RSA_size(_rsa);</span><br><span class="line">    </span><br><span class="line">    if (padding_type == RSA_PADDING_TYPE_PKCS1 || padding_type == RSA_PADDING_TYPE_SSLV23) &#123;</span><br><span class="line">        len -= 11;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//---------------加密工具方法</span><br><span class="line">- (NSString *)base64EncodedStringForData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    return [self base64EncodedStringWithWrapWidth:0 data:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)base64EncodedStringWithWrapWidth:(NSUInteger)wrapWidth data:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    //ensure wrapWidth is a multiple of 4</span><br><span class="line">    wrapWidth = (wrapWidth / 4) * 4;</span><br><span class="line">    </span><br><span class="line">    const char lookup[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</span><br><span class="line">    </span><br><span class="line">    long long inputLength = [data length];</span><br><span class="line">    const unsigned char *inputBytes = [data bytes];</span><br><span class="line">    </span><br><span class="line">    long long maxOutputLength = (inputLength / 3 + 1) * 4;</span><br><span class="line">    maxOutputLength += wrapWidth? (maxOutputLength / wrapWidth) * 2: 0;</span><br><span class="line">    unsigned char *outputBytes = (unsigned char *)malloc(maxOutputLength);</span><br><span class="line">    </span><br><span class="line">    long long i;</span><br><span class="line">    long long outputLength = 0;</span><br><span class="line">    for (i = 0; i &lt; inputLength - 2; i += 3)</span><br><span class="line">    &#123;</span><br><span class="line">        outputBytes[outputLength++] = lookup[(inputBytes[i] &amp; 0xFC) &gt;&gt; 2];</span><br><span class="line">        outputBytes[outputLength++] = lookup[((inputBytes[i] &amp; 0x03) &lt;&lt; 4) | ((inputBytes[i + 1] &amp; 0xF0) &gt;&gt; 4)];</span><br><span class="line">        outputBytes[outputLength++] = lookup[((inputBytes[i + 1] &amp; 0x0F) &lt;&lt; 2) | ((inputBytes[i + 2] &amp; 0xC0) &gt;&gt; 6)];</span><br><span class="line">        outputBytes[outputLength++] = lookup[inputBytes[i + 2] &amp; 0x3F];</span><br><span class="line">        </span><br><span class="line">        //add line break</span><br><span class="line">        if (wrapWidth &amp;&amp; (outputLength + 2) % (wrapWidth + 2) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            outputBytes[outputLength++] = &apos;\r&apos;;</span><br><span class="line">            outputBytes[outputLength++] = &apos;\n&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //handle left-over data</span><br><span class="line">    if (i == inputLength - 2)</span><br><span class="line">    &#123;</span><br><span class="line">        // = terminator</span><br><span class="line">        outputBytes[outputLength++] = lookup[(inputBytes[i] &amp; 0xFC) &gt;&gt; 2];</span><br><span class="line">        outputBytes[outputLength++] = lookup[((inputBytes[i] &amp; 0x03) &lt;&lt; 4) | ((inputBytes[i + 1] &amp; 0xF0) &gt;&gt; 4)];</span><br><span class="line">        outputBytes[outputLength++] = lookup[(inputBytes[i + 1] &amp; 0x0F) &lt;&lt; 2];</span><br><span class="line">        outputBytes[outputLength++] =   &apos;=&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (i == inputLength - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        // == terminator</span><br><span class="line">        outputBytes[outputLength++] = lookup[(inputBytes[i] &amp; 0xFC) &gt;&gt; 2];</span><br><span class="line">        outputBytes[outputLength++] = lookup[(inputBytes[i] &amp; 0x03) &lt;&lt; 4];</span><br><span class="line">        outputBytes[outputLength++] = &apos;=&apos;;</span><br><span class="line">        outputBytes[outputLength++] = &apos;=&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //truncate data to match actual output length</span><br><span class="line">    outputBytes = realloc(outputBytes, outputLength);</span><br><span class="line">    NSString *result = [[NSString alloc] initWithBytesNoCopy:outputBytes length:outputLength encoding:NSASCIIStringEncoding freeWhenDone:YES];</span><br><span class="line">    </span><br><span class="line">#if !__has_feature(objc_arc)</span><br><span class="line">    [result autorelease];</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    return (outputLength &gt;= 4)? result: nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSData *)base64DecodedDataForString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    return [self dataWithBase64EncodedString:string];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSData *)dataWithBase64EncodedString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    const char lookup[] =</span><br><span class="line">    &#123;</span><br><span class="line">        99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,</span><br><span class="line">        99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,</span><br><span class="line">        99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 62, 99, 99, 99, 63,</span><br><span class="line">        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 99, 99, 99, 99, 99, 99,</span><br><span class="line">        99,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,</span><br><span class="line">        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 99, 99, 99, 99, 99,</span><br><span class="line">        99, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,</span><br><span class="line">        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 99, 99, 99, 99, 99</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    NSData *inputData = [string dataUsingEncoding:NSASCIIStringEncoding allowLossyConversion:YES];</span><br><span class="line">    long long inputLength = [inputData length];</span><br><span class="line">    const unsigned char *inputBytes = [inputData bytes];</span><br><span class="line">    </span><br><span class="line">    long long maxOutputLength = (inputLength / 4 + 1) * 3;</span><br><span class="line">    NSMutableData *outputData = [NSMutableData dataWithLength:maxOutputLength];</span><br><span class="line">    unsigned char *outputBytes = (unsigned char *)[outputData mutableBytes];</span><br><span class="line">    </span><br><span class="line">    int accumulator = 0;</span><br><span class="line">    long long outputLength = 0;</span><br><span class="line">    unsigned char accumulated[] = &#123;0, 0, 0, 0&#125;;</span><br><span class="line">    for (long long i = 0; i &lt; inputLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned char decoded = lookup[inputBytes[i] &amp; 0x7F];</span><br><span class="line">        if (decoded != 99)</span><br><span class="line">        &#123;</span><br><span class="line">            accumulated[accumulator] = decoded;</span><br><span class="line">            if (accumulator == 3)</span><br><span class="line">            &#123;</span><br><span class="line">                outputBytes[outputLength++] = (accumulated[0] &lt;&lt; 2) | (accumulated[1] &gt;&gt; 4);</span><br><span class="line">                outputBytes[outputLength++] = (accumulated[1] &lt;&lt; 4) | (accumulated[2] &gt;&gt; 2);</span><br><span class="line">                outputBytes[outputLength++] = (accumulated[2] &lt;&lt; 6) | accumulated[3];</span><br><span class="line">            &#125;</span><br><span class="line">            accumulator = (accumulator + 1) % 4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //handle left-over data</span><br><span class="line">    if (accumulator &gt; 0) outputBytes[outputLength] = (accumulated[0] &lt;&lt; 2) | (accumulated[1] &gt;&gt; 4);</span><br><span class="line">    if (accumulator &gt; 1) outputBytes[++outputLength] = (accumulated[1] &lt;&lt; 4) | (accumulated[2] &gt;&gt; 2);</span><br><span class="line">    if (accumulator &gt; 2) outputLength++;</span><br><span class="line">    </span><br><span class="line">    //truncate data to match actual output length</span><br><span class="line">    outputData.length = outputLength;</span><br><span class="line">    return outputLength? outputData: nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里面我增加了 密钥直接从字符串读取的方法 原来方法是 从<code>NSBundle</code>读取private_key.pem和 public_key.pem 但是考虑到被篡改 我增加了 密钥直接搞成字符串(把字符串写到本地沙盒然后加载文件的方式) 这样代码 安全就提高了一些 如果能破译.m的话 拿到的也只能是 publicKey(公钥) 只要不能篡改 就是安全的</p>
</blockquote>
<h3 id="外部调用">外部调用</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *publicKey = <span class="string">@"-----BEGIN PUBLIC KEY-----\n此处替换生成的公钥 记得换行 按照一定规则加'\n'  \n-----END PUBLIC KEY-----"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *privateKey = <span class="string">@"-----BEGIN PRIVATE KEY-----\n  此处替换生成的私钥 \n-----END PRIVATE KEY-----"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取Documents目录路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *docDir = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) firstObject];</span><br><span class="line">    <span class="built_in">NSString</span> *bundleIdentifier = [[<span class="built_in">NSBundle</span> mainBundle] bundleIdentifier];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [docDir stringByAppendingFormat:<span class="string">@"/%@"</span>,bundleIdentifier];</span><br><span class="line">    <span class="built_in">NSString</span> *publicKeyPath = [path stringByAppendingPathComponent:<span class="string">@"public_key.pem"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *privateKeyPath = [path stringByAppendingPathComponent:<span class="string">@"private_key.pem"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> isDir;</span><br><span class="line">    <span class="built_in">BOOL</span> exists = [fm fileExistsAtPath:path isDirectory:&amp;isDir];</span><br><span class="line">    <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">        <span class="comment">/* file exists */</span></span><br><span class="line">        <span class="keyword">if</span> (isDir) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">            <span class="built_in">BOOL</span> pubResult = [publicKey writeToFile:publicKeyPath atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[error localizedDescription]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">BOOL</span> privateResult = [privateKey writeToFile:privateKeyPath atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[error localizedDescription]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        [fm createDirectoryAtPath:path withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">        <span class="built_in">BOOL</span> pubResult = [publicKey writeToFile:publicKeyPath atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[error localizedDescription]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BOOL</span> privateResult = [privateKey writeToFile:privateKeyPath atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[error localizedDescription]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rsa.rsaKeyPath = path;</span><br><span class="line">    [rsa importRSAKeyFromeStringWithType:KeyTypePublic andKey:publicKeyPath];</span><br><span class="line">    </span><br><span class="line">    [rsa importRSAKeyFromeStringWithType:KeyTypePrivate andKey:privateKeyPath];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *pubDesc = [rsa encryptByRsa:<span class="string">@"需要加密的字符串"</span> withKeyType:KeyTypePrivate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"加密内容:%@\n--------\n"</span>,encryptString);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"摘要:\n---------\n%@\n--------\n"</span>,pubDesc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩下的大家自己探索一下 没什么难度</span></span><br></pre></td></tr></table></figure>
<p>其中openssl api包，我们可以在第一步RSA密钥生成工具openssl的include文件夹中得到</p>
<p>下面我说一下如何集成openssl到 iOS工程</p>
<h3 id="下载-openssl-library">1.下载 openssl library</h3>
<p><a href="https://github.com/st3fan/ios-openssl" target="_blank" rel="noopener">openssl ios下载</a></p>
<h3 id="导入到工程中">2.导入到工程中</h3>
<p>拖拽 openssl的库 _(包含 <code>include</code> &amp; <code>lib</code> 的文件夹 )_到工程中</p>
<p>然后 去 project targets -&gt; <code>Build Settings</code></p>
<ul>
<li>找到 <strong>Header Search Paths</strong>, 添加 <code>"${SRCROOT}/Libraries/openssl/include"</code> 为你的工程</li>
<li>找到 <strong>Library Search Paths</strong>, 添加 <code>"${SRCROOT}/Libraries/openssl/lib"</code></li>
</ul>
<p>然后就可以了如果中间出问题 请检查一下目录是否正确理论上应该是OK的</p>
<p>--</p>
<h2 id="最后说一下我遇到rsa加密的坑">最后说一下我遇到RSA加密的坑</h2>
<p>在iOS端加密 生成摘要到android的时候 android解析不出来(有时候解析出结果前面 一堆乱码) 这是base64有问题 建议 android使用原生的恩</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.util.Base64;</span><br></pre></td></tr></table></figure>
<p>如果是iOS 请使用 如下 Base64 <a href="https://github.com/nicklockwood/Base64" target="_blank" rel="noopener">base64来源</a></p>
<p>上边的ios 的base64和android一一对应 不要理解错了 随便搞个Base64就行了 不信我 你可以试试</p>
<p>base64的代码我已经把代码实现写到<code>CRSA.m</code>了 如果像剥离很简单</p>
<p>好 demo我就不写了 已经把所有实现都搞上去了</p>
<p>希望大家找到 好使的RSA方法实现 如果有问题 随时留言</p>
<p>最后我说一句 很简单的一个RSA跨平台方案 那些抄袭CSDN的文章小伙伴 少坑点人 连搜索引擎都不会放过你</p>
<p>全文完</p>
<p><a href="https://www.lvtao.net/dev/android_ios_php_openssl.html" target="_blank" rel="noopener">参考</a></p>

  </section>

</article>


    <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           ↑<br>
           欣赏此文？求鼓励，求支持！
        </span>
        <br>
    </div>  
    <div id="donate_guide" class="donate_bar center hidden" >
        <!-- 方式一： 
            ![](/img/Alipay.jpg)
            ![](/img/WeChatpay.jpg)
        -->
        <!-- 方式二；
            step1：在_config.yml中添加配置
                Alipay: /img/Alipay.jpg
                WeChatpay: /img/WeChatpay.jpg
            step2：此处两张图片的路径分别设置为如下
                <img src="undefined"
                <img src="undefined"
        -->
        <!-- 支付宝打赏图案 -->
        <img src="/images/Alipay.jpg" alt="支付宝打赏">
        <!-- 微信打赏图案 -->
        <img src="/images/WeChatpay.jpg" alt="微信打赏">
    </div>
    <script type="text/javascript">
        document.getElementById('btn_donate').onclick = function(){
            $('#donate_board').addClass('hidden');
            $('#donate_guide').removeClass('hidden');
        }
    </script>
</div>

<! -- 添加捐赠图标 -->



<section class="read-more">
     
        
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/06/26/20170626GetSandboxPathios/" title="iOS获取各种文件目录的路径">iOS获取各种文件目录的路径</a></h2>
                <p class="excerpt">
                
                // 获取沙盒主目录路径NSString *homeDir = NSHomeDirectory();// 获取Documents目录路径NSString *docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUse
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-06-26T08:44:22.000Z" class="post-list__meta--date date">2017-06-26</time>
 &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/macOS开发/">macOS开发</a>

</span><a class="btn-border-small" href="/2017/06/26/20170626GetSandboxPathios/">继续阅读</a></div>

            </div>
        

        
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/06/20/20170620EnableStaticAnalyer/" title="Xcode开启静态分析器">Xcode开启静态分析器</a></h2>
                <p class="excerpt">
                
                
Clang 静态分析器
Clang 编译器（也就是 XCode 使用的编译器）有一个 静态分析器(static analyer) ，用来执行代码控制流和数据流的分析，可以发现许多编译器检查不出的问题。
你可以在 Xcode 的 Product → Analyze 里手动运行分析器。
分析器可以运行
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-06-20T07:07:33.000Z" class="post-list__meta--date date">2017-06-20</time>
 &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/iOS开发/">iOS开发</a>, <a class="tag-link" href="/tags/macOS开发/">macOS开发</a>, <a class="tag-link" href="/tags/技巧/">技巧</a>

</span><a class="btn-border-small" href="/2017/06/20/20170620EnableStaticAnalyer/">继续阅读</a></div>

            </div>
        
   
</section>



  <div id="gitalk-container" style="padding: 0px 30px 0px 30px;"></div> 

  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script type="text/javascript">

  if(true){
    var gitalk = new Gitalk({
      clientID: '15c55ed469ea673ae332',
      clientSecret: '1801dbf9b1589c256260c85d779eb51d0cf40885',
      repo: 'gitment-comments',
      owner: 'sunyazhou13',
      admin: ['sunyazhou13'],
      id: 'Mon Jun 26 2017 10:42:47 GMT+0800',
      distractionFreeMode: 'true'
  })
  gitalk.render('gitalk-container') 
  }
  </script>




            <footer class="footer">
    <span class="footer__copyright">
        本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 和 Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2020 - 本站由 <a href="/">@sunyazhou13</a> 创建,
        使用<a href="https://github.com/lenbo-ma/hexo-theme-vno">hexo-theme-vno</a>主题,
        修改自<a href="https://github.com/onevcat/vno" target="_blank">喵神的vno</a>
    </span>
</footer>

        </div>
    </div>

    <script src="https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>

     




    


    

<script type="text/javascript">

// var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
// document.write(unescape("%3Cspan id='cnzz_stat_icon_1274885345'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1274885345%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));

var cnzz_s_tag = document.createElement('script');
cnzz_s_tag.type = 'text/javascript';
cnzz_s_tag.async = true;
cnzz_s_tag.charset = "utf-8";
cnzz_s_tag.src = src="https://s13.cnzz.com/z_stat.php?id=1274885345&web_id=1274885345&async=1";
var root_s = document.getElementsByTagName('script')[0];
root_s.parentNode.insertBefore(cnzz_s_tag, root_s);

</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
