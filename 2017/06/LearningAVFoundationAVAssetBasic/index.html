<!DOCTYPE html><html lang="zh-Hans" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.5.1"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Learning AV Foundation(四)AVAsset元数据(基础篇)" /><meta name="author" content="孙亚洲" /><meta property="og:locale" content="zh_Hans" /><meta name="description" content="嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者." /><meta property="og:description" content="嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者." /><link rel="canonical" href="https://www.sunyazhou.com/2017/06/LearningAVFoundationAVAssetBasic/" /><meta property="og:url" content="https://www.sunyazhou.com/2017/06/LearningAVFoundationAVAssetBasic/" /><meta property="og:site_name" content="迈腾大队长" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2017-06-16T18:11:19+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Learning AV Foundation(四)AVAsset元数据(基础篇)" /><meta name="twitter:site" content="@sunyazhou" /><meta name="twitter:creator" content="@孙亚洲" /><meta name="google-site-verification" content="Xo29j227HYVdC-vDA_-qJwvDP3PIo-lC78CFeBvhrDA" /> <script type="application/ld+json"> {"@type":"BlogPosting","headline":"Learning AV Foundation(四)AVAsset元数据(基础篇)","dateModified":"2017-06-16T18:11:19+08:00","datePublished":"2017-06-16T18:11:19+08:00","author":{"@type":"Person","name":"孙亚洲"},"url":"https://www.sunyazhou.com/2017/06/LearningAVFoundationAVAssetBasic/","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sunyazhou.com/2017/06/LearningAVFoundationAVAssetBasic/"},"description":"嗨,我是孙亚洲(@sunyazhou13),一名来自祖国北国冰城的iOS开发者.","@context":"https://schema.org"}</script><title>Learning AV Foundation(四)AVAsset元数据(基础篇) | 迈腾大队长</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/images/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">迈腾大队长</a></div><div class="site-subtitle font-italic">不断学习, 与时俱进.</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>主页</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/projects/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-paint-brush ml-xl-3 mr-xl-3 unloaded"></i> <span>作品</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } get isResolvedDarkMode() { if (this.isLightMode) { return false; } return this.isSysDarkPrefer; } updateCommentStyle() { var theme = "github-light"; if (this.isResolvedDarkMode) { theme = "photon-dark"; } let comment = document.querySelector("iframe.utterances-frame"); if (comment == null) { return; } comment.contentWindow.postMessage( { type: "set-theme", theme: theme }, "https://utteranc.es/" ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateCommentStyle(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/sunyazhou13" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/sunyazhou" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="https://www.weibo.com/sunyazhou13" aria-label="" target="_blank" rel="noopener"> <i class="fab fa-weibo"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sunyazhou','111.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 主页 </a> </span> <span>Learning AV Foundation(四)AVAsset元数据(基础篇)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Learning AV Foundation(四)AVAsset元数据(基础篇)</h1><div class="post-meta text-muted d-flex flex-column"><div> 　由 <span class="author"> 孙亚洲 </span> 发布于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Jun 16, 2017, 6:11 PM +0800" > 2017-06-16 <i class="unloaded">2017-06-16T18:11:19+08:00</i> </span></div><div> 最后更新: <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Feb 5, 2023, 4:47 PM +0800" > 02-05 <i class="unloaded">2023-02-05T16:47:37+08:00</i> </span></div></div><div class="post-content"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/AlbumDetail.webp" alt="" /></p><h1 id="前言">前言</h1><p>本篇讲述的<code class="language-plaintext highlighter-rouge">AVAsset</code>元数据(可以简单理解成 比如一个mp3音频格式的model信息. title:xxxx, art:刘德华, album:专辑 爱你一万年…. 等这些数据的来源). 当然这种意义上的字段信息 属于<code class="language-plaintext highlighter-rouge">AVAsset</code>的一个属性。<code class="language-plaintext highlighter-rouge">AV Foundation</code>通过<code class="language-plaintext highlighter-rouge">AVAsset</code>封装来处理各种音频的元数据, __比如从mp3文件中解析出来封面图(artwork)__等。 本章的具体内容如下:</p><h3 id="理解资源含义"><strong>理解资源含义</strong></h3><h3 id="创建资源"><strong>创建资源</strong></h3><ul><li>iOS Asset库<li>iOS iPod库<li>macOS iTunes库</ul><h3 id="异步载入"><strong>异步载入</strong></h3><h3 id="媒体元数据"><strong>媒体元数据</strong></h3><ul><li>元数据格式<ol><li>QuickTime<li>MPEG-4音频和视频(mp4)<li>MP3</ol></ul><h3 id="使用元数据"><strong>使用元数据</strong></h3><ul><li>查询元数据<li>使用<code class="language-plaintext highlighter-rouge">AVMetadataItem</code></ul><h3 id="创建metamanager-demo"><strong>创建MetaManager Demo</strong></h3><ul><li>MediaItem(相当于Model)<li>MediaItem实现<li><div class="table-wrapper"><table><tbody><tr><td>数据转换器(model to AVMetadataItem<td> <td>AVMetadataItem to mode)</table></div><li>DefaultMetadata默认转换<li>转换Artwork(唱片的封面或者专辑图那种)<li>转换注释<li>转换音轨数据(track)<li>转换唱片数据<li>转换风格数据(genre, eg: blue蓝调, classic古典,pop流行等126种..)<li>完成最终demo</ul><h4 id="保存元数据"><strong>保存元数据</strong></h4><hr /><h3 id="理解avasset资源含义"><strong>理解<code class="language-plaintext highlighter-rouge">AVAsset</code>资源含义</strong></h3><p><code class="language-plaintext highlighter-rouge">AVAsset</code>是一个不可变的抽象类,定义媒体资源混合呈现方式.里面包含音视频的<strong>曲目</strong>、<strong>格式</strong>、<strong>时长</strong>, 以及<strong>元数据NSData</strong>(二进制的bytes).</p><p><code class="language-plaintext highlighter-rouge">AVAsset</code>不用考虑媒体资源具有的两个范畴:</p><ul><li>提供对基本媒体格式的抽象层<li>不用考虑处理因为不同格式获取内容方式不一样</ul><p>这意味着无论是处理<code class="language-plaintext highlighter-rouge">Quick Time</code>影片、<code class="language-plaintext highlighter-rouge">MPEG-4</code>视频还是<code class="language-plaintext highlighter-rouge">MP3</code>音频，框架提供统一的接口，我们只需要理解只有资源这个概念。这样做的目的是为了__开发者在面对不同格式的内容时有一个统一的处理方法。不需要care多种编码器和容器格式因为细节不同而带来的困扰__. 当然获取这些其余信息可以通过其它方式实现. <code class="language-plaintext highlighter-rouge">AVAsset</code>还隐藏了资源位置(GPS定位)信息,当处理一个媒体对象时，通过URL来初始化init. URL可以是Bundle里面 也可以是沙盒的本地文件系统URL.也可以从iPod库中取到的URL。还可以是远程服务器的音频流或视频流的URL。</p><p><code class="language-plaintext highlighter-rouge">AVAsset</code>属于低耦合组件方式的封装 让框架来处理那些繁重的工作, 我们就可以很方便的不用考虑文件位置的前提下获取或者载入媒体。由于不用care文件合适和文件位置等复杂的问题。<code class="language-plaintext highlighter-rouge">AVAsset</code>为开发者处理<code class="language-plaintext highlighter-rouge">timed media(时基媒体)</code>提供了一种简单统一的方式.</p><p><code class="language-plaintext highlighter-rouge">AVAsset</code>本身不是媒体资源. 可以把它理解成承载<code class="language-plaintext highlighter-rouge">timed media(时基媒体)</code>的容器类。它有很多描述自身元数据的媒体组成. <code class="language-plaintext highlighter-rouge">AVAssetTrack</code>才是我们真正存储媒体资源的统一媒体类型。并对每个资源建立相应的model. <code class="language-plaintext highlighter-rouge">AVAssetTrack</code>最常见的形式就是 音频流和视频流, 但是他还可以用于表示诸如__文本__、<strong>副标题</strong>、__隐藏字幕__等媒体类型. 如下示意图理解<code class="language-plaintext highlighter-rouge">AVAsset</code> 和 <code class="language-plaintext highlighter-rouge">AVAssetTrack</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/AVAssetTrack.webp" alt="" /></p><p><em><strong><code class="language-plaintext highlighter-rouge">AVAsset.tracks</code></strong></em> 如下</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSArray</span><span class="o">&lt;</span><span class="n">AVAssetTrack</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="n">tracks</span><span class="p">;</span>

</pre></table></code></div></div><p>资源曲目可通过tracks属性访问到. 该属性返回一个NSArray的数组,这个数组中的元素就是专辑包含的所有曲目. 此外，<code class="language-plaintext highlighter-rouge">AVAsset</code>还可以通过标识符、媒体类型或媒体特征等信息找到相应的曲目.这使得在未来更高级的处理中我们可以很容易获取一组需要的曲目</p><h4 id="创建资源-1"><strong>创建资源</strong></h4><p>当为一个现有的媒体资源创建<code class="language-plaintext highlighter-rouge">AVAsset</code>对象时, 可以通过URL对它的进行的初始化来实现. 一般来说是一个本地文件URL, 也可以是远程的资源URL</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="n">NSURL</span> <span class="o">*</span><span class="n">assetURL</span> <span class="o">=</span> <span class="c1">//....</span>
    <span class="n">AVAsset</span> <span class="o">*</span><span class="n">asset</span> <span class="o">=</span> <span class="p">[</span><span class="n">AVAsset</span> <span class="nf">assetWithURL</span><span class="p">:</span> <span class="n">assetURL</span><span class="p">];</span>
</pre></table></code></div></div><blockquote><p>….</p></blockquote><p><code class="language-plaintext highlighter-rouge">AVAsset</code>是个抽象类, 它不能直接被实例化. 当使用<code class="language-plaintext highlighter-rouge">assetWithURL:</code>方法创建实例时,实际上是创建了<code class="language-plaintext highlighter-rouge">AVAsset</code>的子类<code class="language-plaintext highlighter-rouge">AVURLAsset</code> 有时候会直接使用这个类, 因为它允许通过传递选项字典来精细调整资源的创建方式, 举个例子,比如创建 用在音频或视频编辑场景中的资源, 可能希望传递一个选项(option)的字典来告诉程序提供更精确的时长和计时等信息 例如:</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>
    <span class="n">NSURL</span> <span class="o">*</span><span class="n">assetURL</span> <span class="o">=</span> <span class="c1">//....</span>
    <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">options</span> <span class="o">=</span> <span class="p">@{</span><span class="n">AVURLAssetPreferPreciseDurationAndTimingKey</span><span class="o">:</span><span class="nb">@YES</span><span class="p">};</span>
    <span class="n">AVAsset</span> <span class="o">*</span><span class="n">asset</span> <span class="o">=</span> <span class="p">[</span><span class="n">AVAsset</span> <span class="nf">assetWithURL</span><span class="p">:</span> <span class="n">assetURL</span><span class="p">];</span>
    
</pre></table></code></div></div><blockquote><p>…</p></blockquote><p>这里传递的是希望得到稍长一点的加载事件,来获取更精确的时长及时间信息.很多常见的位置是开发时大家想创建资源对象的地方. 在iOS设备上我们希望在用户的照片库中访问视频文件, 或者在iPod库中访问歌曲. 在Mac上 我们希望从用户的iTunes库中找到媒体项. 借助iOS和macOS中的这些辅助framework我们可以使用上边的媒体资源。下面介绍一下这些要用到的framework的例子</p><h5 id="ios-assets库">iOS Assets库</h5><p>在iOS上拍照或者通过前置和后置相机捕捉到的音视频,它们保存在用户的照片库中.iOS提供的Assets库框架可以实现从照片库中读写的功能, 下例从用户资源库中的视频创建一个AVAsset:</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">ALAssetsLibrary</span> <span class="o">*</span><span class="n">library</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ALAssetsLibrary</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="p">[</span><span class="n">library</span> <span class="nf">enumerateGroupsWithTypes</span><span class="p">:</span><span class="n">ALAssetsGroupSavedPhotos</span> <span class="nf">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">ALAssetsGroup</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="n">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//Filter down to only videos</span>
        <span class="p">[</span><span class="n">group</span> <span class="nf">setAssetsFilter</span><span class="p">:[</span><span class="n">ALAssetsFilter</span> <span class="nf">allVideos</span><span class="p">]];</span>
        
        <span class="c1">//Grab the first video returned</span>
        <span class="p">[</span><span class="n">group</span> <span class="nf">enumerateAssetsAtIndexes</span><span class="p">:[</span><span class="n">NSIndexSet</span> <span class="nf">indexSetWithIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="nf">options</span><span class="p">:</span><span class="mi">0</span> <span class="n">usingBlock</span><span class="o">:^</span><span class="p">(</span><span class="n">ALAsset</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">index</span><span class="p">,</span> <span class="n">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">id</span> <span class="n">representation</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span> <span class="nf">defaultRepresentation</span><span class="p">];</span>
                <span class="n">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="n">representation</span> <span class="nf">url</span><span class="p">];</span>
                <span class="n">AVAsset</span> <span class="o">*</span><span class="n">asset</span> <span class="o">=</span> <span class="p">[</span><span class="n">AVAsset</span> <span class="nf">assetWithURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
                <span class="c1">//创建 调用一些其它API</span>
            <span class="p">}</span>
        <span class="p">}];</span>
        
    <span class="p">}</span> <span class="n">failureBlock</span><span class="o">:^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"%@"</span><span class="p">,</span> <span class="p">[</span><span class="n">error</span> <span class="nf">localizedDescription</span><span class="p">]);</span>
    <span class="p">}];</span>
</pre></table></code></div></div><p>上面是如何获取保存在 相册中的视频资源(iOS10.10以后就废弃了上述方式) 获取出筛选结果的第一个视频, 库中的条目全部被建模为<code class="language-plaintext highlighter-rouge">ALAsset</code>对象, 为默认的呈现方式选用<code class="language-plaintext highlighter-rouge">ALAsset</code>类型返回一个<code class="language-plaintext highlighter-rouge">ALAssetRepresentation</code>对象,它提供了一个适用于创建<code class="language-plaintext highlighter-rouge">AVAset</code>的URL.</p><h5 id="ios-ipod库">iOS iPod库</h5><p>我们获取媒体的一个常见位置就是用户的iPod库. <code class="language-plaintext highlighter-rouge">MediaPlayer</code> framework 框架提供了API, 用于在iPod库中查询和获取条目. 当找到想获取的item时, 可以得到一个存储的URL并使用这个得到的URL初始化一个资源, 如下例所示:</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>    <span class="c1">//艺术家</span>
    <span class="n">MPMediaPropertyPredicate</span> <span class="o">*</span><span class="n">artistPredicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">MPMediaPropertyPredicate</span> <span class="nf">predicateWithValue</span><span class="p">:</span><span class="s">@"刘德华"</span> <span class="nf">forProperty</span><span class="p">:</span><span class="n">MPMediaItemPropertyArtist</span><span class="p">];</span>
    <span class="c1">//专辑</span>
    <span class="n">MPMediaPropertyPredicate</span> <span class="o">*</span><span class="n">albumPredicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">MPMediaPropertyPredicate</span> <span class="nf">predicateWithValue</span><span class="p">:</span><span class="s">@"真永远"</span> <span class="nf">forProperty</span><span class="p">:</span><span class="n">MPMediaItemPropertyAlbumTitle</span><span class="p">];</span>
    <span class="c1">//歌曲名称</span>
    <span class="n">MPMediaPropertyPredicate</span> <span class="o">*</span><span class="n">songPredicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">MPMediaPropertyPredicate</span> <span class="nf">predicateWithValue</span><span class="p">:</span><span class="s">@"爱你一万年"</span> <span class="nf">forProperty</span><span class="p">:</span><span class="n">MPMediaItemPropertyTitle</span><span class="p">];</span>
    <span class="c1">//查询</span>
    <span class="n">MPMediaQuery</span> <span class="o">*</span><span class="n">query</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MPMediaQuery</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="p">[</span><span class="n">query</span> <span class="nf">addFilterPredicate</span><span class="p">:</span><span class="n">artistPredicate</span><span class="p">];</span>
    <span class="p">[</span><span class="n">query</span> <span class="nf">addFilterPredicate</span><span class="p">:</span><span class="n">albumPredicate</span><span class="p">];</span>
    <span class="p">[</span><span class="n">query</span> <span class="nf">addFilterPredicate</span><span class="p">:</span><span class="n">songPredicate</span><span class="p">];</span>
    
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">query</span> <span class="nf">items</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MPMediaItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">NSURL</span> <span class="o">*</span><span class="n">assetURL</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="nf">valueForProperty</span><span class="p">:</span><span class="n">MPMediaItemPropertyAssetURL</span><span class="p">];</span>
        <span class="n">AVAsset</span> <span class="o">*</span><span class="n">asset</span> <span class="o">=</span> <span class="p">[</span><span class="n">AVAsset</span> <span class="nf">assetWithURL</span><span class="p">:</span><span class="n">assetURL</span><span class="p">];</span>
        <span class="c1">// Asset 信息</span>
    <span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">MediaPlayer</code>framework提供了一个为<code class="language-plaintext highlighter-rouge">MPMediaPropertyPredicate</code>的类,用户帮助用户在iPod库中查找到具体内容所用的查询语句 上边举例一个例子: 在<code class="language-plaintext highlighter-rouge">刘德华</code>的<code class="language-plaintext highlighter-rouge">真永远</code>(真永远专辑) 唱片中查找<code class="language-plaintext highlighter-rouge">爱你一万年</code>这首歌, 执行完查询 会返回这个媒体 条目的资源URL属性(<code class="language-plaintext highlighter-rouge">MPMediaItemPropertyAssetURL</code>). 并使用这个属性创建<code class="language-plaintext highlighter-rouge">AVAsset</code></p><h5 id="macos-itunes库">macOS iTunes库</h5><p>在 macOS(以前叫 OS X)上, iTunes是用户的媒体资源中心. 要识别这个库中的资源, 我们通常要对iTunes音乐目录中的iTunes Music Library.xml 文件进行解析, 从而得到相关数据. 不过在 Mac OS X 10.8山狮之后 有了比较简单的方法–<code class="language-plaintext highlighter-rouge">iTunesLibrary</code>framework.</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">ITLibrary</span> <span class="o">*</span><span class="n">library</span> <span class="o">=</span> <span class="p">[</span><span class="n">ITLibrary</span> <span class="nf">libraryWithAPIVersion</span><span class="p">:</span><span class="s">@"1.0"</span> <span class="nf">error</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">items</span> <span class="o">=</span> <span class="n">library</span><span class="p">.</span><span class="n">allMediaItems</span><span class="p">;</span>
    
    <span class="n">NSString</span> <span class="o">*</span><span class="n">query</span> <span class="o">=</span> <span class="s">@"artist.name == '刘德华'"</span>
                      <span class="s">"album.title == '真永远'"</span>
                      <span class="s">"title == '爱你一万年'"</span><span class="p">;</span>
    <span class="n">NSPredicate</span> <span class="o">*</span><span class="n">predicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPredicate</span> <span class="nf">predicateWithFormat</span><span class="p">:</span><span class="n">query</span><span class="p">];</span>
    
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">songs</span> <span class="o">=</span> <span class="p">[</span><span class="n">items</span> <span class="nf">filteredArrayUsingPredicate</span><span class="p">:</span><span class="n">predicate</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">songs</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ITLibMediaItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">songs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">AVAsset</span> <span class="o">*</span><span class="n">asset</span> <span class="o">=</span> <span class="p">[</span><span class="n">AVAsset</span> <span class="nf">assetWithURL</span><span class="p">:</span><span class="n">item</span><span class="p">.</span><span class="n">location</span><span class="p">];</span>
        <span class="c1">// asset info</span>
    <span class="p">}</span>
    
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">iTunesLibrary</code>框架并没有像MediaPlayer框架那样给出具体的查询API. 不过开发者可使用标准的Cocoa NSPredicate(谓词)类来构建一个复杂的查询,当筛出需要的media item集合后，可使用<code class="language-plaintext highlighter-rouge">ITLibMediaItem</code>的<code class="language-plaintext highlighter-rouge">location</code>属性得到一个URL并创建<code class="language-plaintext highlighter-rouge">AVAsset</code>.</p><h4 id="异步载入-1">异步载入</h4><p><code class="language-plaintext highlighter-rouge">AVAsset</code>具有多种有用的方法和属性, 可以提供有关资源的信息, 比如时长、创建日期、元数据等. <code class="language-plaintext highlighter-rouge">AVAsset</code>还包含一些用于获取和使用曲目集合的方法. 不过有一点很重要, 就是当创建时资源就是对基础文件的处理, <code class="language-plaintext highlighter-rouge">AVAsset</code> 采用一种lazy load的加载方式, 提升了快速创建资源和立即载入的速度. __<em>注意<code class="language-plaintext highlighter-rouge">AVAsset</code>的属性访问是同步的,如果正在请求的属性没有预先载入,程序就会阻塞,直到它做出响应为止</em>__这个搞法不是很好,eg: avasset.duration 可能是个比较耗时的操作,如果使用MP3文件时没有在头文件中设置<code class="language-plaintext highlighter-rouge">TLEN</code>标签,这个标签用于定义duration值,则整个音频曲目都需要进行解析来准确的知道它的duration, 如果在主线程做这样的访问操作就会阻塞主线程,直到相关操作完成为止, APP可能会出现卡顿,导致系统监视器介入,并终止APP运行,如果解决这种问题,我们应该使用异步的 方式来查询资源属性.</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">-</span> <span class="p">(</span><span class="n">AVKeyValueStatus</span><span class="p">)</span><span class="nf">statusOfValueForKey</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span> <span class="nf">error</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="o">*</span><span class="p">)</span><span class="nv">outError</span><span class="p">;</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">loadValuesAsynchronouslyForKeys</span><span class="p">:(</span><span class="n">NSArray</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nv">keys</span> <span class="nf">completionHandler</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">handler</span><span class="p">;</span>

</pre></table></code></div></div><p>可以使用statusOfValueForKey:error:方法查询一个给定的属性状态,返回一个<code class="language-plaintext highlighter-rouge">AVKeyValueStatus</code>的枚举值</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">enum</span> <span class="n">AVKeyValueStatus</span> <span class="o">:</span> <span class="n">NSInteger</span> <span class="p">{</span>
    <span class="n">AVKeyValueStatusUnknown</span><span class="p">,</span>
    <span class="n">AVKeyValueStatusLoading</span><span class="p">,</span>
    <span class="n">AVKeyValueStatusLoaded</span><span class="p">,</span>
    <span class="n">AVKeyValueStatusFailed</span><span class="p">,</span>
    <span class="n">AVKeyValueStatusCancelled</span>
<span class="p">}</span> <span class="n">AVKeyValueStatus</span><span class="p">;</span>
</pre></table></code></div></div><p>用于表示当前所请求的属性的状态, 如果状态不是<code class="language-plaintext highlighter-rouge">AVKeyValueStatusLoaded</code>说明此时这个属性可能导致程序卡顿,要异步载入一个给定的属性loadValuesAsynchronouslyForKeys:completionHandler:方法,参数keys 是一个或多个<code class="language-plaintext highlighter-rouge">资源属性名</code>的数组和一个callback,当资源处于回应状态时,就会调用这个<code class="language-plaintext highlighter-rouge">completionHandler</code></p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre>	<span class="n">NSURL</span> <span class="o">*</span><span class="n">assetURL</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="nf">mainBundle</span><span class="p">]</span> <span class="nf">URLForResource</span><span class="p">:</span><span class="s">@"384551_1438267683"</span> <span class="nf">withExtension</span><span class="p">:</span><span class="s">@"mov"</span><span class="p">];</span>
    <span class="n">AVAsset</span> <span class="o">*</span><span class="n">asset</span> <span class="o">=</span> <span class="p">[</span><span class="n">AVAsset</span> <span class="nf">assetWithURL</span><span class="p">:</span><span class="n">assetURL</span><span class="p">];</span>
    <span class="c1">//异步加在 tracks property</span>
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">keys</span> <span class="o">=</span> <span class="p">@[</span><span class="s">@"tracks"</span><span class="p">];</span>
    <span class="p">[</span><span class="n">asset</span> <span class="nf">loadValuesAsynchronouslyForKeys</span><span class="p">:</span><span class="n">keys</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="c1">//查询tracks的属性状态</span>
        <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="n">AVKeyValueStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="p">[</span><span class="n">asset</span> <span class="nf">statusOfValueForKey</span><span class="p">:</span><span class="s">@"tracks"</span> <span class="nf">error</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">AVKeyValueStatusLoaded</span><span class="p">:</span>
                <span class="c1">//继续处理后续逻辑</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">AVKeyValueStatusFailed</span><span class="p">:</span>
                <span class="c1">//有error</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">AVKeyValueStatusCancelled</span><span class="p">:</span>
                <span class="c1">// 处理意外取消等情况的逻辑</span>
                <span class="k">break</span><span class="p">;</span>
            
            <span class="nl">default:</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}];</span>

</pre></table></code></div></div><p>这里用bundle中的<code class="language-plaintext highlighter-rouge">QuickTime</code>电影创建一个AVAsset, 并异步载入该对象的<code class="language-plaintext highlighter-rouge">tracks</code>属性.在<code class="language-plaintext highlighter-rouge">completionHandler</code> block中,我们希望通过调用资源的statusOfValueForKey:error:方法来拿出请求属性的状态,NSError用于判断资源包含错误信息. <em>*注意:<code class="language-plaintext highlighter-rouge">completionHandler:</code>block可能在任意一个队列中调用,在对UI界面做出相应更新之前,必须先回到主线程队列,否则必被坑！！！*</em></p><blockquote><p><em>*注意:上面的demo载入了一个tracks属性,其实可以在一个吊用中请求多个属性,如果请求多个属性的时候需要注意以下两点:*</em> (1) 每次调用 <code class="language-plaintext highlighter-rouge">loadValuesAsynchronouslyForKeys:completionHandler:</code>方法时只会调用一次<code class="language-plaintext highlighter-rouge">completionHandler</code>block, 调用这个callback的次数不是根据传递给这个方法的key个数决定的. (2) 需要为每个请求的属性调用<code class="language-plaintext highlighter-rouge">statusOfValueForKey:error:</code>,不能假设所有属性都返回相同的状态值.</p></blockquote><h3 id="媒体元数据-1"><strong>媒体元数据</strong></h3><p>当创建一个媒体应用程序时,了解该媒体的组织格式非常重要, 简单的展示一堆文件名也许在文件不多的时候还能接受, 如果大规模批量的文件需要展示就比较蛋疼了, 我们真正需要的是 <em>找到一种方法对媒体进行描述,当用户可以方便的找到、识别和组织这些媒体.</em> 我们所使用的<code class="language-plaintext highlighter-rouge">AV Foundation</code>中的主要媒体格式(<em>.mp4、</em>.mp3、<em>.mov、</em>.mkv…..)都可以嵌入描述其内容的元数据.因为各种媒体格式的描述不尽相同,要搞一套通用的策略去解析各种媒体的格式文件,这要求我们对底层技术有一些了解.不过<code class="language-plaintext highlighter-rouge">AV Foundation</code>让这些变得简单,因为它使开发者不需要考虑大多数特定格式的细节; 在处理媒体元数据方面, AV Foundation`提供了一套统一的方法.</p><h4 id="元数据格式">元数据格式</h4><p>虽然存在多种格式的媒体资源,但是我们在Apple环境下遇到的媒体类型主要有4种, 分别是:<code class="language-plaintext highlighter-rouge">QuickTime(mov)</code>、<code class="language-plaintext highlighter-rouge">MPEG-4 video(mp4和m4v)</code>、<code class="language-plaintext highlighter-rouge">MPEG-4 audio(m4a)</code>和<code class="language-plaintext highlighter-rouge">MPEG-Layer Ⅲ audio(mp3)</code>. 虽然<code class="language-plaintext highlighter-rouge">AV Foundation</code>处理这些文件中嵌入的元数据时都使用一个接口, 但是理解这些不同类型资源的元数据如何存储及存储位置仍然很有价值. 这里只做概述, 但是如果深入研究这些都是必学的基础.</p><ol><li><p><strong>QuickTime</strong> <code class="language-plaintext highlighter-rouge">QuickTime</code>是苹果自己开发的一种跨平台媒体架构, 其中一部分是Quick File Format规范, 定义了 .mov文件的内部结构.<code class="language-plaintext highlighter-rouge">QuickTime</code>文件由一种称为<code class="language-plaintext highlighter-rouge">atom</code>的数据结构组成. 一般规则是这样的: 一个<code class="language-plaintext highlighter-rouge">atom</code>包含了描述媒体资源的某一方面的数据, 或者嵌套包含其它<code class="language-plaintext highlighter-rouge">atom</code>,但不能两者都包含.有时候苹果自己的方法实现可能会违背这一规则.<code class="language-plaintext highlighter-rouge">atom</code>以一种复杂的树状结构组合在一起, 详细的对布局、音频样本格式、视频帧信息乃至需要呈现的元数据信息(作者,版权等)做了描述.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/atom.webp" alt="" /> <em>为了能记住<code class="language-plaintext highlighter-rouge">atom</code>我把它戏称为<code class="language-plaintext highlighter-rouge">阿童木</code>哈哈-跟阿童木压根没啥关系</em>.</p><p>了解<code class="language-plaintext highlighter-rouge">QuickTime</code>的一个好办法是用十六进制编辑器中打开一个.mov格式的文件.(常见的十六进制编辑器有Hex Fiend或Synalyze It! Pro).典型的十六进制工具会将一个真实的<code class="language-plaintext highlighter-rouge">QuickTime</code>文件的数据显示出来,但其中的结构和<code class="language-plaintext highlighter-rouge">atom</code>间的关系不是很直观能理解,推荐苹果有一个<code class="language-plaintext highlighter-rouge">Atom Inspector</code>工具.这个工具将atom结构以<code class="language-plaintext highlighter-rouge">NSOutlineView</code>(树形UI控件类似UITableView)方式显示.所以<code class="language-plaintext highlighter-rouge">atom</code>的树形瓜西会很清晰的看到,这个工具还提供一个小型的十六进制查看器,可以从中查看到__实际字节布局__.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/AtomInspector.webp" alt="" /></p><p>下载地址:<a href="http://adcdownload.apple.com/QuickTime/atom_inspector/atom_inspector.dmg">Atom Inspector 猛击这里</a> 貌似需要登录开发者帐号 下载中心:<a href="https://developer.apple.com/download/more/">苹果官方软件下载中心</a> 貌似需要登录开发者帐号</p><p>下图就是atom格式 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/QuickTimeAtomStructureNew.webp" alt="" /></p><p><em>atom格式</em></p><p><strong><code class="language-plaintext highlighter-rouge">QuickTime</code>文件最少包含三个高级的<code class="language-plaintext highlighter-rouge">atom</code></strong></p><ul><li><strong>用于描述文件类型和兼容类型的<code class="language-plaintext highlighter-rouge">fypy</code></strong><li><strong>包含实际音频和视频媒体的<code class="language-plaintext highlighter-rouge">mdat</code></strong><li><strong>moov atom(moo-vee) 媒体资源的所有细节做了完整描述包括原始的二进制数据</strong></ul><p>下图是我实际测试一个mov文件的atom <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/QuickTimeAtomStructureReal.webp" alt="" /> <em>实测</em></p><p>当处理QuickTime电影时会遇到两种类型的元数据. 标准的<code class="language-plaintext highlighter-rouge">QuickTime</code>元数据由<code class="language-plaintext highlighter-rouge">Final Cut Pro X</code>这样的工具编写, 位于/moov/meta/plist中, 它的key几乎都具有com.apple.quicktime前缀. 其它类型的数据被认为是<code class="language-plaintext highlighter-rouge">QuickTime</code>用户数据, 保存在/moov/udta/中.<code class="language-plaintext highlighter-rouge">QuickTime</code>用户数据可以包含播放器需要查找的标准数据,eg: 歌曲的演唱者或版权信息, 除此之外还可以包含任何对应用程序有帮助的信息. 上述两种元数据类型在 <code class="language-plaintext highlighter-rouge">AV Foundation</code>中都是可以读写的.<br /> 如果想了解更多<code class="language-plaintext highlighter-rouge">QuickTime</code>细节可以查看<a href="https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFPreface/qtffPreface.html">Quick Time Format Specification</a>官方文档(400多页).<br /> 掌握moov atom的核心知识很重要,有助于我们更好的了解<code class="language-plaintext highlighter-rouge">AV Foundation</code>是如何使用这些数据的.</p><li><p><strong>MPEG-4 (MP4)音频和视频</strong></p><p>MPEG-4 Part 14是定义MP4文件格式的规范. <code class="language-plaintext highlighter-rouge">MP4</code>直接派生自<code class="language-plaintext highlighter-rouge">QuickTime</code>文件格式,所以<code class="language-plaintext highlighter-rouge">MP4</code>文件格式与<code class="language-plaintext highlighter-rouge">QuickTime</code>文件结构很类似. 其实有时候能解析一种文件类型的工具也适用于其它文件类型.<code class="language-plaintext highlighter-rouge">MP4</code>文件也由成为<code class="language-plaintext highlighter-rouge">atom</code>的数据结构组成.技术上讲,<code class="language-plaintext highlighter-rouge">MPEG-4</code>规范将这些称为<code class="language-plaintext highlighter-rouge">boxes</code>,因为其大部分来自于<code class="language-plaintext highlighter-rouge">QuickTime</code>所以大家都还是把它成为<code class="language-plaintext highlighter-rouge">atom</code>.<br /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/mp4AtomBook.webp" alt="" /> <em>MPEG-4 atom结构</em></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/mp4Atom.webp" alt="" /> <em>MPEG-4 atom结构 实测结果</em></p><p><code class="language-plaintext highlighter-rouge">MPEG-4</code>文件的元数据保存在<code class="language-plaintext highlighter-rouge">/moov/udat/meta/ilst</code>中. 对于<code class="language-plaintext highlighter-rouge">atom</code>中使用key没有标准, 大家都墨守成规的遵循苹果尚未发布的iTunes元数据规范中对key的定义. 虽然没有正式的发布,但iTunes元数据格式的相关文档已经在网上广为人知了(我就很纳闷 这算是发了版本还是没发,发了怎么还是尚未公布,没发怎么又广为人知…). 可以参考<a href="https://code.google.com/archive/p/mp4v2/wikis/iTunesMetadata.wiki">mp4v2库</a>文档了解更多mp4内容.</p><p><code class="language-plaintext highlighter-rouge">mp4</code>是对MPEG-4媒体的标准扩展.eg: <code class="language-plaintext highlighter-rouge">.m4v</code>、<code class="language-plaintext highlighter-rouge">.m4a</code>、<code class="language-plaintext highlighter-rouge">.m4p</code>、<code class="language-plaintext highlighter-rouge">.m4b</code>.这些变体使用的都是<code class="language-plaintext highlighter-rouge">MPEG-4</code>容器格式,也有些包含了附加的扩展功能.<br /> 大家只需要记住几点:</p><ul><li><strong><code class="language-plaintext highlighter-rouge">M4V</code></strong> 文件是带有苹果公司针对__<code class="language-plaintext highlighter-rouge">FairPlay</code><strong>加密及</strong><code class="language-plaintext highlighter-rouge">AC3-audio</code>__扩展的<code class="language-plaintext highlighter-rouge">MPEG-4</code>视频格式<li><strong><code class="language-plaintext highlighter-rouge">MP4</code></strong> 如果不涉及<code class="language-plaintext highlighter-rouge">FairPlay</code>加密及<code class="language-plaintext highlighter-rouge">AC3-audio</code>扩展,<code class="language-plaintext highlighter-rouge">M4V</code>就仅仅是扩展名不一样而已<li><strong><code class="language-plaintext highlighter-rouge">M4A</code></strong> 专门针对音频,使用这种扩展名的目的是让大家知道这种格式的文件只带有音频资源<li><strong><code class="language-plaintext highlighter-rouge">M4P</code></strong> 苹果很古老的iTunes格式,使用其<code class="language-plaintext highlighter-rouge">FairPlay</code>扩展<li><strong><code class="language-plaintext highlighter-rouge">M4B</code></strong> 用于有声读物,同窗包含章节标签以及提供书签功能,让读者可以返回到指定位置开始阅读(类似有声小说)</ul><li><p><strong>MP3</strong></p><p><code class="language-plaintext highlighter-rouge">MP3</code>文件和<code class="language-plaintext highlighter-rouge">MPEG-4 (.mp4)</code>、<code class="language-plaintext highlighter-rouge">QuickTime(.mov)</code>有显著区别,<code class="language-plaintext highlighter-rouge">MP3</code>不使用容器格式,而使用__编码音频数据__,文件开头通常包含可选元数据的结构块.<code class="language-plaintext highlighter-rouge">mp3</code>文件使用一种称为ID3v2的格式来保存关于音频内容的描述信息,包含: artist(艺术家)、演唱者、album(所属专辑)、音乐风格等.<br /> <code class="language-plaintext highlighter-rouge">ID3</code>数据很easy,<code class="language-plaintext highlighter-rouge">mp3</code>前10个字节带有嵌入的元数据, 这10个字节定义了<code class="language-plaintext highlighter-rouge">ID3</code>块的头部.10个字节中的前三个字节始终为’49 44 33’(ID3,用于表示一个<code class="language-plaintext highlighter-rouge">ID3v2标签</code>,后面两个字姐用于定义主版本信息,既<code class="language-plaintext highlighter-rouge">2、3、4</code>和版本号.剩余字节用于定义标志集合及ID3快的大小. <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/ID3Header.webp" alt="" /> <em>ID3 header</em></p><p><code class="language-plaintext highlighter-rouge">ID3</code>块中剩下的数据都是用于描述不同元数据的的key-value键值对的帧.每一帧都有一个__实际标签名称的10字节的头__,之后的4字节表示尺寸,再之后的两个字节用来定义选项标志.</p><div class="table-wrapper"><table><tbody><tr><td>id3<td>version(2字节)<td>revision (剩余字节)<td>flag(2字节)<td>size(4字节)</table></div><p>帧剩下的字节包含了实际的元数据值.如果值是文本类型tag中的第一个字节包含了实际的元数据值.如果值是文本类型,tag中的第一个字节用来定义编码类型. eg:Ox00, 代表:<code class="language-plaintext highlighter-rouge">ISO-8859=1</code>,也支持其它类型的编码。如下图ID3结构示意图. <strong><code class="language-plaintext highlighter-rouge">AV Foundation</code>支持读取<code class="language-plaintext highlighter-rouge">ID3v2</code>标签的的所有版本, 但不支持写入.MP3格式收到专利限制.所以<code class="language-plaintext highlighter-rouge">AV Foundation</code>无法支持对MP3或ID3数据进行编码.</strong> 不过最近听说德国的MP3专利研究所说专利打算撤销因为<code class="language-plaintext highlighter-rouge">AAC</code>格式将有更好的效果相对于MP3而言.看看后续苹果API变动会不会增加修改MP3的数据吧.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/ID3Structure.webp" alt="" /> <em>ID3v2 结构图</em></p></ol><blockquote><p><code class="language-plaintext highlighter-rouge">AV Foundation</code>支持所有<code class="language-plaintext highlighter-rouge">ID3v2</code>标签格式的读取操作,但是<code class="language-plaintext highlighter-rouge">ID3v2</code>是要加星号的.<code class="language-plaintext highlighter-rouge">ID3v2.2</code>的布局和<code class="language-plaintext highlighter-rouge">ID3v2.3</code>及之后版本的布局不同. 需要注意:有些标签由3个字符组成,而不是4个字符, 比如一首歌曲的标注信息, 当标签为<code class="language-plaintext highlighter-rouge">ID3v2.2</code>时,是被保存到COM帧中,但当同一首歌使用<code class="language-plaintext highlighter-rouge">ID3v2.3</code>标签或更新版本的标签时,歌曲的标注信息会被保存在COMM帧中,框架定义的字符常量只适用于<code class="language-plaintext highlighter-rouge">ID3v2.3</code>及以后版本,后续demo中我们通过代码演示如何向前兼容<code class="language-plaintext highlighter-rouge">ID3v2.2</code>.</p></blockquote><h3 id="使用元数据-1"><strong>使用元数据</strong></h3><p><code class="language-plaintext highlighter-rouge">AVAsset</code>和<code class="language-plaintext highlighter-rouge">AVAssetTrack</code>可以实现查询元数据功能</p><ul><li><code class="language-plaintext highlighter-rouge">AVAsset</code> 大部分情况下会使用<li><code class="language-plaintext highlighter-rouge">AVAssetTrack</code> 获取曲目一级元数据</ul><p>读取具体资源元数据的接口可以使用<code class="language-plaintext highlighter-rouge">AVMetadataItem</code>类提供的方法访问<code class="language-plaintext highlighter-rouge">QuickTime</code>、<code class="language-plaintext highlighter-rouge">MPEG-4 atom</code>和<code class="language-plaintext highlighter-rouge">ID3</code>帧中的元数据进行访问. <code class="language-plaintext highlighter-rouge">AVAsset</code>和<code class="language-plaintext highlighter-rouge">AVAssetTrack</code>提供了两种方法可以获取相关元数据.但是有各自的适用范围.了解适用范围之前首先要知道 <strong>键空间</strong>(key space)的含义. <code class="language-plaintext highlighter-rouge">AV Foundation</code>使用__键空间(key space)__作为将相关键组合在一起的方法, 可以实现对<code class="language-plaintext highlighter-rouge">AVMetadataItem</code>实例集合的筛选.每个资源至少包含两个键空间,以便从中获取元数据. <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/images/20170616LearningAVFoundationAVAssetBasic/keyspace.webp" alt="" /></p><p><code class="language-plaintext highlighter-rouge">Common</code>键空间用来定义所有支持媒体类型的键, 包括: 曲名、歌手、插图信息等常见元素. 这提供了一种对所有支持的媒体格式进行一定级别的元数据标准化过程.我们可以从<code class="language-plaintext highlighter-rouge">Common</code>键空间查询 资源或者曲目的<code class="language-plaintext highlighter-rouge">commonMetadata</code>属性来获取元数据 这个属性会返回一个包含所有可用元数据的数组</p><p>访问指定格式的元数据需要在资源或曲目上调用<code class="language-plaintext highlighter-rouge">metadataForFormat:</code>方法.这个方法返回一个包含所有相关元数据信息的数组.<code class="language-plaintext highlighter-rouge">AVMetadataFormat.h</code>为不同的元数据格式提供对应的字符串常量. 由于不同格式的元数据导致key value对应类型不一致,我们可以利用 <code class="language-plaintext highlighter-rouge">availableMetadataFormats</code>(AVAsset的属性)获取到信息.如下代码:</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>
	<span class="n">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nf">fileURLWithPath</span><span class="p">:</span><span class="s">@"xxx.mp4"</span><span class="p">];</span><span class="c1">//给个路径地址</span>
    <span class="c1">//创建元数据</span>
    <span class="n">AVAset</span> <span class="o">*</span><span class="n">asset</span> <span class="o">=</span> <span class="p">[</span><span class="n">AVAsset</span> <span class="nf">assetWithURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">keys</span> <span class="o">=</span> <span class="p">@[</span><span class="s">@"availableMetadataFormats"</span><span class="p">];</span>
    <span class="p">[</span><span class="n">asset</span> <span class="nf">loadValuesAsynchronouslyForKeys</span><span class="p">:</span><span class="n">keys</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nf">array</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">format</span> <span class="k">in</span> <span class="n">asset</span><span class="p">.</span><span class="n">availableMetadataFormats</span><span class="p">){</span>
            <span class="p">[</span><span class="n">metadata</span> <span class="nf">addObjectsFromArray</span><span class="p">:[</span><span class="n">asset</span> <span class="nf">metadataForFormat</span><span class="p">:</span><span class="n">format</span><span class="p">]];</span>
        <span class="p">}</span>
        
        <span class="c1">//处理metadata (AVMetadataItems)</span>
    <span class="p">}];</span>


</pre></table></code></div></div><h3 id="查找元数据"><strong>查找元数据</strong></h3><p>当我们拿到一个包含元数据项的数组(上文中的metadata (AVMetadataItems))时,我们通常通过遍历取出里面的数据值. 元数据(AVAsset)提供一个AVMetadataItem的遍历方法, 例如我们相得到一个M4A的音频文件演奏者和唱片的元数据. 如下:</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>
	<span class="n">NSArray</span> <span class="o">*</span><span class="n">metaData</span> <span class="o">=</span> <span class="c1">//AVMetadataItems数组</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">keySpace</span> <span class="o">=</span> <span class="n">AVMetadataKeySpaceiTunes</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">artistKey</span><span class="o">=</span> <span class="n">AVMetadataiTunesMetadataKeyArtist</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">albumKey</span> <span class="o">=</span> <span class="n">AVMetadataiTunesMetadataKeyAlbum</span><span class="p">;</span>
    
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">artistMetadata</span> <span class="o">=</span> <span class="p">[</span><span class="n">AVMetadataItem</span> <span class="nf">metadataItemsFromArray</span><span class="p">:</span><span class="n">metaData</span> <span class="nf">withKey</span><span class="p">:</span><span class="n">artistKey</span> <span class="n">keySpace</span><span class="o">:</span><span class="n">keySpace</span><span class="p">];</span>
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">albumMetadata</span> <span class="o">=</span> <span class="p">[</span><span class="n">AVMetadataItem</span>  <span class="nf">metadataItemsFromArray</span><span class="p">:</span><span class="n">metaData</span> <span class="nf">withKey</span><span class="p">:</span><span class="n">albumKey</span> <span class="n">keySpace</span><span class="o">:</span><span class="n">keySpace</span><span class="p">];</span>
    
    <span class="n">AVMetadataItem</span> <span class="o">*</span><span class="n">artistItem</span><span class="p">,</span> <span class="o">*</span><span class="n">albumItem</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">artistMetadata</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">artistItem</span> <span class="o">=</span> <span class="n">artistMetadata</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">albumMetadata</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">albumItem</span> <span class="o">=</span> <span class="n">albumMetadata</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

</pre></table></code></div></div><p>这里通过下面的方法来拿出匹配key 和 keySpace的标准对象 通常情况下这个数组就只有一个实例对象</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">+</span> <span class="p">(</span><span class="n">NSArray</span><span class="o">&lt;</span><span class="n">AVMetadataItem</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nf">metadataItemsFromArray</span><span class="p">:(</span><span class="n">NSArray</span><span class="o">&lt;</span><span class="n">AVMetadataItem</span> <span class="o">*&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nv">metadataItems</span> <span class="nf">withKey</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">key</span> <span class="nf">keySpace</span><span class="p">:(</span><span class="n">AVMetadataKeySpace</span><span class="p">)</span><span class="nv">keySpace</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="使用avmetadataitem">使用AVMetadataItem</h3><p>AVMetadataItem 可以理解成它是一个 专用于元数据的 字典(key: value) 类型, 唯一的区别是 它的key 有可能是 数字(NSNumber), 它提供了 转 字符串(stringValue) 和numberValue以及 dataValue 的转换</p><p>举个例子： 如果输出的key是 145238391 …. 我觉得大家肯定不知道这代表啥意思</p><p>为了解决这个问题 需要对<code class="language-plaintext highlighter-rouge">AVMetadataItem</code>进行category扩展 把这种语义不清楚的整形key换成字符串的key就好理解了 代码如下:</p><div class="language-objc highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="cp">#import "AVMetadataItem+Additions.h"
</span>
<span class="k">@implementation</span> <span class="nc">AVMetadataItem</span> <span class="p">(</span><span class="nl">Additions</span><span class="p">)</span>

<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">keyString</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">key</span> <span class="nf">isKindOfClass</span><span class="p">:[</span><span class="n">NSString</span> <span class="nf">class</span><span class="p">]])</span> <span class="p">{</span>                        <span class="c1">// 1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">key</span> <span class="nf">isKindOfClass</span><span class="p">:[</span><span class="n">NSNumber</span> <span class="nf">class</span><span class="p">]])</span> <span class="p">{</span>

        <span class="n">UInt32</span> <span class="n">keyValue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="p">)</span> <span class="n">self</span><span class="p">.</span><span class="n">key</span> <span class="nf">unsignedIntValue</span><span class="p">];</span>         <span class="c1">// 2</span>
        
        <span class="c1">// Most, but not all, keys are 4 characters ID3v2.2 keys are</span>
        <span class="c1">// only be 3 characters long.  Adjust the length if necessary.</span>
        
        <span class="kt">size_t</span> <span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UInt32</span><span class="p">);</span>                                     <span class="c1">// 3</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">keyValue</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">--</span><span class="n">length</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">keyValue</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">--</span><span class="n">length</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">keyValue</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">--</span><span class="n">length</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">keyValue</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">--</span><span class="n">length</span><span class="p">;</span>
        
        <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">keyValue</span><span class="p">;</span>
        <span class="n">address</span> <span class="o">+=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">UInt32</span><span class="p">)</span> <span class="o">-</span> <span class="n">length</span><span class="p">);</span>

        <span class="c1">// keys are stored in big-endian format, swap</span>
        <span class="n">keyValue</span> <span class="o">=</span> <span class="n">CFSwapInt32BigToHost</span><span class="p">(</span><span class="n">keyValue</span><span class="p">);</span>                          <span class="c1">// 4</span>

        <span class="kt">char</span> <span class="n">cstring</span><span class="p">[</span><span class="nf">length</span><span class="p">];</span>                                               <span class="c1">// 5</span>
        <span class="n">strncpy</span><span class="p">(</span><span class="n">cstring</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">address</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
        <span class="n">cstring</span><span class="p">[</span><span class="nf">length</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

        <span class="c1">// Replace '©' with '@' to match constants in AVMetadataFormat.h</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cstring</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\xA9'</span><span class="p">)</span> <span class="p">{</span>                                         <span class="c1">// 6</span>
            <span class="n">cstring</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'@'</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithCString</span><span class="p">:(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">cstring</span>                 <span class="c1">// 7</span>
                                  <span class="nl">encoding:</span><span class="n">NSUTF8StringEncoding</span><span class="p">];</span>

    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">@"&lt;&lt;unknown&gt;&gt;"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">@end</span>

</pre></table></code></div></div><p>基础篇部分讲解到这里 下一篇 会写个demo演示一下元数据的各种不同格式如何统一解析</p><p>全文完</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/ios/'>iOS</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/ios/" class="post-tag no-text-decoration" >iOS</a> <a href="/tags/macos/" class="post-tag no-text-decoration" >macOS</a> <a href="/tags/objective-c/" class="post-tag no-text-decoration" >Objective-C</a> <a href="/tags/avfoundation/" class="post-tag no-text-decoration" >AVFoundation</a> <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" class="post-tag no-text-decoration" >音视频</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 该博客文章由作者通过 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a> 进行授权。</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Learning AV Foundation(四)AVAsset元数据(基础篇) - 迈腾大队长&url=https://www.sunyazhou.com/2017/06/LearningAVFoundationAVAssetBasic/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Learning AV Foundation(四)AVAsset元数据(基础篇) - 迈腾大队长&u=https://www.sunyazhou.com/2017/06/LearningAVFoundationAVAssetBasic/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Learning AV Foundation(四)AVAsset元数据(基础篇) - 迈腾大队长&url=https://www.sunyazhou.com/2017/06/LearningAVFoundationAVAssetBasic/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="http://service.weibo.com/share/share.php?title=Learning AV Foundation(四)AVAsset元数据(基础篇) - 迈腾大队长&url=https://www.sunyazhou.com/2017/06/LearningAVFoundationAVAssetBasic/" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/2023/03/podxcassets/">如何在pod中的podspec使用XCAssets</a><li><a href="/2023/03/circularsliderview/">使用SwiftUI绘制环形 Slider</a><li><a href="/2022/12/thesunyazhoutheoryii/">《The Sunyazhou Theory Ⅱ》的诞生</a><li><a href="/2022/12/gradientlayeranimation/">模仿Q音径向渐变动画</a><li><a href="/2022/11/swiftuipropertywrapper/">SwiftUI属性包装器:State、Binding、ObservableObject、EnvironmentObject</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/objective-c/">Objective C</a> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/macos/">macOS</a> <a class="post-tag" href="/tags/skills/">skills</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/swift/">Swift</a> <a class="post-tag" href="/tags/c++/">C++</a> <a class="post-tag" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a> <a class="post-tag" href="/tags/avfoundation/">AVFoundation</a> <a class="post-tag" href="/tags/%E5%8A%A8%E7%94%BB/">动画</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章目录</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>接下来阅读</h3><div class="card-deck mb-4"><div class="card"> <a href="/2019/04/AVRoutePickerView/"><div class="card-body"> <span class="timeago small" > 2019-04-17 <i class="unloaded">2019-04-17T23:19:52+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AVRoutePickerView</h3><div class="text-muted small"><p> 前言 最近无意中看了一下AVKit发现内部增加了很多新的内容.其中有个AVRoutePickerView的UI控件,打算研究一下. 其实这个很常见就在系统的控制中心 下拉屏幕就能看见 当你连接耳机或者无线蓝牙设备的时候. 这里网易云音乐中有实践的例子 这个控件主要用于AirPlay投屏 和音频的线路切换 那么我今天就跟大家一起学习一下这个新的控件 代码实现 导入#im...</p></div></div></a></div><div class="card"> <a href="/2022/04/CVPixelBufferRef/"><div class="card-body"> <span class="timeago small" > 2022-04-06 <i class="unloaded">2022-04-06T09:50:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>深入理解CVPixelBufferRef</h3><div class="text-muted small"><p> 在iOS里，我们经常能看到CVPixelBufferRef这个类型，在Camera采集返回的数据里得到一个CMSampleBufferRef,而每个CMSampleBufferRef里则包含一个CVPixelBufferRef,在视频硬解码的返回数据里也是一个CVPixelBufferRef。 顾名思义,CVPixelBufferRef是一种像素图片类型，由于CV开头，所以它是属于Co...</p></div></div></a></div><div class="card"> <a href="/2017/03/LearningAVFoundationAVSpeechSynthesizer/"><div class="card-body"> <span class="timeago small" > 2017-03-11 <i class="unloaded">2017-03-11T20:38:53+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Learning AV Foundation(一)汉字语音朗读</h3><div class="text-muted small"><p> 前言 最近在研究AV Foundation 框架 发现有一本书叫做 AV Foundation开发秘籍：实践掌握iOS &amp; OS X 应用的视听处理技术 然后google查了一下英文版叫 Learning AV Foundation: A Hands-on Guide to Mastering the AV Foundation Framework 看着国人的翻译不仅慨叹...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/2017/05/OpenGLglslLanguage/" class="btn btn-outline-primary"><p>OpenGL编程语言-glsl基础</p></a> <a href="/2017/06/XcodeDebugViaWireless/" class="btn btn-outline-primary"><p>Xcode9新功能 无线真机调试</p></a></div><div class="utterances-container"> <script src="https://utteranc.es/client.js" repo="sunyazhou13/gitment-comments" issue-term="pathname" theme="photon-dark" crossorigin="anonymous" async> </script></div><script type="text/javascript"> $(function() { window.onmessage = evt => { if (evt.origin === 'https://utteranc.es') { toggle.updateCommentStyle(); window.onmessage = null; } } }); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/sunyazhou13">sunyazhou13</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，否则本网站上的博客文章均由作者根据知识共享许可协议 - 署名标示 4.0（CC BY 4.0）进行授权许可。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本博客由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，使用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> 作为主题</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/objective-c/">Objective C</a> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/macos/">macOS</a> <a class="post-tag" href="/tags/skills/">skills</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/swift/">Swift</a> <a class="post-tag" href="/tags/c++/">C++</a> <a class="post-tag" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/">音视频</a> <a class="post-tag" href="/tags/avfoundation/">AVFoundation</a> <a class="post-tag" href="/tags/%E5%8A%A8%E7%94%BB/">动画</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sunyazhou.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
