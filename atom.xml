<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>東引甌越</title>
  <subtitle>不断学习, 与时俱进.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sunyazhou.com/"/>
  <updated>2018-09-20T02:13:00.934Z</updated>
  <id>https://www.sunyazhou.com/</id>
  
  <author>
    <name>sunyazhou</name>
    <email>sunyazhou13@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS扩大UIButton的点击的响应范围</title>
    <link href="https://www.sunyazhou.com/2018/09/20/20180920IncreasingTapAreaOfButton/"/>
    <id>https://www.sunyazhou.com/2018/09/20/20180920IncreasingTapAreaOfButton/</id>
    <published>2018-09-20T01:40:06.000Z</published>
    <updated>2018-09-20T02:13:00.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开发过程中经常遇到<code>UIButton</code>点击区域太小 又不想 改动按钮的大小.</p>
<p>今天的文章和大家分享一下解决这种问题的代码</p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><ul>
<li>子类话UIButton 复写 它的<code>hitTest:</code>方法</li>
<li>子类话UIButton 复写 point:inside:withEvent: 方法</li>
</ul>
<h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">hitTest</span><span class="params">(<span class="number">_</span> point: CGPoint, with event: UIEvent?)</span></span> -&gt; <span class="type">UIView</span>? &#123;</div><div class="line">	<span class="keyword">let</span> biggerButtonFrame = theButton.frame.insetBy(dx: -<span class="number">30</span>, dy: -<span class="number">30</span>) <span class="comment">// 1	</span></div><div class="line">	<span class="keyword">if</span> biggerButtonFrame.<span class="built_in">contains</span>(point) &#123; <span class="comment">// 2</span></div><div class="line">		<span class="keyword">return</span> theButton <span class="comment">// 3</span></div><div class="line">	&#125;		</div><div class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.hitTest(point, with: event) <span class="comment">// 4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>让theButton的 x 扩大 30, y 扩大 30 (正数为缩小 负数为放大. 然后宽高 分别是2 <em> 30和 2 </em> 30)</li>
</ol>
</li>
<li><ol>
<li>判断点击的位置是否在放大完的frame内.</li>
</ol>
</li>
<li><ol>
<li>如果是 就返回button</li>
</ol>
</li>
<li><ol>
<li>不是的话让事件继续传递</li>
</ol>
</li>
</ul>
<blockquote>
<p>注意:<em>这里没判断 theButton.alpha == 0 和 theButton.userInterface.. ==  YES 还有它是否可见之类的,请自行判断</em></p>
</blockquote>
<h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p>复写UIView的point:方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">point</span><span class="params">(inside point: CGPoint, with event: UIEvent?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">	<span class="keyword">let</span> biggerFrame = bounds.insetBy(dx: -<span class="number">30</span>, dy: -<span class="number">30</span>)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> biggerFrame.<span class="built_in">contains</span>(point)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OC的版本是这样</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">	<span class="comment">//这里写上 </span></div><div class="line">	</div><div class="line">	<span class="built_in">CGRectInset</span>(&lt;<span class="meta">#CGRect rect#&gt;, <span class="meta-string">&lt;#CGFloat dx#&gt;</span>, <span class="meta-string">&lt;#CGFloat dy#&gt;</span>)</span></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是 第二种方式 其实 是 hitTest:方法调用之前UIView的判断,它判断当前点击的point是否在这个UIView上.</p>
<p>不过 还是推荐第一种方式</p>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p>其实 最核心的代码是</p>
<p>CGRectInset(&lt;#CGRect rect#&gt;, &lt;#CGFloat dx#&gt;, &lt;#CGFloat dy#&gt;)</p>
<blockquote>
<p>CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)是以rect为中心，根据dx和dy来实现缩小。</p>
</blockquote>
<p>如果dx 和 dy是负数 则放大 ,正数则缩小</p>
<p>但是大家可能很疑惑 那宽度和高度怎么 缩小放大</p>
<p>首先: 我们明确 这个API的含义 只要传入正数 它就缩放 那么 宽高也会适当前传入的dx和dy来决定 缩放比</p>
<p>因为是中心点缩放 所以宽高 <strong>要 X 2</strong>,因为有两侧嘛,左侧缩小30右侧也需要缩小30,上部和底部是一样的.</p>
<p>大家可自行查阅google看下</p>
<p><a href="https://rolandleth.com/increasing-the-tap-area-of-a-uibutton" target="_blank" rel="external">参考Increasing the tap area of a UIButton</a><br><a href="https://mp.weixin.qq.com/s/9rvSRt4kfpy7e87EJoaJOQ" target="_blank" rel="external">参考 iOS触摸事件全家桶</a></p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;开发过程中经常遇到&lt;code&gt;UIButton&lt;/code&gt;点击区域太小 又不想 改动按钮的大小.&lt;/p&gt;
&lt;p&gt;今天的文章和大家分享一下解
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS键盘动画细节</title>
    <link href="https://www.sunyazhou.com/2018/09/18/20180918KeyboardAnimation/"/>
    <id>https://www.sunyazhou.com/2018/09/18/20180918KeyboardAnimation/</id>
    <published>2018-09-18T01:49:58.000Z</published>
    <updated>2018-09-18T03:48:25.329Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/3c30ff9ede53ff83c4dd1d31ec6e75b27bb5d3f3/20180918KeyboardAnimation/keyboard1.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很久没写技术文章里,本篇记录了一下一个键盘弹出的小细节动画,像微信一样流程</p>
<p>上图</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/23780124887263a4f9a87f094f061bbd564129c3/20180918KeyboardAnimation/keyboardAnimation.gif" alt=""></p>
<h1 id="动画细节代码"><a href="#动画细节代码" class="headerlink" title="动画细节代码"></a>动画细节代码</h1><p>细节核心主要是通知中的一些key</p>
<ul>
<li>动画时长</li>
<li>动画的出现方式</li>
</ul>
<p>…</p>
<p>下面的通知是接收 键盘将要出现的通知<code>UIKeyboardWillShowNotification</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                             selector:<span class="keyword">@selector</span>(didReceiveKeyboardShowNotification:)</div><div class="line">                                                 name:<span class="built_in">UIKeyboardWillShowNotification</span></div><div class="line">                                               object:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>然后是实现的核心代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)didReceiveKeyboardShowNotification:(<span class="built_in">NSNotification</span> *)noti &#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *userInfo = noti.userInfo;</div><div class="line">    <span class="built_in">NSTimeInterval</span> animationDuration;</div><div class="line">    <span class="built_in">UIViewAnimationCurve</span> animationCurve;</div><div class="line">    <span class="built_in">CGRect</span> keyboardFrame;</div><div class="line">    [[userInfo objectForKey:<span class="built_in">UIKeyboardAnimationCurveUserInfoKey</span>] getValue:&amp;animationCurve];</div><div class="line">    [[userInfo objectForKey:<span class="built_in">UIKeyboardAnimationDurationUserInfoKey</span>] getValue:&amp;animationDuration];</div><div class="line">    [[userInfo objectForKey:<span class="built_in">UIKeyboardFrameEndUserInfoKey</span>] getValue:&amp;keyboardFrame];</div><div class="line">    </div><div class="line">    <span class="built_in">UIViewAnimationOptions</span> animationOptions = animationCurve &lt;&lt; <span class="number">16</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.bottomConstrains.offset = -<span class="built_in">CGRectGetHeight</span>(keyboardFrame);</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:animationDuration delay:<span class="number">0.</span> options:animationOptions animations:^&#123;</div><div class="line">        [<span class="keyword">self</span>.view setNeedsUpdateConstraints];</div><div class="line">        [<span class="keyword">self</span>.view layoutIfNeeded];</div><div class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>self.bottomConstrains.offset = -CGRectGetHeight(keyboardFrame); 是我写的约束 详细请参考demo</p>
</blockquote>
<p>键盘消失也是一样的 <code>UIKeyboardWillHideNotification</code> 接收这个key</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                             selector:<span class="keyword">@selector</span>(didReceiveKeyboardHideNotification:)</div><div class="line">                                                 name:<span class="built_in">UIKeyboardWillHideNotification</span></div><div class="line">                                               object:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>消失的时候 把约束偏移量设置<code>0</code>即可</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)didReceiveKeyboardHideNotification:(<span class="built_in">NSNotification</span> *)noti &#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *userInfo = noti.userInfo;</div><div class="line">    <span class="built_in">NSTimeInterval</span> animationDuration;</div><div class="line">    <span class="built_in">UIViewAnimationCurve</span> animationCurve;</div><div class="line">    <span class="built_in">CGRect</span> keyboardFrame;</div><div class="line">    [[userInfo objectForKey:<span class="built_in">UIKeyboardAnimationCurveUserInfoKey</span>] getValue:&amp;animationCurve];</div><div class="line">    [[userInfo objectForKey:<span class="built_in">UIKeyboardAnimationDurationUserInfoKey</span>] getValue:&amp;animationDuration];</div><div class="line">    [[userInfo objectForKey:<span class="built_in">UIKeyboardFrameEndUserInfoKey</span>] getValue:&amp;keyboardFrame];</div><div class="line">    </div><div class="line">    <span class="built_in">UIViewAnimationOptions</span> animationOptions = animationCurve &lt;&lt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">self</span>.bottomConstrains.offset = <span class="number">0</span>;</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:animationDuration delay:<span class="number">0.</span> options:animationOptions animations:^&#123;</div><div class="line">        [<span class="keyword">self</span>.view setNeedsUpdateConstraints];</div><div class="line">        [<span class="keyword">self</span>.view layoutIfNeeded];</div><div class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>self.bottomConstrains.offset = 0; //设置偏移量会原来位置</p>
</blockquote>
<p>利用Masonry做的动画</p>
<p>最后 别忘记移除通知</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>键盘弹出这个微小的细节 很容易被大家忽视,写这篇文章是为了记录知识和技巧,希望各位多多指教</p>
<p><a href="https://github.com/sunyazhou13/KeyboardAnimation" target="_blank" rel="external">Demo点击这里下载</a></p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/3c30ff9ede53ff83c4dd1d31ec6e75b27bb5d3f3/20180918Key
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>船与灯塔</title>
    <link href="https://www.sunyazhou.com/2018/09/02/20180902Beacon/"/>
    <id>https://www.sunyazhou.com/2018/09/02/20180902Beacon/</id>
    <published>2018-09-02T04:12:51.000Z</published>
    <updated>2018-09-18T01:46:43.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180902Beacon/beacon.jpg" alt=""></p>
<p>荷兰🇳🇱被称为”海上马车夫”，今天讲述的故事与海上马车夫的有关的爱情故事，但它属于东方，属于中国。</p>
<h1 id="船🚢"><a href="#船🚢" class="headerlink" title="船🚢"></a>船🚢</h1><p>它是一搜小船，船上有两只船桨，这艘船从驶出造船厂的时候，就被定义为普通货物运输船只，载重不超过1吨，造这艘船的主人希望能靠这只船养家糊口，但又舍不得花更多的钱买好的木料来制造它。</p>
<h1 id="灯塔"><a href="#灯塔" class="headerlink" title="灯塔"></a>灯塔</h1><p>这是一座集成很多高新科技的灯塔，塔基可以在海上漂浮，自动平衡系统让他在海浪的动荡中稳如泰山，灯塔的父母距离这座新的灯塔不远，形成海上灯塔群，发出很强的激光束，指明航线方向，这坐新的灯塔还能发出加密的无线电信号，这座灯塔通过自身的太阳能外壳和风力发电机提供电力，还能通过坐落于港口海岸线的父母灯塔群无线传输电力给自己充电。只要她觉得电力不足，她就可以移动回父母灯塔群的无线充电有效范围补充能量，在众多灯塔群中，有两座地面灯塔为她提供稳定的电力输送。这座灯塔很幸福。但这座灯塔喜欢游弋在距离父母灯塔不远的浅海区，距离灯塔不超过几海里的范围内。</p>
<h1 id="邂逅那只船"><a href="#邂逅那只船" class="headerlink" title="邂逅那只船"></a>邂逅那只船</h1><p>同在浅海区，有一天这只船在海上的一次风急浪高的夜晚迷失了方向，那只移动的灯塔发现了它，并回应了灯光交换信令，渐渐地，这艘船能识别这个灯塔发出的灯光束，船渐渐地喜欢上了这座移动的灯塔，这座灯塔也很钦佩这艘船，他能在如此大的风浪中屹立不沉，可是船自己深深地知道，自己是载货船，只有通过拉更多的货才能让主人把自己改造成更大的舰船，灯塔看出了船眼中的迷茫，说:”你可以留在浅海区，拉着普通的货物，我的灯塔父母那里是一座港口，他们也许有些小的货物可以给你”，船心里也很想留在这座灯塔附近的港口做一些普通的货物运输，可是船出身寒微，怕被灯塔父母看不起，加之这座港口的贸易很不透明，只有有关系的船才能得到好的货物，船的自尊心受到了极大打击，决心一定要成为一艘旗舰，才有资格去这座港口拉重达几十吨的集装箱，去赢得灯塔父母和灯塔的尊重。就这样那天的风浪过后，船离开了这座灯塔，去了很多像这只小船组成的小船群队。</p>
<h1 id="海上漂泊"><a href="#海上漂泊" class="headerlink" title="海上漂泊"></a>海上漂泊</h1><p>在大海上运送完全超载的货物，过着漂流的生活，举目无亲，背井离乡，由于每次都拉超载的货物，船每次都打肿脸充胖子的运自己运不动的货物，每次触礁都撞得遍体鳞伤，渐渐地船学会了自我修复和疗伤，就这样船的主人赚了第一桶金，打算改造升级这艘木船，把他变成一艘铁甲舰船，去掉了双桨，还用发动机提供动力，这艘船的灯光系统不知为何，对那座灯塔发出的光有一种特殊的能力，识别率能达到200%.可是对其它灯塔的光束识别基本50%都达不到，船主人对这套灯光系统简直食之无用弃之可惜。可是船自己满足，知道灯光识别系统还在我就不会失去方向，我就能运送更重的货物，我就能看到那座灯塔，那座悬浮的灯塔。</p>
<p>刚货运不久，船给灯塔发出了无线电信号，请求灯塔能否和她一样来这座大的港口指名方向，船内心是没有底的，不知道新的港口是好是坏，只是这里的贸易很发达可以积累更多资本，灯塔发来反馈信号，表达了灯塔不想来到新港口的意愿，船很伤心，也很无助，伤心的是自己太弱小，无助的是就算灯塔来了船也给不了灯塔需要的一切电力和希望。不过船内心没有放弃，只要努力才能得到那些需要的一切。</p>
<p>第一次运送货物回到港口，船身已经从木板换成了轻型铁甲，可以运载不超过10吨的货物，当他第一次回到港口时，灯光系统识别那座灯塔发出的光束很精准，甚至光的色彩都可以模拟变换，用船的心里话说，我甚至可以识别那座灯塔光闪烁快慢，闪烁次数分别代表什么意思，以及最重要的是我能解密出她发出的加密信号。那座灯塔也很高兴，那艘很不一样的船回应她的速度很快很精准，也许这座灯塔的光线专为那艘船而发。</p>
<p>船停靠在港口一周时间，然后又要再一次的出海航行，船这一周想了很多，”我纵然能运重10吨的货物，可是马达还达不到指定的节数，速度不够快”(节 是指船只航行速度的单位，类似汽车的马力是多少匹)，就这样道别了灯塔又开始扬帆起航。</p>
<p>在海上航行的时候，船一直思考一个问题，我为什么要放弃这些美好，是因为过上更好的生活吗？是为了把自身打造成旗舰去拉货吗？还是因为贫穷我需要自我救赎的脱贫致富？</p>
<p>在航行中，船会间隔一定时间给灯塔发送无线电波，从而证明他的存在。</p>
<p>在航行的几年中，灯塔很孤独，船也一样孤独，突然有一天船从其它船那里得知灯塔旁边出现了一座新的灯塔，船伤心了，自己没有机会去灯塔父母那里赢得他们的尊重了，于是船卸载了旧的灯光识别系统，卸载了无线电台收发器。直到一段时间以后船换上了新的无线电台和灯光系统，从光谱中删除了那座移动的灯塔的全部信道和交换秘钥，从此失去了一切和那座灯塔的联系。</p>
<p>每次运送货物的周期大概需要在海上航行一年，每年船都会回到浅海区的港口一次看望那座灯塔，远远的望着她，但那座灯塔心里了解，那艘船一年一定有一次会回到这里，只是它不发出光而已。</p>
<p>突然有一天船听说新建在悬浮灯塔旁边的新灯塔因为施工时间紧任务重导致质量不合格而坍塌，船为那座悬浮的灯塔深深地捏了一把汗，她没事吧？我是不是应该在这个时候跟她说句话，安慰一下她，可是我的无线电系统中已经没有了她的信道和交换秘钥。我比她都伤心，在她需要我的光束的时候我居然发不出来任何她需要的光束，让我唯一能有欣慰的是，她还有父母灯塔为她提供地面电力输送，保障她没有被坍塌的风险。</p>
<p>就这样时光过了4年2个月，在这四年中船在每个航行的夜晚时不时的做同一个梦，梦到那座移动的灯塔在发出寻找他的光束，他回应了这灯塔以同样的光束和无线电信号，互相拥抱着哭泣。每次梦里醒来，船的眼角里含着眼泪（当我写到这里时眼角里已经流出了眼泪），每次醒来船都会发出一次信号，记录下时间，就这样4年中梦到了灯塔15次，每次都是很伤心，船也许永远也想不明白自己到底做错了什么，怎么永远忘不掉那永不磨灭的电波，怎么永远也没有机会赢得属于自己的尊重，船的四年中不断完善自己的缺陷，把自己从轻型铁甲舰升级成了巡洋舰，但船的内心依然没有丝毫的高兴，即便自己能拉千吨货物，万吨排量，几千节速度，成为战列舰又能怎样，能换回那座悬浮的灯塔吗？不能，因为船很失败，一辈子也许都是载集装箱的命运，运更多的货物，船沉默了，船很想击沉自己永远沉没。</p>
<p>船试图启用新的灯光系统尝试发出那座灯塔需要的光束和新的无线电台接收系统，从其它友船那里找到这座灯塔信号频道和光谱。不久收到了悬浮灯塔的应答，船内心很矛盾，很高兴，很心酸，很无助，得知那座新灯塔倒塌后海洋总署联合地面港口以及父母灯塔，为悬浮灯塔建造了一座新的灯塔，并且用钢缆固定塔基，让她不在孤独，不在风浪的洗礼中摇摆不定。</p>
<p>灯塔也许不知道船的灯光系统中只换了灯芯和灯罩还有线路，灯光的芯片依然还是原来的芯片，只是现在仅仅能识别90%的那座灯塔光束。船的内心是替灯塔高兴的，她终于有了她想要的一切。但船也许很伤心，他的那座灯塔已经倒塌了，再也不能在海中为船指明方向了，船也不得不找下一座灯塔…</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>这艘船叫”良工”号。</p>
<p>真人故事改编，版权所有翻版必究。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.gi
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="文学" scheme="https://www.sunyazhou.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>iOS中CPU线程调试高级技巧</title>
    <link href="https://www.sunyazhou.com/2018/08/17/20180817CPU-thread-debug/"/>
    <id>https://www.sunyazhou.com/2018/08/17/20180817CPU-thread-debug/</id>
    <published>2018-08-17T09:19:23.000Z</published>
    <updated>2018-08-17T11:14:59.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在开发直播,发现CPU性能被打满后导致CPU降频,发热严重,然后卡顿…</p>
<p>为了定位这个问题我们花费了至少 3天的时间 一点一点跟踪CPU的线程代码,当遇到C++的thread的时候没有符号表,只能看见一坨对象地址,除此以外连个方法名都没有的时候真是手足无措.本篇介绍一个高级调试 方法,使用符号表和相关 指令寻踪 相关代码调用,写的不好 大佬们请轻喷.代码相关过程感谢同事 陈豪的大力支持.</p>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap show me the code"></a>Talk is cheap show me the code</h1><p>我们的实现思路是找到动态库的首地址调用从此入手用相关指令恢复</p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul>
<li>build setting中开启符号表</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/6db967f376eddf5c04bda7db38be27b07f2d48bc/20180817CPU-thread-debug/enable_dysm.png" alt=""></p>
<h2 id="1-导入头文件"><a href="#1-导入头文件" class="headerlink" title="1.导入头文件"></a>1.导入头文件</h2><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>这是mac os的可执行文件的动态链接库头文件 内部内建函数有几个我们需要用到</p>
<h2 id="2-复制下面代码到你的相关调用的地方"><a href="#2-复制下面代码到你的相关调用的地方" class="headerlink" title="2.复制下面代码到你的相关调用的地方"></a>2.复制下面代码到你的相关调用的地方</h2><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//1</span></div><div class="line">uint32_t count = _dyld_image_count();</div><div class="line">DDLogInfo(<span class="string">@"Dyld image count %d"</span>, count);</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">    <span class="keyword">char</span> *image_name = (<span class="keyword">char</span> *)_dyld_get_image_name(i);</div><div class="line">    <span class="comment">//3</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh = _dyld_get_image_header(i);</div><div class="line">    intptr_t vmaddr_slide = _dyld_get_image_vmaddr_slide(i);</div><div class="line">    <span class="comment">//4</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Image name %s at address 0x%llx and ASLR slide 0x%lx.\n"</span>,</div><div class="line">              image_name, (mach_vm_address_t)mh, vmaddr_slide);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我解释一下以上代码  </p>
<ul>
<li>1.拿出当前镜像数量  </li>
<li>2.遍历镜像  </li>
<li>3.获取镜像首地址  </li>
<li>4.打印  </li>
</ul>
<p>然后运行你的程序</p>
<p>然后看下控制台 过滤一下 ASLR我们log中的键入内容</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/08f5465b5d977904da7f3acf876cb6efcd11bf0b/20180817CPU-thread-debug/consolo_debug.png" alt=""></p>
<p>然后 点击 工程中的Product </p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/08f5465b5d977904da7f3acf876cb6efcd11bf0b/20180817CPU-thread-debug/products.png" alt=""></p>
<p>右键 show in finder</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/08f5465b5d977904da7f3acf876cb6efcd11bf0b/20180817CPU-thread-debug/product_dir.png" alt=""></p>
<p>下一步骤 打开终端 cd 到这这个目录(可以打开终端 输入 cd 空格 拖拽那个文件夹)</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/08f5465b5d977904da7f3acf876cb6efcd11bf0b/20180817CPU-thread-debug/dir_final.png" alt=""></p>
<p>然后 <code>pwd</code>一下 看看</p>
<h2 id="3-控制台搜索相关我们打印log的代码"><a href="#3-控制台搜索相关我们打印log的代码" class="headerlink" title="3.控制台搜索相关我们打印log的代码"></a>3.控制台搜索相关我们打印log的代码</h2><p>找到我们第一条首地址</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/536c82a196f36b0b4634d6825ee3e297d66e3830/20180817CPU-thread-debug/importent.png" alt=""></p>
<blockquote>
<p>注意:<strong>这一步非常重要 如果不好使,请重试几次.</strong></p>
</blockquote>
<h4 id="拿出main函数的首地址-ASLR中搜搜的-首地址然后复制-回到终端中输入"><a href="#拿出main函数的首地址-ASLR中搜搜的-首地址然后复制-回到终端中输入" class="headerlink" title="拿出main函数的首地址 ASLR中搜搜的 首地址然后复制 回到终端中输入"></a>拿出main函数的首地址 ASLR中搜搜的 首地址然后复制 <strong>回到终端中输入</strong></h4><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">atos -arch arm64 -o com_kwai_gif.app.dSYM/Contents/Resources/DWARF/com_kwai_gif -l  0x1006b8000</div></pre></td></tr></table></figure>
<blockquote>
<p>注意:<strong>这里是符号表路径</strong>,如果不知道在哪里找到请google一下.</p>
</blockquote>
<p>我们来测试一下 好不好使</p>
<p>首先在控制台顶部的面板点击</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/08f5465b5d977904da7f3acf876cb6efcd11bf0b/20180817CPU-thread-debug/breakpoint1.png" alt=""></p>
<p>然后 在 consolo中输入 <code>bt</code> </p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/08f5465b5d977904da7f3acf876cb6efcd11bf0b/20180817CPU-thread-debug/main.png" alt=""></p>
<p>如果看到 如下内容说明已经成功.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/08f5465b5d977904da7f3acf876cb6efcd11bf0b/20180817CPU-thread-debug/main_result.png" alt=""></p>
<h2 id="4-真机运行-找出未知线程"><a href="#4-真机运行-找出未知线程" class="headerlink" title="4.真机运行 找出未知线程"></a>4.真机运行 找出未知线程</h2><p>首先点击Xcode工程中的Profile运行<code>instruments</code>,我这里是运行工程之后 Xcode9.4可以无缝转换到<code>instruments</code></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/ffdc3d690a4b68cd3d26a1148e81e5817044442c/20180817CPU-thread-debug/instruments0.png" alt=""></p>
<p>我们找到相关线程 没有名称也不知道对象叫什么 就一个十六进制地址</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/ffdc3d690a4b68cd3d26a1148e81e5817044442c/20180817CPU-thread-debug/instruments2.png" alt=""></p>
<p>我们随便找个地址 在终端中输入 </p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/ffdc3d690a4b68cd3d26a1148e81e5817044442c/20180817CPU-thread-debug/instruments3.png" alt=""></p>
<p>好了 如果有问题 请删除product和符号表重新编译</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CPU调试的过程非常麻烦,而且中间过程的代码多数都是C++的调用,主要是线程消耗的开销,中有很多收获希望大家多多指教.</p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在开发直播,发现CPU性能被打满后导致CPU降频,发热严重,然后卡顿…&lt;/p&gt;
&lt;p&gt;为了定位这个问题我们花费了至少 3天的时间 一点一
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Taptic Engine振动反馈</title>
    <link href="https://www.sunyazhou.com/2018/08/13/20180813TapticEngineFeedback/"/>
    <id>https://www.sunyazhou.com/2018/08/13/20180813TapticEngineFeedback/</id>
    <published>2018-08-13T06:28:04.000Z</published>
    <updated>2018-08-13T07:34:57.192Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/6215324852334218b2d9908f39be966090de2f33/20180813TapticEngineFeedback/taptic_engine.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Taptic Engine 是苹果产品上推出的全新震动模块，该元件最早出现在 Apple Watch 中。iPhone 6s 和 iPhone 6s Plus 中，也同样内置了Taptic Engine，在设计上有所升级。</p>
<p>Taptic Engine 振动模块为 Apple Watch 以及 iPhone 6s、iPhone 7 提供了 Force Touch 以及 3D Touch，不同的屏幕操作，可以感受到不同的振动触觉效果，带来更好的用户体验</p>
<h1 id="触觉振动体验"><a href="#触觉振动体验" class="headerlink" title="触觉振动体验"></a>触觉振动体验</h1><h2 id="振动代码-旧方案"><a href="#振动代码-旧方案" class="headerlink" title="振动代码(旧方案)"></a>振动代码(旧方案)</h2><p>调用这行代码虽然可以振动 但是它属于长振动</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);</div></pre></td></tr></table></figure>
<h2 id="振动代码-新方案"><a href="#振动代码-新方案" class="headerlink" title="振动代码(新方案)"></a>振动代码(新方案)</h2><p>iOS10 引入了一种新的、产生触觉反馈的方式， 帮助用户认识到不同的震动反馈有不同的含义 。这个功能的核心就是由 UIFeedbackGenerator 提供。</p>
<p><code>UIFeedbackGenerator</code> 可以帮助你实现 <code>haptic feedback</code>。它的要求是：</p>
<ul>
<li>支持 Taptic Engine 机型 (iPhone 7 以及 iPhone 7 Plus).</li>
<li>app 需要在前台运行</li>
<li>系统 Taptic setting 需要开启</li>
</ul>
<blockquote>
<p>下图开启 声音与触感<br>手机 – 设置 – 声音与触感 – 系统触感反馈(打开)<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/a8bed46d914016aaeb13aa7bac8d7b4c9e287dba/20180813TapticEngineFeedback/setting.png" alt=""></p>
</blockquote>
<h3 id="调用相关振动代码实现振动功能"><a href="#调用相关振动代码实现振动功能" class="headerlink" title="调用相关振动代码实现振动功能"></a>调用相关振动代码实现振动功能</h3><p><code>UIFeedbackGenerator</code> 子类有:</p>
<ul>
<li>UIImpactFeedbackGenerator</li>
<li>UISelectionFeedbackGenerator</li>
<li>UINotificationFeedbackGenerator</li>
</ul>
<h4 id="UIImpactFeedbackGenerator振动"><a href="#UIImpactFeedbackGenerator振动" class="headerlink" title="UIImpactFeedbackGenerator振动"></a>UIImpactFeedbackGenerator振动</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">UIImpactFeedbackGenerator</span> *generator = [[<span class="built_in">UIImpactFeedbackGenerator</span> alloc] initWithStyle: <span class="built_in">UIImpactFeedbackStyleLight</span>];</div><div class="line">[generator impactOccurred];</div></pre></td></tr></table></figure>
<p>振动style有三种枚举</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIImpactFeedbackStyle</span>) &#123;</div><div class="line">    <span class="built_in">UIImpactFeedbackStyleLight</span>,</div><div class="line">    <span class="built_in">UIImpactFeedbackStyleMedium</span>,</div><div class="line">    <span class="built_in">UIImpactFeedbackStyleHeavy</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>基本每次振动相当于创建一个实例调用一次方法就行了,如果觉得性能更好的设计可以搞成成员变量</p>
</blockquote>
<p>反馈结果</p>
<table>
<thead>
<tr>
<th>UIImpactFeedbackGenerator</th>
<th>UIImpactFeedbackStyleLight</th>
<th>UIImpactFeedbackStyleMedium</th>
<th>UIImpactFeedbackStyleHeavy</th>
</tr>
</thead>
<tbody>
<tr>
<td>iPhone 7（iOS 10）及以上机型</td>
<td>微弱短振</td>
<td>中等短振</td>
<td>明显短振</td>
</tr>
<tr>
<td>iPhone 6s Puls（iOS 9）</td>
<td>长振</td>
<td>长振</td>
<td>长振</td>
</tr>
<tr>
<td>iPhone 6（iOS 10）</td>
<td>无振动</td>
<td>无振动</td>
<td>无振动</td>
</tr>
</tbody>
</table>
<h4 id="UISelectionFeedbackGenerator振动"><a href="#UISelectionFeedbackGenerator振动" class="headerlink" title="UISelectionFeedbackGenerator振动"></a>UISelectionFeedbackGenerator振动</h4><p>这里我试图搞成成员变量模拟手势拖拽 振动</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UISelectionFeedbackGenerator</span> *feedbackGesGenerator;</div></pre></td></tr></table></figure>
<p>事件相应</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)gestrueHandle:(<span class="built_in">UIGestureRecognizer</span> *)sender &#123;</div><div class="line">    <span class="keyword">switch</span> (sender.state) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:</div><div class="line">            </div><div class="line">            <span class="comment">// Instantiate a new generator.</span></div><div class="line">            <span class="keyword">self</span>.feedbackGesGenerator = [[<span class="built_in">UISelectionFeedbackGenerator</span> alloc] init];</div><div class="line">            </div><div class="line">            <span class="comment">// Prepare the generator when the gesture begins.</span></div><div class="line">            [<span class="keyword">self</span>.feedbackGesGenerator prepare];</div><div class="line">            </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>: &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// Check to see if the selection has changed...</span></div><div class="line">           </div><div class="line">                <span class="comment">// Trigger selection feedback.</span></div><div class="line">                [<span class="keyword">self</span>.feedbackGesGenerator selectionChanged];</div><div class="line">                </div><div class="line">                <span class="comment">// Keep the generator in a prepared state.</span></div><div class="line">                [<span class="keyword">self</span>.feedbackGesGenerator prepare];</div><div class="line">            </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateCancelled</span>:</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateFailed</span>:</div><div class="line">            </div><div class="line">            <span class="comment">// Release the current generator.</span></div><div class="line">            <span class="keyword">self</span>.feedbackGesGenerator = <span class="literal">nil</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            </div><div class="line">            <span class="comment">// Do nothing.</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意: <strong>这里调用了一下<code>[self.feedbackGesGenerator prepare]</code>方法让振动引擎准备就绪,方便下次快速启动</strong>这个方法是父类的方法</p>
</blockquote>
<h4 id="UINotificationFeedbackGenerator振动"><a href="#UINotificationFeedbackGenerator振动" class="headerlink" title="UINotificationFeedbackGenerator振动"></a>UINotificationFeedbackGenerator振动</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">UINotificationFeedbackGenerator</span> *notifiFeedBack = [[<span class="built_in">UINotificationFeedbackGenerator</span> alloc] init];</div><div class="line">    [notifiFeedBack notificationOccurred:<span class="built_in">UINotificationFeedbackTypeWarning</span>];</div></pre></td></tr></table></figure>
<p>同样<code>UINotificationFeedbackType</code>也是三种枚举</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UINotificationFeedbackType</span>) &#123;</div><div class="line">    <span class="built_in">UINotificationFeedbackTypeSuccess</span>,</div><div class="line">    <span class="built_in">UINotificationFeedbackTypeWarning</span>,</div><div class="line">    <span class="built_in">UINotificationFeedbackTypeError</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>几种不同的振动API 可以视情况而使用, 比较常用的是 <code>UIImpactFeedbackGenerator</code>, 当然也可以随意使用注意操作系统判断检查。</p>
<p>例如:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (@available(iOS <span class="number">10.0</span>, *)) &#123;</div><div class="line">	<span class="comment">//写相关振动代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/6215324852334218b2d9908f39be966090de2f33/20180813Tap
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>利用UIToolBar做高斯模糊背景</title>
    <link href="https://www.sunyazhou.com/2018/07/23/20180723ToolBar-Blur/"/>
    <id>https://www.sunyazhou.com/2018/07/23/20180723ToolBar-Blur/</id>
    <published>2018-07-23T10:22:05.000Z</published>
    <updated>2018-07-25T03:15:08.313Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/360cb7db556ac95a3d8e2028e7027cdcf1378d51/20180723ToolBar-Blur/blur.gif" alt=""></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">UIView</span> *)containerBackgroundView &#123;</div><div class="line">    <span class="keyword">if</span> (!_containerBackgroundView) &#123;</div><div class="line">        <span class="built_in">UIToolbar</span> *toolBar = [[<span class="built_in">UIToolbar</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</div><div class="line">        toolBar.barStyle = <span class="built_in">UIBarStyleBlack</span>;</div><div class="line">        toolBar.clipsToBounds = <span class="literal">YES</span>;</div><div class="line">        _containerBackgroundView = toolBar;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _containerBackgroundView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以使用<code>UIBlurEffect</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">UIBlurEffect</span> *blurEffect = [<span class="built_in">UIBlurEffect</span> effectWithStyle:<span class="built_in">UIBlurEffectStyleLight</span>];</div><div class="line"><span class="built_in">UIVisualEffectView</span> *blurView = [[<span class="built_in">UIVisualEffectView</span> alloc] initWithEffect:blurEffect];</div><div class="line">blurView.frame = myView.bounds;</div><div class="line">[myView addSubview:blurView];</div></pre></td></tr></table></figure>
<p>UIBlurEffectStyle </p>
<ul>
<li><p>UIBlurEffectStyleExtraLight,//额外亮度，（高亮风格）</p>
</li>
<li><p>UIBlurEffectStyleLight,//亮风格</p>
</li>
<li><p>UIBlurEffectStyleDark//暗风格</p>
</li>
</ul>
<blockquote>
<p>UIBlurEffect 不能调节模糊半径</p>
</blockquote>
<p>如果要调整模糊半径</p>
<p>可以对图片进行高斯模糊</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="built_in">UIImage</span> *)convertToBlurImage:(<span class="built_in">UIImage</span> *)image&#123;</div><div class="line">    <span class="built_in">CIFilter</span> *gaussianBlurFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIGaussianBlur"</span>];</div><div class="line">    [gaussianBlurFilter setDefaults];</div><div class="line">    <span class="built_in">CIImage</span> *inputImage = [<span class="built_in">CIImage</span> imageWithCGImage:[image <span class="built_in">CGImage</span>]];</div><div class="line">    [gaussianBlurFilter setValue:inputImage forKey:kCIInputImageKey];</div><div class="line">    [gaussianBlurFilter setValue:@<span class="number">5</span> forKey:kCIInputRadiusKey];</div><div class="line">    <span class="built_in">CIImage</span> *outputImage = [gaussianBlurFilter outputImage];</div><div class="line">    <span class="built_in">CIContext</span> *context   = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">CGImageRef</span> cgimg     = [context createCGImage:outputImage fromRect:[inputImage extent]];  <span class="comment">// note, use input image extent if you want it the same size, the output image extent is larger</span></div><div class="line">    <span class="built_in">UIImage</span> *convertedImage = [<span class="built_in">UIImage</span> imageWithCGImage:cgimg];</div><div class="line">    <span class="keyword">return</span> convertedImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心代码是<code>[gaussianBlurFilter setValue:@5 forKey:kCIInputRadiusKey]</code>;</p>
<p>但是我测试100也没啥问题 没有测试出最大值</p>
<p>以上是几种高斯模糊的相关代码 </p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/360cb7db556ac95a3d8e2028e7027cdcf1378d51/20180723Too
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux 终端 Bash 常用快捷键介绍及经验</title>
    <link href="https://www.sunyazhou.com/2018/07/18/20180718Linux-Bash/"/>
    <id>https://www.sunyazhou.com/2018/07/18/20180718Linux-Bash/</id>
    <published>2018-07-18T01:29:39.000Z</published>
    <updated>2018-07-18T01:46:46.024Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/fb11c210541063b65b788d918ab299cea1f4373f/20180718Linux-Bash/2013-05-20-linux_logo-on-centos5.png" alt=""></p>
<h1 id="bash及其特性"><a href="#bash及其特性" class="headerlink" title="bash及其特性"></a>bash及其特性</h1><ul>
<li><a href="http://cn.linux.vbird.org/linux_basic/0320bash.php" target="_blank" rel="external">bash</a>实质上是一个可执行程序，一个用户的工作环境。</li>
<li>在每一个shell下可以再打开一个shell，新打开的shell可以称为子shell，每一个shell之间是相互独立的。</li>
<li>可以使用pstree命令查看当前shell下的子shell个数。</li>
</ul>
<h3 id="1-最重要的自动补全"><a href="#1-最重要的自动补全" class="headerlink" title="1. 最重要的自动补全"></a>1. 最重要的自动补全</h3><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tab</td>
<td>自动补全</td>
</tr>
</tbody>
</table>
<h3 id="2-编辑跳转"><a href="#2-编辑跳转" class="headerlink" title="2. 编辑跳转"></a>2. 编辑跳转</h3><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + A</td>
<td>跳转到当前行首</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>跳转到当前行末</td>
</tr>
<tr>
<td>Alt + F</td>
<td>将光标在当前行上向后移动一个单词</td>
</tr>
<tr>
<td>Alt + B</td>
<td>将光标在当前行上向前移动一个单词</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>删除当前光标前的一个单词</td>
</tr>
<tr>
<td>Ctrl + K</td>
<td>删除当前光标后的内容</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>清除整行</td>
</tr>
<tr>
<td>Ctrl + L</td>
<td>清屏，类似于 clear 命令</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>退格，类似于 backspace 键</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>将当前光标前的两个字符互换位置</td>
</tr>
<tr>
<td>Esc + T</td>
<td>将当前光标前的两个单词互换位置</td>
</tr>
</tbody>
</table>
<p><code>Ctrl + W</code> 和 <code>Ctrl + U</code> 相当常用。拼写错是很常见的事。</p>
<p><code>Ctrl + L</code> 也不用多说。</p>
<h3 id="3-进程相关"><a href="#3-进程相关" class="headerlink" title="3. 进程相关"></a>3. 进程相关</h3><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + C</td>
<td>终止当前进程</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>将当前进程在后台挂起</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>退出当前 Shell，类似于 exit 命令</td>
</tr>
</tbody>
</table>
<p><code>Ctrl + C</code> 是向当前运行的进程发送 SIGINT 信号，终止进程。</p>
<blockquote>
<p>SIGINT - This signal is the same as pressing ctrl-c. On some systems, “delete” + “break” sends the same signal to the process. The process is interrupted and stopped. However, the process can ignore this signal.</p>
</blockquote>
<p><code>Ctrl + Z</code> 并不结束进程，而是挂起在后台。之后仍然可以通过 <code>fg</code>命令恢复。对应的信号是 SIGTSTP。</p>
<h3 id="3-搜索使用过的命令（特别推荐）"><a href="#3-搜索使用过的命令（特别推荐）" class="headerlink" title="3. 搜索使用过的命令（特别推荐）"></a>3. 搜索使用过的命令（特别推荐）</h3><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + R</td>
<td>用于搜索之前使用过的命令</td>
</tr>
</tbody>
</table>
<p>我经常用 <code>history</code> 查看历史命令，其实已经有现成的快捷键可以用。</p>
<p>按下 <code>Ctrl + R</code> 之后，输入查询的关键字，如果不符合，可以继续按 <code>Ctrl + R</code> 进行遍历。</p>
<p>这个命令其实也是通过 <code>history</code> 记录来查询的。如果不喜欢这种方式，可以直接 <code>history | grep xxx</code> 也是不错的。</p>
<p><a href="https://www.linuxidc.com/Linux/2017-11/148262.htm" target="_blank" rel="external">参考 Linux公社</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些命令对工作效率提升很显著,需要反复学习牢记,文章最后推荐大家关注<code>Linux公社</code>这个具有历史人文精神的Linux社区, 它让我学到不少东西.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/fb11c210541063b65b788d918ab299cea1f4373f/20180718Lin
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C中使用正则去除非数字字母汉字</title>
    <link href="https://www.sunyazhou.com/2018/06/25/20180625FilterString/"/>
    <id>https://www.sunyazhou.com/2018/06/25/20180625FilterString/</id>
    <published>2018-06-25T10:35:17.000Z</published>
    <updated>2018-06-25T10:55:19.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天碰到个需求,PM要求输入框中取出非字母数字汉字的输入.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/0c00202bcba36a3821f799a16e006f467c33a9fc/20180625FilterString/RegularExpressDemo.gif" alt=""></p>
<p>带着这个疑问开始今天的文章</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>创建个demo 代码如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *input;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *label;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.input.delegate = <span class="keyword">self</span>;</div><div class="line">    [<span class="keyword">self</span>.input addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(textChange:) forControlEvents:<span class="built_in">UIControlEventEditingChanged</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//当文本内容改变时调用</span></div><div class="line">- (<span class="keyword">void</span>)textChange:(<span class="built_in">UITextField</span> *)textField</div><div class="line">&#123;</div><div class="line">    <span class="comment">//这里调用相关方法过滤字符串显示出来</span></div><div class="line">    <span class="keyword">self</span>.label.text = <span class="comment">//...;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在网上找了一圈大多都是使用谓词去判断时候包含,没有几个给出相应的处理字符串.</p>
<p>我找到了3种 处理字符串的方式</p>
<ul>
<li>方案1 使用谓词过滤</li>
<li>方案2 使用正则过滤增加寻找的字符串长度</li>
<li>方案3 使用正则精简过滤字符串</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">方案<span class="number">1</span></div><div class="line">- (<span class="built_in">NSString</span> *)filterString1:(<span class="built_in">NSString</span> *)str &#123;</div><div class="line">    <span class="built_in">NSString</span> *regex = <span class="string">@"^[a-zA-Z0-9\u4e00-\u9fa5]+"</span>;</div><div class="line">    <span class="built_in">NSPredicate</span> *pred = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF MATCHES %@"</span>, regex];</div><div class="line">    <span class="built_in">NSMutableString</span> * retStr = [<span class="built_in">NSMutableString</span> string];</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">NSInteger</span> i=<span class="number">0</span>; i&lt; [str length];i++)&#123;</div><div class="line">        <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(i, <span class="number">1</span>);</div><div class="line">        <span class="built_in">NSString</span> *character = [str substringWithRange:range];</div><div class="line">        <span class="keyword">if</span>([pred evaluateWithObject:character])</div><div class="line">        &#123;</div><div class="line">            [retStr appendString:character];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> retStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这种方式虽然能实现 但是代码略显冗长,不过能就解决问题</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//方案2</span></div><div class="line">- (<span class="built_in">NSString</span> *)filterString2:(<span class="built_in">NSString</span> *)str &#123;</div><div class="line">    <span class="built_in">NSString</span> *regex = <span class="string">@"[^a-zA-Z0-9\u4e00-\u9fa5]"</span>;</div><div class="line">    <span class="built_in">NSMutableString</span> *mstr = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"%@"</span>, str];</div><div class="line">    <span class="built_in">NSUInteger</span> i = [mstr replaceOccurrencesOfString:regex withString:<span class="string">@""</span> options:<span class="built_in">NSRegularExpressionSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, mstr.length)];</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@-长度:%zd"</span>,mstr,i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>同样的方法使用正则<code>replaceOccurrencesOfString:withString:options:range:</code>方法替换字符串</p>
</blockquote>
<p>下面我们精简到2行代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//方案3</span></div><div class="line">- (<span class="built_in">NSString</span> *)filterString3:(<span class="built_in">NSString</span> *)str &#123;</div><div class="line">    <span class="built_in">NSString</span> *regex = <span class="string">@"[^a-zA-Z0-9\u4e00-\u9fa5]"</span>;</div><div class="line">    <span class="keyword">return</span> [str stringByReplacingOccurrencesOfString:regex withString:<span class="string">@""</span> options:<span class="built_in">NSRegularExpressionSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str.length)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>最终方案3 得到的预期结果还是不错,推荐使用</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有些问题都是在工作中遇到,希望记录下来一起分享和学习.</p>
<p>全完完</p>
<p><a href="https://github.com/sunyazhou13/RegularExpressDemo" target="_blank" rel="external">Demo在这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天碰到个需求,PM要求输入框中取出非字母数字汉字的输入.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubuserc
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用NSAttributeString实现不同颜色大小显示</title>
    <link href="https://www.sunyazhou.com/2018/06/15/20180615NSAttributeString/"/>
    <id>https://www.sunyazhou.com/2018/06/15/20180615NSAttributeString/</id>
    <published>2018-06-15T02:10:58.000Z</published>
    <updated>2018-06-16T02:06:53.940Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180615NSAttributeString/richtext.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近开发需求遇到一个比较简单但又棘手的问题.先看需求</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/b20f325385e063624b16aa726df0077209327fb0/20180615NSAttributeString/NSAttributeString1.png" alt=""></p>
<p>一个<code>UILabel</code>显示不同大小颜色的字符串,当然我们首先的想到属性字符串,但是注意: 我们这里要处理国际化完成的字符串也就是说：</p>
<p>必须在国际化完成以后才能追加我们的逻辑,而不是一上来就加属性字符串</p>
<p>比如:  <code>2分14秒</code> or <code>2min14secs</code></p>
<p>也就是给我们的是一个  <code>&quot;2分14秒&quot;</code>字符串 我们需要匹配range来修改或者替换. 带着这个疑问开始今天的文章?</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>孔圣贤有云:”举一隅不以三隅反，则不复也。”  </p>
<blockquote>
<p>出自《论语·第七章·述而篇》</p>
</blockquote>
<p>为了不愧对圣贤对我的期待我把 这个问题定位升级成 4个等级</p>
<ul>
<li>Level 1  最优解,时间复杂度最低,效率最高</li>
<li>Level 2  非最优解,时间复杂度最低,效率高</li>
<li>Level 3  都一般</li>
<li>Level 4  简单粗暴</li>
</ul>
<p>我想到了以下至少两种方法</p>
<ol>
<li>通过计算出来的时间  eg: <code>分</code> <code>秒</code>   字符串 range去国际化处理完的字符串去匹配修改</li>
<li>用正则匹配数字</li>
<li>用谓词匹配数字</li>
<li>level4太业余了不敢想向一个工作好几年的开发者还写出这么打脸的代码</li>
</ol>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在工程中拖拽了一个label</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *label;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"> </div><div class="line"> 	<span class="comment">//调用</span></div><div class="line">    <span class="built_in">NSAttributedString</span> *resultTime = [<span class="keyword">self</span> formattedCurrentTime:<span class="number">133</span>];</div><div class="line">    <span class="keyword">self</span>.label.attributedText = resultTime;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="方案1-字符串range匹配"><a href="#方案1-字符串range匹配" class="headerlink" title="方案1: 字符串range匹配"></a>方案1: 字符串range匹配</h3><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 返回当前时间格式</div><div class="line"> @return 返回组装好的字符串</div><div class="line"> */</div><div class="line">- (<span class="built_in">NSAttributedString</span> *)formattedCurrentTime:(<span class="built_in">NSTimeInterval</span>)timeInterval &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSUInteger</span> time = (<span class="built_in">NSUInteger</span>)timeInterval;</div><div class="line">    <span class="built_in">NSInteger</span> minutes = (time / <span class="number">60</span>) % <span class="number">60</span>;</div><div class="line">    <span class="built_in">NSInteger</span> seconds = time % <span class="number">60</span>;</div><div class="line">    <span class="built_in">NSString</span> *minStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" %zd "</span>,minutes];</div><div class="line">    <span class="built_in">NSString</span> *secStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" %zd "</span>,seconds];</div><div class="line">    <span class="comment">//假设这就是我们国际化后的字符串</span></div><div class="line">    <span class="built_in">NSString</span> *localizedFormatString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@分%@秒"</span>,minStr,secStr];</div><div class="line">    <span class="built_in">NSMutableAttributedString</span> *attributeStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:localizedFormatString];</div><div class="line">    <span class="built_in">NSRange</span> minRange, secRange;</div><div class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">9.0</span>, *)) &#123;</div><div class="line">        minRange = [localizedFormatString localizedStandardRangeOfString:minStr];</div><div class="line">        secRange = [localizedFormatString localizedStandardRangeOfString:secStr];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        minRange = [localizedFormatString rangeOfString:minStr];</div><div class="line">        secRange = [localizedFormatString rangeOfString:secStr];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSDictionary</span> *timeAttrs = @&#123; <span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">UIColor</span> redColor],</div><div class="line">                                 <span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">40.0</span>f]&#125;;</div><div class="line">    [attributeStr addAttributes:timeAttrs range:minRange];</div><div class="line">    [attributeStr addAttributes:timeAttrs range:secRange];    </div><div class="line">    <span class="keyword">return</span> [[<span class="built_in">NSAttributedString</span> alloc] initWithAttributedString:attributeStr];;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看下显示结果</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/18f973e4bf79ada776e8bbe9fb845a66375100d1/20180615NSAttributeString/first_arrtributestring.png" alt=""></p>
<blockquote>
<p>是不是看上去很好</p>
</blockquote>
<p>但我认为这并不完美,这种搞法虽然简单直接,但是过于依赖<code>minStr</code>和<code>secStr</code>的原始range,基于iOS9之后提供的API计算<code>range</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (@available(iOS <span class="number">9.0</span>, *)) &#123;</div><div class="line">    minRange = [localizedFormatString localizedStandardRangeOfString:minStr];</div><div class="line">    secRange = [localizedFormatString localizedStandardRangeOfString:secStr];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    minRange = [localizedFormatString rangeOfString:minStr];</div><div class="line">    secRange = [localizedFormatString rangeOfString:secStr];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意:<em>API平台区分</em></p>
</blockquote>
<p>但是这么实现有个Bug 当遇到同样字符串的时候就会匹配错位, 如图</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/ce8515d36cdf420cbe900bc3e4e73c3cfbda7ef6/20180615NSAttributeString/%08NSAttributeString_bug.png" alt=""></p>
<p>错误的原因显然大家都了解</p>
<p>字符串 “0” 的range相同了,但就解决这个问题而言,简单判断一下range然后截取字符串向后跳跃length继续截取获取能实现,但这显然很啰嗦,万一有一天 你遇到的是 “<code>0小时0分12秒</code>“这种字符串那该如何写呢？</p>
<p>是不是要递归的遍历一遍然后挨个取<code>Range</code> 做属性修改?</p>
<p>这样的结果显然不但代码啰嗦 实现起来成本还是比较高的,对代码阅读性都有很大影响(写得好的代码除外哈). </p>
<h5 id="那怎么不啰嗦呢"><a href="#那怎么不啰嗦呢" class="headerlink" title="那怎么不啰嗦呢?"></a>那怎么不啰嗦呢?</h5><p>有一种搞法就是 用两个不同的字符占位.然后 国际化完成之后取Range,再然后替换文字,搞法虽然low点,但是时间复杂度降低了不少,还是可以考虑的.代码我就不写了 我怕小伙伴review代码的时候会虐我.继续往下看</p>
<p><strong>评级: Level 2</strong></p>
<p>那如何不依赖range解决这种问题呢？</p>
<h3 id="方案2-正则匹配"><a href="#方案2-正则匹配" class="headerlink" title="方案2: 正则匹配"></a>方案2: 正则匹配</h3><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 返回当前时间格式</div><div class="line"> @return 返回组装好的字符串</div><div class="line"> */</div><div class="line">- (<span class="built_in">NSAttributedString</span> *)formattedCurrentTime:(<span class="built_in">NSTimeInterval</span>)timeInterval &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSUInteger</span> time = (<span class="built_in">NSUInteger</span>)timeInterval;</div><div class="line">    <span class="built_in">NSInteger</span> minutes = (time / <span class="number">60</span>) % <span class="number">60</span>;</div><div class="line">    <span class="built_in">NSInteger</span> seconds = time % <span class="number">60</span>;</div><div class="line">    <span class="built_in">NSString</span> *minStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" %zd "</span>,minutes];</div><div class="line">    <span class="built_in">NSString</span> *secStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" %zd "</span>,seconds];</div><div class="line">    <span class="comment">//假设这就是我们国际化后的字符串</span></div><div class="line">    <span class="built_in">NSString</span> *localizedFormatString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@分%@秒"</span>,minStr,secStr];</div><div class="line">    <span class="built_in">NSMutableAttributedString</span> *attributeStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:localizedFormatString];</div><div class="line">    <span class="built_in">NSDictionary</span> *timeAttrs = @&#123; <span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">UIColor</span> redColor],</div><div class="line">                                 <span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">40.0</span>f]&#125;;    </div><div class="line">    <span class="comment">/** 方案2 **/</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSRegularExpression</span> *reg = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:<span class="string">@"[0-9]+"</span> options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *matches = [reg matchesInString:localizedFormatString options:<span class="built_in">NSMatchingReportCompletion</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, localizedFormatString.length)];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSTextCheckingResult</span> *match <span class="keyword">in</span> matches) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; match.numberOfRanges; i++) &#123;</div><div class="line">                <span class="built_in">NSRange</span> range = [match rangeAtIndex:i];</div><div class="line">                <span class="keyword">if</span> (range.location != <span class="built_in">NSNotFound</span>) &#123;</div><div class="line">                    [attributeStr addAttributes:timeAttrs range:range];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [[<span class="built_in">NSAttributedString</span> alloc] initWithAttributedString:attributeStr];;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看下显示结果</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/85f7a4f8f09e10c1603968555d86a0128c98696f/20180615NSAttributeString/second_attributestring.png" alt=""></p>
<p>完美实现</p>
<blockquote>
<p>这种方案缺点就是,时间复杂度高了一些,需要每次正则遍历<br>有点是扩展性好一点,万一有一天PM又提了需求要做成 <code>A1</code> <code>B2</code> <code>C3</code> <code>XXX#话题</code>这种，那一定会出坑</p>
</blockquote>
<p>但我第一次这么实现被小伙伴嘲笑很业余.确实很业余,但它能避免方案1中的bug.而且相当精确.</p>
<p><strong>评级: Level 2</strong></p>
<h3 id="方案3-谓词匹配"><a href="#方案3-谓词匹配" class="headerlink" title="方案3: 谓词匹配"></a>方案3: 谓词匹配</h3><p>这种搞法我没尝试,估计会比 方案1和方案2都快一些和简单直接一些,时间太紧张算了,期待评论轻喷吧！</p>
<h3 id="方案4-简单粗暴"><a href="#方案4-简单粗暴" class="headerlink" title="方案4: 简单粗暴"></a>方案4: 简单粗暴</h3><p>就搞 4个label. 我都想象到了被实习生嘲讽+打脸的搞法发生在一个工作好几年开发者身上是多么惨痛的画面. 放弃这种low的搞法</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最终解决问题的方案还是方案2:正则匹配比较靠谱,而且一劳永逸</p>
<p>本篇主要蛋疼的问题是 国际化后的字符串返回结果后,对返回的结果进行加工处理.</p>
<p>没有做到Level 1级的做法很是遗憾,愧对圣贤. 希望小伙伴多提提建议.</p>
<p><a href="https://github.com/sunyazhou13/NSAttributeStringDemo" target="_blank" rel="external">Demo</a>在这里找到</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>格式化时间的代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> 返回时间格式 HH:mm:ss</div><div class="line"> @return 返回组装好的字符串</div><div class="line"> */</div><div class="line">- (<span class="built_in">NSString</span> *)formattedCurrentTime &#123;</div><div class="line">    <span class="built_in">NSUInteger</span> time = (<span class="built_in">NSUInteger</span>)<span class="keyword">self</span>.recorder.currentTime;</div><div class="line">    <span class="built_in">NSInteger</span> hours = (time / <span class="number">3600</span>);</div><div class="line">    <span class="built_in">NSInteger</span> minutes = (time / <span class="number">60</span>) % <span class="number">60</span>;</div><div class="line">    <span class="built_in">NSInteger</span> seconds = time % <span class="number">60</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *format = <span class="string">@"%02i:%02i:%02i"</span>;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:format, hours, minutes, seconds];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180615NSAttributeString/richtext.png&quot; alt=&quot;
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.2中的随机数</title>
    <link href="https://www.sunyazhou.com/2018/06/08/20180608Swift-Random2/"/>
    <id>https://www.sunyazhou.com/2018/06/08/20180608Swift-Random2/</id>
    <published>2018-06-08T01:18:03.000Z</published>
    <updated>2018-06-08T06:19:16.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/dac725ebc1b0f7a6a6c99265f76153b5bfb6d09d/20180608Swift-Random2/whatisnewinswift.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章发布不久WWDC2018就拉开了序幕,让我觉得有一点比较蛋疼的(a bit of pain) 是swift4.2中增加了系统的随机数支持.所以不得不完善的好上一篇文章的缺漏和新技术的研究学习.特此新发一篇新的随机数文章以彰其咎.</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>Xcode10或者更高版本 </li>
<li>Swift4.2</li>
<li>使用Xcode中的Playground</li>
</ul>
<h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><p>在上一篇中我们大部分时间都在围绕<a href="https://man.openbsd.org/arc4random.3" target="_blank" rel="external">arcrandom()</a>函数来介绍随机数.当然也有它的一些变种.eg：arc4random_uniform(),rand(),random().但无论如何这些函数多数都是系统级函数。</p>
<p>在swift4.2中 所有的 数字类型(就是普通数据类型中代表数字的)都有一个静态方法<code>random(in:)</code>,这个方法将接收一个范围(Range)或者开闭范围,返回一个无序的随机数(a uniform distribution). 这些随机函数将会包含在swift的标准库中,如果跨平台的话标准库函数都是一致的,不像上面介绍的系统随机函数.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">1</span>...<span class="number">1000</span>) <span class="comment">//→ 580</span></div><div class="line"><span class="type">Double</span>.random(<span class="keyword">in</span>: <span class="number">0</span>..&lt;<span class="number">1</span>) <span class="comment">//→ 0.3211009027224093</span></div><div class="line"><span class="type">UInt32</span>.random(<span class="keyword">in</span>: <span class="number">0xD800</span>...<span class="number">0xDFFF</span>) <span class="comment">//→ 56324</span></div></pre></td></tr></table></figure>
<h3 id="模偏差-Modulo-bias"><a href="#模偏差-Modulo-bias" class="headerlink" title="模偏差(Modulo bias)"></a>模偏差(Modulo bias)</h3><p>以下代码演示了我们常用的取模 方式随机</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Wrong! ❌</span></div><div class="line"><span class="keyword">let</span> between0And5 = <span class="type">UInt8</span>.random() % <span class="number">6</span></div></pre></td></tr></table></figure>
<p>这种随机数 有可能不够均匀分布,这种非均匀分布的方式就叫<a href="https://www.quora.com/What-is-modulo-bias" target="_blank" rel="external"><code>模偏差</code></a>.</p>
<p>那如何解决这种莫偏差的问题呢?</p>
<p>在swift中就是用我上边介绍的方法.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Correct ✅</span></div><div class="line"><span class="keyword">let</span> between0And5 = <span class="type">UInt8</span>.random(<span class="keyword">in</span>: <span class="number">0</span>..&lt;<span class="number">6</span>) <span class="comment">// → 5</span></div></pre></td></tr></table></figure>
<p>如果我们需要随机一个<code>数字数据类型</code>全范围的随机数的话可以使用 <code>.min ... .max</code>来进行范围随机. 如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> between0And255 = <span class="type">UInt8</span>.random(<span class="keyword">in</span>: .<span class="built_in">min</span> ... .<span class="built_in">max</span>) <span class="comment">// → 190</span></div></pre></td></tr></table></figure>
<h3 id="Bool值随机"><a href="#Bool值随机" class="headerlink" title="Bool值随机"></a>Bool值随机</h3><p>虽然这种类型完全可以用 %2 ==0 或者 %2==0 来解决,但是swift还是很负责任的帮我们做到了这一点, 举个<code>抛硬币</code>场景的随机例子:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinToss</span><span class="params">(<span class="built_in">count</span> tossCount: Int)</span></span> -&gt; (heads: <span class="type">Int</span>, tails: <span class="type">Int</span>) &#123;</div><div class="line">    <span class="keyword">var</span> result = (heads: <span class="number">0</span>, tails: <span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;tossCount &#123;</div><div class="line">        <span class="keyword">let</span> toss = <span class="type">Bool</span>.random()</div><div class="line">        <span class="keyword">if</span> toss &#123;</div><div class="line">            result.heads += <span class="number">1</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.tails += <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> (heads, tails) = coinToss(<span class="built_in">count</span>: <span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="comment">// → (heads 54, tails 46)</span></div></pre></td></tr></table></figure>
<blockquote>
<p>heads → 人头面<br>tails → 背面</p>
</blockquote>
<h3 id="容器类型的元素随机-Random-collection-elements"><a href="#容器类型的元素随机-Random-collection-elements" class="headerlink" title="容器类型的元素随机(Random collection elements)"></a>容器类型的元素随机(Random collection elements)</h3><p>首先大家可以<a href="https://developer.apple.com/documentation/swift/collection" target="_blank" rel="external"><code>Collection</code></a>理解成一个集成<code>NSObject</code>的类实现了容器协议的类型.eg: 数组，字典等等。。。。</p>
<p>这些<code>Collection</code> 类型都有一个<code>randomElement()</code>方法(可以看下上一篇文章末尾介绍的10个字符串的数).这个函数返回一个<code>Optional</code>可选类型.因为<code>Collection</code>可能为空.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> emptyRange = <span class="number">10</span>..&lt;<span class="number">10</span></div><div class="line">emptyRange.isEmpty <span class="comment">// → true</span></div><div class="line">emptyRange.randomElement() <span class="comment">// → nil</span></div></pre></td></tr></table></figure>
<blockquote>
<p>可以看到元素随机为nil</p>
</blockquote>
<p>我们举个上一节的例子还测试一下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>]</div><div class="line"><span class="keyword">let</span> randomElement = arr.randomElement()!  <span class="comment">// → "8"</span></div></pre></td></tr></table></figure>
<p>举个字符串emotion表情的demo</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> emotions = <span class="string">"😀😂😊😍🤪😎😩😭😡"</span></div><div class="line"><span class="keyword">let</span> randomEmotion = emotions.randomElement()! <span class="comment">// → "😡"</span></div></pre></td></tr></table></figure>
<h3 id="Shuffling-集合随机排列-洗牌算法"><a href="#Shuffling-集合随机排列-洗牌算法" class="headerlink" title="Shuffling 集合随机排列(洗牌算法)"></a>Shuffling 集合随机排列(洗牌算法)</h3><p>使用<a href="https://developer.apple.com/documentation/swift/sequence/2996816-shuffled" target="_blank" rel="external">shuffled()</a>方法去随机排列一个序列或容易.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">(<span class="number">1</span>...<span class="number">20</span>).shuffled() </div><div class="line"><span class="comment">// → numbers is now [16, 9, 2, 18, 5, 13, 8, 11, 17, 3, 6, 1, 14, 7, 10, 15, 20, 19, 12, 4]</span></div></pre></td></tr></table></figure>
<p>以上实现了一个类似洗牌算法的排序 1~20 之间的数 注意：左右都是闭区间(闭区间包含本身) 因为这里用的是<code>...</code>,不理解大家可以查找一下swift相关区间标识的知识.</p>
<h2 id="随机数生成的协议（Random-number-generators）"><a href="#随机数生成的协议（Random-number-generators）" class="headerlink" title="随机数生成的协议（Random number generators）"></a>随机数生成的协议（Random number generators）</h2><p><code>Random number generators</code>简称<code>RNG</code>,以下简称<code>RNG</code>.</p>
<h3 id="默认的RNG"><a href="#默认的RNG" class="headerlink" title="默认的RNG"></a>默认的RNG</h3><p>以上介绍的使用方法都是被定义在swift的标准库中的方法. 叫<a href="https://forums.swift.org/t/se-0202-amendment-proposal-rename-random-to-defaultrandomnumbergenerator/12942" target="_blank" rel="external">Random.default</a></p>
<p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0202-random-unification.md" target="_blank" rel="external">SE-0202</a> 讨论了这种默认随机的一些问题</p>
<p>我在这里简要一下</p>
<blockquote>
<p>The aspiration is that this RNG should be cryptographically secure, provide reasonable performance, and should be thread safe. If a vendor is unable to provide these goals, they should document it clearly. … if an RNG on a platform has the possibility of failing, then it must fail [i.e. trap] when it is unable to complete its operation.<br>大概意思就是 高性能,高安全性,线程安全…. </p>
</blockquote>
<h3 id="自定义RNGs"><a href="#自定义RNGs" class="headerlink" title="自定义RNGs"></a>自定义RNGs</h3><p>对于大多数简单的用例，缺省的RNG应该是正确的选择。但是，如果您的代码对随机数生成器有特殊的要求，比如特定的算法或用可重复的种子初始化RNG的能力，那么您就可以通过采用随机数生成器协议来实现自己的RNG。协议只有一个要求:<code>next()</code>方法，该方法产生<code>8个新的字节随机数</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RandomNumberGenerator</span> </span>&#123;</div><div class="line">    <span class="comment">/// Returns a value from a uniform, independent</span></div><div class="line">    <span class="comment">/// distribution of binary data.</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">UInt64</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意:协议需要统一的分布。其思想是，需要具有非均匀分布的随机值的用户可以在第二步将期望的分布应用到均匀分布随机性序列里。<br>就是如果想按照自己的方法随机需要吧next()函数写上,写好泛型函数规则就行了.</p>
</blockquote>
<h3 id="使用自定义随机RNG"><a href="#使用自定义随机RNG" class="headerlink" title="使用自定义随机RNG"></a>使用自定义随机RNG</h3><p>所有用于生成随机值的标准库api都提供了允许用户传入自定义随机数生成器的方法重载。例如，Int类型有以下两种方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">random</span><span class="params">(<span class="keyword">in</span> range: Range&lt;Int&gt;)</span></span> -&gt; <span class="type">Int</span> &#123; ... &#125;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">random</span>&lt;T&gt;<span class="params">(<span class="keyword">in</span> range: Range&lt;Int&gt;,</span></span></div><div class="line">        using generator: <span class="keyword">inout</span> T) -&gt; <span class="type">Int</span></div><div class="line">        <span class="keyword">where</span> <span class="type">T</span>: <span class="type">RandomNumberGenerator</span> &#123; ... &#125;</div><div class="line">    <span class="comment">// The overloads that take a ClosedRange are not shown</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>generator</code>参数需要总是传入<a href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID545" target="_blank" rel="external"><code>inout</code></a>,因为在产生新的随机性时，RNGs通常会改变它们的状态。</p>
<p>下面看下我们怎么调用自定义随机, 我们需要创建一个可变的并且满足inout的要求的方法.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mersenneTwister = <span class="type">MersenneTwisterRNG</span>(...) <span class="comment">// assume this exists</span></div><div class="line"><span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">10</span>..&lt;<span class="number">20</span>, using: &amp;mersenneTwister)</div></pre></td></tr></table></figure>
<h3 id="在自有类型中生成随机值"><a href="#在自有类型中生成随机值" class="headerlink" title="在自有类型中生成随机值"></a>在自有类型中生成随机值</h3><p>通过上面我们了解到</p>
<p>自定义随机协议需要满足两个标准库模式的步骤:</p>
<ul>
<li>提供静态随机方法<code>random() -&gt; Self</code> 这个方法使用默认的RNG,如果我们规范随机范围的时候这个函数能补充额外参数.以便于我们规范随机的range.  </li>
<li>提供第二个方法<code>random&lt;T: RandomNumberGenerator&gt;(using generator: inout T) -&gt; Self</code>这个是生成默认随机数的核心方法.</li>
</ul>
<p>举个扑克游戏中的枚举例子, 这里面我们可以充分利用<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0194-derived-collection-of-enum-cases.md" target="_blank" rel="external"><code>Swift4.2</code></a>中的<a href="https://developer.apple.com/documentation/swift/caseiterable" target="_blank" rel="external">allCase</a>属性.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> diamonds = <span class="string">"♦"</span></div><div class="line">    <span class="keyword">case</span> clubs = <span class="string">"♣"</span></div><div class="line">    <span class="keyword">case</span> hearts = <span class="string">"♥"</span></div><div class="line">    <span class="keyword">case</span> spades = <span class="string">"♠"</span></div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Suit</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Suit</span>.random(using: &amp;<span class="type">Random</span>.<span class="keyword">default</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">random</span>&lt;T: RandomNumberGenerator&gt;</span></div><div class="line">        <span class="params">(using generator: <span class="keyword">inout</span> T)</span> -&gt; <span class="type">Suit</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Force-unwrap can't fail as long as the</span></div><div class="line">        <span class="comment">// enum has at least one case.</span></div><div class="line">        <span class="keyword">return</span> allCases.randomElement(using: &amp;generator)!</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> randomSuit = <span class="type">Suit</span>.random() <span class="comment">// → clubs</span></div><div class="line">randomSuit.rawValue <span class="comment">// → "♠"</span></div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇补充了新版Swift4.2中对标准库中的随机函数支持,也介绍了洗牌函数默认随机均匀排列,希望小伙伴们看完有所收获,有问题还请多多指教</p>
<p>全文完</p>
<p><a href="https://oleb.net/blog/2018/06/random-numbers-in-swift/" target="_blank" rel="external">参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/dac725ebc1b0f7a6a6c99265f76153b5bfb6d09d/20180608Swi
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的随机数</title>
    <link href="https://www.sunyazhou.com/2018/06/01/20180601Random/"/>
    <id>https://www.sunyazhou.com/2018/06/01/20180601Random/</id>
    <published>2018-06-01T09:30:56.000Z</published>
    <updated>2018-06-01T12:02:57.245Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/d91bef0915eb510aeb874e05ccf21df897d2d03d/20180601Random/powered-by-Swift-random-numbers.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天儿童节,写一篇<code>随机数</code>技术文章纪念<code>留守儿童(资深)</code>的童年.</p>
<h2 id="swift中的随机数使用"><a href="#swift中的随机数使用" class="headerlink" title="swift中的随机数使用"></a>swift中的随机数使用</h2><p>在我们开发的过程中，经常用到求取一些随机数,今天列举几种写篇文章</p>
<h2 id="整型随机数"><a href="#整型随机数" class="headerlink" title="整型随机数"></a>整型随机数</h2><p>首先是这个arc4random()</p>
<blockquote>
<p><code>arc4random()</code>使用了<code>arc4</code>密码加密的<code>key</code> <code>stream</code>生成器，产生一个<code>[0, 2^32)</code>区间的随机数(注意是左闭右开区间)。这个函数的返回类型是<code>UInt32</code></p>
<p>提示: <em><code>[</code>和<code>]</code> 分别代表左右闭区间</em>,<br><em><code>(</code>和<code>)</code>代表左右开区间</em><br>也就是<code>中括号</code> -&gt; 代表 闭区间, 闭区间代表包含.<br>小括号 -&gt; 代表开区间, 开区间代表不包含.<br>所以以下看到</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">arc4random()   <span class="comment">//"4058056034"</span></div></pre></td></tr></table></figure>
<p>如果我们想生成一个<strong>指定范围内</strong>的整型随机数，则可以使用<code>arc4random()</code> <code>%</code> <code>upper_bound</code>的方式，其中<code>upper_bound</code>指定的是上边界，如下代码:</p>
<p>求一个10以内的随机数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">arc4random() % <span class="number">10</span>  <span class="comment">// 0~9 注意没有10哈</span></div></pre></td></tr></table></figure>
<p>不过使用这种方法，在<code>upper_bound</code>不是<code>2</code>的幂次方时，会产生一个所谓<code>Modulo bias</code>(模偏差)的问题。</p>
<p>可以使用<code>arc4random_uniform()</code>，它接受一个<code>UInt32</code>类型的参数，<strong>指定随机数区间的上边界</strong><code>upper_bound</code>，该函数生成的随机数范围是[0, upper_bound)，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">arc4random_uniform(<span class="number">10</span>)		<span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>那问题来了？我想指定区间随机 比如: <code>[10, 200)</code>.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> maxNum: <span class="type">UInt32</span> = <span class="number">200</span></div><div class="line"><span class="keyword">let</span> minNum: <span class="type">UInt32</span> = <span class="number">10</span></div><div class="line">arc4random_uniform(maxNum - minNum) + minNum   <span class="comment">// 153</span></div></pre></td></tr></table></figure>
<p>可以看到上述结果 是 <code>153</code>.</p>
<p>swift也可以用C函数中的随机 eg: random() 或者 rand(),但是这些有下面缺点:</p>
<ul>
<li>这两个函数都需要初始种子，通常是以当前时间来确定,属于伪随机.</li>
<li>这两个函数的上限在<code>RAND_MAX=0X7fffffff</code>(2147483647)，是<code>arc4random</code>的一半.</li>
<li><code>rand()</code>函数以有规律的低位循环方式实现，更容易预测</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">srand(UInt32(time(nil)))  <span class="comment">// 种子,random对应的是srandom</span></div><div class="line">rand()				      <span class="comment">// 1,314,695,483</span></div><div class="line">rand() % <span class="number">10</span>	   			  <span class="comment">// 8</span></div></pre></td></tr></table></figure>
<h2 id="64位整型随机数"><a href="#64位整型随机数" class="headerlink" title="64位整型随机数"></a>64位整型随机数</h2><p>我们发现这些函数主要都是针对<code>32</code>位整型数来操作的.如果需要生成一个<code>64</code>位的整型随机数呢?</p>
<p>可以使用如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">arc4random</span> &lt;T: ExpressibleByIntegerLiteral&gt; <span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span> &#123;</div><div class="line">    <span class="keyword">var</span> r: <span class="type">T</span> = <span class="number">0</span></div><div class="line">    arc4random_buf(&amp;r, <span class="type">MemoryLayout</span>&lt;<span class="type">T</span>&gt;.size)</div><div class="line">    <span class="keyword">return</span> r</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以像下面这样调用 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">arc4random(type: <span class="type">UInt64</span>.<span class="keyword">self</span>) <span class="comment">//8021765689869396105</span></div><div class="line">arc4random(type: <span class="type">UInt32</span>.<span class="keyword">self</span>) <span class="comment">//1293034028</span></div><div class="line">arc4random(type: <span class="type">UInt16</span>.<span class="keyword">self</span>) <span class="comment">//29059</span></div><div class="line">arc4random(type: <span class="type">UInt8</span>.<span class="keyword">self</span>)  <span class="comment">//183</span></div></pre></td></tr></table></figure>
<blockquote>
<p>swift 4 语法</p>
</blockquote>
<p>这个函数中使用了<code>arc4random_buf()</code>来生成随机数。</p>
<p>这个函数使用ARC4加密的随机数来填充该函数第二个参数指定的长度的缓存区域。因此，如果我们传入的是sizeof(UInt64)，该函数便会生成一个随机数来填充8个字节的区域，并返回给r。那么64位的随机数生成方法便可以如下实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt64</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: UInt64 = <span class="built_in">min</span>, upper: UInt64 = <span class="built_in">max</span>)</span></span> -&gt; <span class="type">UInt64</span> &#123;</div><div class="line">        <span class="keyword">var</span> m: <span class="type">UInt64</span></div><div class="line">        <span class="keyword">let</span> u = upper - lower</div><div class="line">        <span class="keyword">var</span> r = arc4random(type: <span class="type">UInt64</span>.<span class="keyword">self</span>)</div><div class="line">        <span class="keyword">if</span> u &gt; <span class="type">UInt64</span>(<span class="type">Int64</span>.<span class="built_in">max</span>) &#123;</div><div class="line">            m = <span class="number">1</span> + ~u</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            m = ((<span class="built_in">max</span> - (u * <span class="number">2</span>)) + <span class="number">1</span>) % u</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> r &lt; m &#123;</div><div class="line">            r = arc4random(type: <span class="type">UInt64</span>.<span class="keyword">self</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (r % u) + lower</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来试用一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">UInt64</span>.random()      <span class="comment">//9223372036854775807</span></div></pre></td></tr></table></figure>
<h2 id="浮点型随机数"><a href="#浮点型随机数" class="headerlink" title="浮点型随机数"></a>浮点型随机数</h2><p>如果需要一个浮点值的随机数，则可以使用drand48函数，这个函数产生一个[0.0, 1.0]区间中的浮点数。这个函数的返回值是Double类型。其使用如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">srand48(<span class="type">Int</span>(time(<span class="literal">nil</span>)))</div><div class="line">drand48()  <span class="comment">//0.4643666202473504</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意:需要先调用srand48()生成种子</p>
</blockquote>
<h2 id="示例实践"><a href="#示例实践" class="headerlink" title="示例实践"></a>示例实践</h2><p>如何生成一个0~9 这几个数组做个随机排序,实现类似银行类动态键盘的功能</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>]</div><div class="line">arr.<span class="built_in">sort</span> &#123; (s1, s2) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">    arc4random() &lt; arc4random()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(arr)</div></pre></td></tr></table></figure>
<p>在闭包中，随机生成两个数，比较它们之间的大小，来确定数组的排序.注意不需要重新赋值了在swift4上.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随机数相关的知识容易忘记,特此记录一些技巧,争取每个月发布两篇文章.</p>
<p><a href="http://southpeak.github.io/2015/09/26/ios-techset-5/" target="_blank" rel="external">参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/d91bef0915eb510aeb874e05ccf21df897d2d03d/20180601Ran
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UIView不同方向的导角</title>
    <link href="https://www.sunyazhou.com/2018/05/15/20180515How-to-Create-Top-or-Bottom-Rounded-Corners-for-Views/"/>
    <id>https://www.sunyazhou.com/2018/05/15/20180515How-to-Create-Top-or-Bottom-Rounded-Corners-for-Views/</id>
    <published>2018-05-15T01:58:00.000Z</published>
    <updated>2018-05-15T02:55:50.911Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/1f076ce5865fc9f8d5acf7f1d808c6da04972014/20180515How-to-Create-Top-or-Bottom-Rounded-Corners-for-Views/WX20180515-104917%402x.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开发中总因为一些比较蛋疼的导角问题而困扰着我们,尤其是我们要给一个UIView导角成 左上 、左下。。。</p>
<p>这种需求很值得用代码实现一下, 今天突然在<a href="https://www.appcoda.com/rounded-corners-uiview/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+appcoda+%28AppCoda%3A+Your+iOS+Programming+Community%29" target="_blank" rel="external">AppCode</a>找到了一篇好文章.于是有了下文</p>
<h2 id="通常导角"><a href="#通常导角" class="headerlink" title="通常导角"></a>通常导角</h2><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">self</span>.view.cornerRadius = <span class="number">20.0</span></div><div class="line"><span class="keyword">self</span>.view.clipToBounds = <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>这两行代码是全方向导角</p>
<p>如果像要搞成不同方向的话可以用iOS11 新的API和 iOS11以前的<code>CAShapeLayer</code>画贝赛尔曲线来解决</p>
<p>首先我们要创建一个UIView</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> cardView: <span class="type">UIView</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        cardView = <span class="type">UIView</span>()</div><div class="line">        view.addSubview(cardView)</div><div class="line">        cardView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></div><div class="line">        <span class="comment">//把View居中</span></div><div class="line">        cardView.widthAnchor.constraint(equalToConstant: <span class="number">200</span>).isActive = <span class="literal">true</span></div><div class="line">        cardView.heightAnchor.constraint(equalToConstant: <span class="number">200</span>).isActive = <span class="literal">true</span></div><div class="line">        cardView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></div><div class="line">        cardView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = <span class="literal">true</span></div><div class="line">        cardView.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">1.0</span>, green: <span class="number">0.784</span>, blue: <span class="number">0.2</span>, alpha: <span class="number">1</span>)      </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>iOS11 以后苹果提供了一个<code>UIView</code>的属性叫<code>maskedCorners</code>用于CALayer的动画相关.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CACornerMask</span> : <span class="title">OptionSet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> layerMinXMinYCorner: <span class="type">CACornerMask</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> layerMaxXMinYCorner: <span class="type">CACornerMask</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> layerMinXMaxYCorner: <span class="type">CACornerMask</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> layerMaxXMaxYCorner: <span class="type">CACornerMask</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我说一下</p>
<ul>
<li>layerMinXMinYCorner 底部右侧 的圆角 -&gt; 右下角</li>
<li>layerMaxXMinYCorner 顶部右侧 的圆角 -&gt; 右上角</li>
<li>layerMinXMaxYCorner 底部左侧 的圆角 -&gt; 左下角</li>
<li>layerMinXMinYCorner 顶部左侧 的圆角 -&gt; 左上角</li>
</ul>
<p>一般我们都为UIView写个 extension</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">roundCorners</span><span class="params">(cornerRadius: Double)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.layer.cornerRadius = <span class="type">CGFloat</span>(cornerRadius)</div><div class="line">        <span class="keyword">self</span>.clipsToBounds = <span class="literal">true</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</div><div class="line">            <span class="keyword">self</span>.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>(roundedRect: <span class="keyword">self</span>.bounds, byRoundingCorners: [.topLeft, .topRight], cornerRadii: <span class="type">CGSize</span>(width: cornerRadius, height: cornerRadius))</div><div class="line">            <span class="keyword">let</span> maskLayer = <span class="type">CAShapeLayer</span>()</div><div class="line">            maskLayer.frame = <span class="keyword">self</span>.bounds</div><div class="line">            maskLayer.path = path.cgPath</div><div class="line">            <span class="keyword">self</span>.layer.mask = maskLayer</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里区分了iOS11之前和之后的两种搞法.</p>
<p>之前的话我们都是用一个贝塞尔曲线画path.然后创建CAShapeLayer 给self.layer.mask做一种透明的遮罩来解决不同方向导角问题.</p>
<h2 id="添加动画效果的导角"><a href="#添加动画效果的导角" class="headerlink" title="添加动画效果的导角"></a>添加动画效果的导角</h2><p>我们在原ViewDidLoad()方法里面加个手势.</p>
<p>并写好触发的事件, 完整的代码如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> cardView: <span class="type">UIView</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        cardView = <span class="type">UIView</span>()</div><div class="line">        view.addSubview(cardView)</div><div class="line">        cardView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></div><div class="line">        cardView.widthAnchor.constraint(equalToConstant: <span class="number">200</span>).isActive = <span class="literal">true</span></div><div class="line">        cardView.heightAnchor.constraint(equalToConstant: <span class="number">200</span>).isActive = <span class="literal">true</span></div><div class="line">        cardView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></div><div class="line">        cardView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = <span class="literal">true</span></div><div class="line">        cardView.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">1.0</span>, green: <span class="number">0.784</span>, blue: <span class="number">0.2</span>, alpha: <span class="number">1</span>)</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">let</span> tapRecognizer = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(animateCornerChange(recognizer:)))</div><div class="line">        cardView.addGestureRecognizer(tapRecognizer)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">animateCornerChange</span><span class="params">(recognizer: UITapGestureRecognizer)</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> targetRadius: <span class="type">Double</span> = (cardView.layer.cornerRadius == <span class="number">0.0</span>) ? <span class="number">100.0</span>:<span class="number">0.0</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> #available(iOS <span class="number">10.0</span>, *) &#123;</div><div class="line">            <span class="type">UIViewPropertyAnimator</span>(duration: <span class="number">0.4</span>, curve: .easeInOut) &#123;</div><div class="line">                <span class="keyword">self</span>.cardView.roundCorners(cornerRadius: targetRadius)</div><div class="line">                &#125;.startAnimation()</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="type">UIView</span>.animate(withDuration: <span class="number">1.0</span>, delay: <span class="number">0.0</span>, options: .curveEaseInOut, animations: &#123;</div><div class="line">                </div><div class="line">            &#125;, completion: <span class="literal">nil</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">roundCorners</span><span class="params">(cornerRadius: Double)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.layer.cornerRadius = <span class="type">CGFloat</span>(cornerRadius)</div><div class="line">        <span class="keyword">self</span>.clipsToBounds = <span class="literal">true</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</div><div class="line">            <span class="keyword">self</span>.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>(roundedRect: <span class="keyword">self</span>.bounds, byRoundingCorners: [.topLeft, .topRight], cornerRadii: <span class="type">CGSize</span>(width: cornerRadius, height: cornerRadius))</div><div class="line">            <span class="keyword">let</span> maskLayer = <span class="type">CAShapeLayer</span>()</div><div class="line">            maskLayer.frame = <span class="keyword">self</span>.bounds</div><div class="line">            maskLayer.path = path.cgPath</div><div class="line">            <span class="keyword">self</span>.layer.mask = maskLayer</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="这里主要强调一下动画的新API"><a href="#这里主要强调一下动画的新API" class="headerlink" title="这里主要强调一下动画的新API"></a>这里主要强调一下动画的新API</h3><p>iOS10之后U增加一个新的动画效果API</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">UIViewPropertyAnimator</span>(duration: <span class="number">0.4</span>, curve: .easeInOut) &#123;</div><div class="line"><span class="comment">//这里写相关View的操作代码 。。。eg:下面代码</span></div><div class="line">                <span class="keyword">self</span>.cardView.roundCorners(cornerRadius: targetRadius)</div><div class="line">                &#125;.startAnimation()</div></pre></td></tr></table></figure>
<p>iOS之前可以通过古老的API来实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">1.0</span>, delay: <span class="number">0.0</span>, options: .curveEaseInOut, animations: &#123;</div><div class="line"><span class="comment">//这里写相关View的操作代码 。。。eg:下面代码</span></div><div class="line">                <span class="keyword">self</span>.cardView.roundCorners(cornerRadius: targetRadius)</div><div class="line">            &#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>最终的效果</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/b501b8cabbeaff551be152f8d812148eda1a5319/20180515How-to-Create-Top-or-Bottom-Rounded-Corners-for-Views/TopBottomCornerDemo.gif" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>iOS一些简单的动画导角比较常用所以记录下来,希望大家多多指教</p>
<p><a href="https://github.com/sunyazhou13/TopBottomCornerDemo" target="_blank" rel="external">本文Demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/1f076ce5865fc9f8d5acf7f1d808c6da04972014/20180515How
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>手动管理UIViewController的生命周期</title>
    <link href="https://www.sunyazhou.com/2018/05/08/20180508ManualControlUIViewControllerLifeCycle/"/>
    <id>https://www.sunyazhou.com/2018/05/08/20180508ManualControlUIViewControllerLifeCycle/</id>
    <published>2018-05-08T04:01:27.000Z</published>
    <updated>2018-05-08T06:29:41.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>话说很久不用UIViewController的不常用 的API渐渐的都没有了印象,在 iOS 客户端中，多个 childViewController 的页面是个很常见的交互设计,最早的网易新闻,今日头条等.这篇文章回味一下古老的手动控制视图控制器的生命周期的API.</p>
<h1 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h1><p>我们在使用<code>addChildViewController:</code>的时候会遇到个问题.如何手动控制被添加控制器的生命周期.</p>
<p>如下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">self</span>.vc1 = [[VC1ViewController alloc] init]; <span class="comment">//子控制器</span></div><div class="line"><span class="keyword">self</span>.vc2 = [[VC2ViewController alloc] init]; <span class="comment">//子控制器</span></div><div class="line">    </div><div class="line">[<span class="keyword">self</span> addChildViewController:<span class="keyword">self</span>.vc1]; <span class="comment">//添加到父控制器中</span></div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.vc1.view];   <span class="comment">//把子控制器的 view 添加到父控制器的 view 上面</span></div><div class="line"><span class="keyword">self</span>.vc1.view.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//设置 frame</span></div><div class="line">[<span class="keyword">self</span>.vc1 didMoveToParentViewController:<span class="keyword">self</span>];<span class="comment">//子控制器被通知有了一个父控制器</span></div><div class="line"></div><div class="line"></div><div class="line">    </div><div class="line">[<span class="keyword">self</span> addChildViewController:<span class="keyword">self</span>.vc2];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.vc2.view];</div><div class="line"><span class="keyword">self</span>.vc2.view.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">[<span class="keyword">self</span>.vc2 didMoveToParentViewController:<span class="keyword">self</span>];<span class="comment">//子控制器被通知有了一个父控制器</span></div></pre></td></tr></table></figure>
<p>如果是移除的话使用如下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//移除一个 childViewController</span></div><div class="line">[<span class="keyword">self</span>.vc1 willMoveToParentViewController:<span class="literal">nil</span>];<span class="comment">//子控制器被通知即将解除父子关系</span></div><div class="line">[<span class="keyword">self</span>.vc1.view removeFromSuperview];<span class="comment">//把子控制器的 view 从到父控制器的 view 上面移除</span></div><div class="line">[<span class="keyword">self</span>.vc1 removeFromParentViewController];<span class="comment">//真正的解除关系,会自己调用 [self.vc1 didMoveToParentViewController:nil]</span></div></pre></td></tr></table></figure>
<p>当我们添加child到父控制器的时候<br>它的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</div><div class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated&#123;</div><div class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidDisappear:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些放系统内部会自动帮我们调用</p>
<h4 id="手动管理child-ViewController-的生命周期方法"><a href="#手动管理child-ViewController-的生命周期方法" class="headerlink" title="手动管理child ViewController 的生命周期方法"></a>手动管理child ViewController 的生命周期方法</h4><p>需要在父ViewController里面复写如下方法 并返回<code>NO</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)shouldAutomaticallyForwardAppearanceMethods&#123;</div><div class="line">    <span class="comment">//手动管理子VC的生命周期</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过我们需要注意的是，不能手动调用 viewWillAppear、viewDidAppear等等这些方法，而应该调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)beginAppearanceTransition:(<span class="built_in">BOOL</span>)isAppearing animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line">- (<span class="keyword">void</span>)endAppearanceTransition;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意:<em><strong>用这两个方法来间接触发子控制器的生命周期，并且它们需要成对使用</strong></em></p>
</blockquote>
<p><code>isAppearing</code> 设置为 <code>YES</code> : 触发 <code>viewWillAppear:</code>;  </p>
<p><code>isAppearing</code> 设置为 <code>NO</code> : 触发 <code>viewWillDisappear:</code>;</p>
<p><code>endAppearanceTransition</code>方法会基于我们传入的<code>isAppearing</code><br>来调用<code>viewDidAppear:</code>以及<code>viewDidDisappear:</code>方法</p>
<p>为了测试我写一段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)click:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    sender.selected = !sender.selected;</div><div class="line">    <span class="keyword">if</span> (sender.selected) &#123;</div><div class="line">        [<span class="keyword">self</span>.vc1 beginAppearanceTransition:<span class="literal">NO</span> animated:<span class="literal">YES</span>];  <span class="comment">//调用vc1的 viewWillDisappear:</span></div><div class="line">        [<span class="keyword">self</span>.vc2 beginAppearanceTransition:<span class="literal">YES</span> animated:<span class="literal">YES</span>];  <span class="comment">//调用vc2的 viewWillAppear:</span></div><div class="line">        [<span class="keyword">self</span>.vc1 endAppearanceTransition]; <span class="comment">//调用vc1的viewDidDisappear: </span></div><div class="line">        [<span class="keyword">self</span>.vc2 endAppearanceTransition]; <span class="comment">//调用vc2的viewDidAppear:</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span>.vc1 beginAppearanceTransition:<span class="literal">YES</span> animated:<span class="literal">YES</span>];</div><div class="line">        [<span class="keyword">self</span>.vc2 beginAppearanceTransition:<span class="literal">NO</span> animated:<span class="literal">YES</span>];</div><div class="line">        [<span class="keyword">self</span>.vc1 endAppearanceTransition];</div><div class="line">        [<span class="keyword">self</span>.vc2 endAppearanceTransition];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/sunyazhou13/VCLifeCycle" target="_blank" rel="external">Demo</a></p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;话说很久不用UIViewController的不常用 的API渐渐的都没有了印象,在 iOS 客户端中，多个 childViewContro
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AudioUnit</title>
    <link href="https://www.sunyazhou.com/2018/05/07/20180507AudioUnit/"/>
    <id>https://www.sunyazhou.com/2018/05/07/20180507AudioUnit/</id>
    <published>2018-05-07T06:59:41.000Z</published>
    <updated>2018-05-10T02:34:43.626Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180430AudioEffectImplement/au_host_app1.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>声音的渲染在iOS平台上回直接使用<code>AudioUnit</code>的API来完成.用来实现一些类似<code>大叔</code>,<code>KTV</code>,<code>耳返等效果</code>….</p>
<p>今天带领大家深入了解和学习一下这些音效.</p>
<h2 id="实现iOS变声的背景"><a href="#实现iOS变声的背景" class="headerlink" title="实现iOS变声的背景"></a>实现iOS变声的背景</h2><p>声音变声一般都是发生在 一端采集录制另一端播放音频, 忽略中间的转码过程,在输入输出的中间过程中进行相应的音频参数就实现了变声. </p>
<p>下图是AVAudioSession的工作流<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/9818fa6853c32f92936661cfc06f25c87f07f64f/20180430AudioEffectImplement/ASPG_intro_2x.png" alt=""></p>
<p>大家常用的变声方案有很多:</p>
<ol>
<li>FFMpeg提供内部效果器 eg:EQ均衡器  </li>
<li>AVFoundation底层的<code>Audio Unit</code> eg: 混响reverb</li>
<li>SoundTouch</li>
<li>其它方案…</li>
</ol>
<p>这里我们选用iOS AVFoundation本身提供的音频处理单元<code>Audio Unit</code>. </p>
<p><code>Audio Unit</code>提供如下功能:</p>
<ul>
<li>低延迟的音频I/O eg:voip</li>
<li>多路声音的合成并回放 eg:游戏中的音乐合成器</li>
<li>Audio Unit 自身提供 eg：回声消除、Mix两轨音频、均衡器、压缩器、混响效果器等.</li>
<li>需要图状的结构来处理音频. eg: 有点类似PC时代的主播经常用的一种叫KX 驱动. </li>
</ul>
<p>下图是KX 驱动连线图 windows平台 </p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/ce762c6a5f6eb1d09da7bde9c7ec773c42f2d663/20180430AudioEffectImplement/kx.jpeg" alt=""></p>
<h2 id="AudioUnit介绍"><a href="#AudioUnit介绍" class="headerlink" title="AudioUnit介绍"></a>AudioUnit介绍</h2><h4 id="iOS层级架构图"><a href="#iOS层级架构图" class="headerlink" title="iOS层级架构图"></a>iOS层级架构图</h4><p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180430AudioEffectImplement/iphone_os_audio_architecture_2x.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180430AudioEffectImplement/AboutAudioUnitHosting_2x.png" alt=""></p>
<blockquote>
<p>声音的处理过程, 首先需要认识一下<code>AUGraph</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/360b2677618e504462966e58d406d0a47a6e993d/20180430AudioEffectImplement/simple_au_chain_2x.png" alt=""></p>
<blockquote>
<p><strong>audio processing graph</strong>:  A representation of a signal chain comprising an interconnection of audio units. Also called an AUGraph or graph. Core Audio represents such an interconnected network as a software object of typeAUGraph. Audio processing graphs must end in an output unit. See also audio unit.<br>一种信号链的表示，包括音频单元的互连。也称为AUGraph或graph。Core Audio代表着这样一个相互连接的网络，它是一个<code>AUGraph</code>类型的对象。</p>
</blockquote>
<h4 id="audio-unit-结构图-工作流"><a href="#audio-unit-结构图-工作流" class="headerlink" title="audio unit 结构图(工作流)"></a>audio unit 结构图(工作流)</h4><p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/7e99645383e5db4837567bd9ec35fe78588439f6/20180430AudioEffectImplement/au_architecture.jpg" alt=""></p>
<h4 id="Audio-Unit-构成图"><a href="#Audio-Unit-构成图" class="headerlink" title="Audio Unit 构成图"></a>Audio Unit 构成图</h4><p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/0b99a7e821ed34b72dd684552394dda26c16cf2d/20180430AudioEffectImplement/audioUnitScopes_2x.png" alt=""></p>
<p>Unit 一般 分为 Element0 和  Element1</p>
<p>下面我们举Remote I/O Unit为例:  </p>
<p>RemoteIO 这个Unit是和硬件IO相关的Unit，它分为输入端和输出端, 输入端一般指麦克风,输出端一般指扬声器.</p>
<blockquote>
<p><code>Element0</code> 控制输出<br><code>Element1</code> 控制输入<br>图中Element 也叫 bus；<br>音频流从输入域（input scope）输入， 从输出域（output scope）输出<br>整个Render过程就是一次RenderCycle</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180430AudioEffectImplement/IO_unit_2x.png" alt=""></p>
<p><strong>同时每个Element分为Input Scope 和 Output Scope.如果我们想使用扬声器的声音播放功能,必须需将这个Unit的<code>Element0</code>的<code>OutputScope</code>和Speak进行连接. 如果想使用麦克风录音功能,那么必须将这个Unit的<code>Element1</code>的<code>InputScope</code>和麦克风进行连接.</strong></p>
<h3 id="构建Audio-Unit"><a href="#构建Audio-Unit" class="headerlink" title="构建Audio Unit"></a>构建Audio Unit</h3><p>首先需要启用音频会话 这些大家自己配置就好 了 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//配置会话相关伪代码</div><div class="line">[[AVAudioSession sharedInstance].xxxxx xxxxx];</div></pre></td></tr></table></figure>
<p>如何用代码构建一个Audio Unit？ 这里我们以Remote I/O Unit 为例:</p>
<p>创建AudioUnit有两种方式</p>
<ol>
<li>直接使用AudioUnit裸创建 </li>
<li>使用AUGraph和AUNode来构建</li>
</ol>
<ul>
<li>第一种 裸创建</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;AudioUnit/AudioUnit.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line">&#123;</div><div class="line">    AudioUnit ioUnitInstance; <span class="comment">//声明一变量</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//首先构造出要用到创建Unit的结构体</span></div><div class="line">    AudioComponentDescription ioUnitDescription;</div><div class="line">    ioUnitDescription.componentType = kAudioUnitType_Output;</div><div class="line">    ioUnitDescription.componentSubType = kAudioUnitSubType_RemoteIO;</div><div class="line">    ioUnitDescription.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">    ioUnitDescription.componentFlags = <span class="number">0</span>;</div><div class="line">    ioUnitDescription.componentFlagsMask = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    AudioComponent ioUnitRef = AudioComponentFindNext(<span class="literal">NULL</span>, &amp;ioUnitDescription);</div><div class="line">    <span class="comment">//创建AudioUnit实例</span></div><div class="line">    AudioComponentInstanceNew(ioUnitRef, &amp;ioUnitInstance);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第二种使用AUGraph和AUNode</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;AudioUnit/AudioUnit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;AudioToolbox/AudioToolbox.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line">&#123;</div><div class="line">    AUGraph     processingGraph;</div><div class="line">    AUNode      ioNode;</div><div class="line">    AudioUnit   ioUnit;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//首先构造出要用到创建Unit的结构体</span></div><div class="line">    AudioComponentDescription ioUnitDescription;</div><div class="line">    ioUnitDescription.componentType = kAudioUnitType_Output;</div><div class="line">    ioUnitDescription.componentSubType = kAudioUnitSubType_RemoteIO;</div><div class="line">    ioUnitDescription.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">    ioUnitDescription.componentFlags = <span class="number">0</span>;</div><div class="line">    ioUnitDescription.componentFlagsMask = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//1 new</span></div><div class="line">    NewAUGraph(&amp;processingGraph);</div><div class="line">    AUGraphAddNode(processingGraph, &amp;ioUnitDescription, &amp;ioNode);</div><div class="line">    </div><div class="line">    <span class="comment">//2 open</span></div><div class="line">    AUGraphOpen(processingGraph);</div><div class="line">    </div><div class="line">    <span class="comment">//3 从相应的Node中获得AudioUnit</span></div><div class="line">    AUGraphNodeInfo(processingGraph, ioNode, <span class="literal">NULL</span>, &amp;ioUnit);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>推荐使用第二种因为这种创建扩展性更高一些<br>注意:<strong><em>AUNode必须和AudioUnit成对出现</em></strong></p>
</blockquote>
<p>如下图 ：Remote I/O Unit </p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/0b99a7e821ed34b72dd684552394dda26c16cf2d/20180430AudioEffectImplement/IO_unit_2x.png" alt=""></p>
<blockquote>
<p>麦克风或者扬声器在Audio Unit中有相应的枚举.<br>直播中的<code>耳返</code>就是用的这个把麦克风采集的数据直接扔给扬声器 这样就能做到 低延迟的实时听到麦克风的声音.<br>直播中一般使用<code>Remote I/O</code> unit来进行采集工作</p>
</blockquote>
<p>使用AudioUnit连接扬声器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">OSStatus status = noErr;</div><div class="line"><span class="built_in">UInt32</span> onFlag = <span class="number">1</span>;</div><div class="line"><span class="built_in">UInt32</span> busZero = <span class="number">0</span>; <span class="comment">//Element0  就是bus0</span></div><div class="line">status = AudioUnitSetProperty(remoteIOUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Output, busZero, &amp;onFlag, <span class="keyword">sizeof</span>(onFlag));</div><div class="line">CheckStatus(status, <span class="string">@"不能连接扬声器"</span>, <span class="literal">YES</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意: kAudioUnitScope_Output 就是连接扬声器的key</p>
</blockquote>
<p>连接麦克风</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">OSStatus status = noErr;</div><div class="line"><span class="built_in">UInt32</span> busOne = <span class="number">1</span>; <span class="comment">//Element1 就是bus1 接麦克风输入</span></div><div class="line"><span class="built_in">UInt32</span> oneFlag = <span class="number">1</span>;</div><div class="line">status =  AudioUnitSetProperty(remoteIOUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Input, busOne, &amp;oneFlag, <span class="keyword">sizeof</span>(oneFlag));</div><div class="line">CheckStatus(status, <span class="string">@"不能连接麦克风"</span>, <span class="literal">YES</span>);</div></pre></td></tr></table></figure>
<p>可以使用如下代码检查每一步执行出错debug  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> CheckStatus(OSStatus status, <span class="built_in">NSString</span> *message, <span class="built_in">BOOL</span> fatal) &#123;</div><div class="line">    <span class="keyword">if</span> (status != noErr) &#123;</div><div class="line">        <span class="keyword">char</span> fourCC[<span class="number">16</span>];</div><div class="line">        *(<span class="built_in">UInt32</span> *)fourCC = <span class="built_in">CFSwapInt32HostToBig</span>(status);</div><div class="line">        fourCC[<span class="number">4</span>] = <span class="string">'\0'</span>;</div><div class="line">        <span class="keyword">if</span> (isprint(fourCC[<span class="number">0</span>]) &amp;&amp; isprint(fourCC[<span class="number">1</span>]) &amp;&amp;</div><div class="line">            isprint(fourCC[<span class="number">2</span>]) &amp;&amp; isprint(fourCC[<span class="number">4</span>])) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@:%s"</span>,message, fourCC);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@:%d"</span>,message, (<span class="keyword">int</span>)status);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (fatal) &#123;</div><div class="line">            exit(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>由于status每次报错都打印 相关数字大家可能不理解可以点击<a href="https://www.osstatus.com/" target="_blank" rel="external">OSStatus</a> 查询相关错误码</p>
</blockquote>
<h4 id="AVAudioMix"><a href="#AVAudioMix" class="headerlink" title="AVAudioMix"></a>AVAudioMix</h4><p>我们一般都在采集、录制或编辑音视频相应的类中使用AVAudioMixer.</p>
<p>举个例子:我们变声实现的流程大概是这个样子 <strong>AVAudioPlayer -&gt; AVPlayerItem -&gt; AVAudioMixer-&gt; AUGraph -&gt; AUNode + AudioUnit</strong></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/903e2fa4eb2daafcc3b187854edc69d1bad8b382/20180430AudioEffectImplement/AVAudioMix-class.001.png" alt=""></p>
<h4 id="AudioStreamBasicDescription-配置麦克风输入的参数"><a href="#AudioStreamBasicDescription-配置麦克风输入的参数" class="headerlink" title="AudioStreamBasicDescription 配置麦克风输入的参数"></a>AudioStreamBasicDescription 配置麦克风输入的参数</h4><p>当我们控制Remote IO Unit的时候想告诉麦克风 各种input的参数 可以通过 一个叫ASBD 格式的结构体数据描述来设置给相应的Unit</p>
<h5 id="Audio-Stream-Format-描述ASBD"><a href="#Audio-Stream-Format-描述ASBD" class="headerlink" title="Audio Stream Format 描述ASBD"></a>Audio Stream Format 描述ASBD</h5><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">UInt32</span> bytePerSample = <span class="keyword">sizeof</span>(Float32);</div><div class="line">AudioStreamBasicDescription asbd;</div><div class="line">bzero(&amp;asbd, <span class="keyword">sizeof</span>(asbd));</div><div class="line">asbd.mFormatID = kAudioFormatLinearPCM;</div><div class="line">asbd.mSampleRate = <span class="number">44100</span>;</div><div class="line">asbd.mChannelsPerFrame = channels;</div><div class="line">asbd.mFramesPerPacket = <span class="number">1</span>;</div><div class="line">asbd.mFormatFlags = kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved;</div><div class="line">asbd.mBitsPerChannel = <span class="number">8</span> * bytePerSample;</div><div class="line">asbd.mBytesPerFrame = bytePerSample;</div><div class="line">asbd.mBytesPerPacket = bytePerSample;</div></pre></td></tr></table></figure>
<blockquote>
<p>上边代码展示了如何填充ASBD结构体,这个描述音视频的具体格式.</p>
</blockquote>
<p>下面具体介绍一下各个参数的意思</p>
<ul>
<li>mFormatID 可用来指定编码格式 eg:PCM</li>
<li>mSampleRate 采样率</li>
<li>mChannelsPerFrame 每个Frame有几个channel</li>
<li>mFramesPerPacket 每个Packet有几Frame</li>
<li>mFormatFlags 这个是用来描述声音格式表示格式的参数,上面代码我们指定的是每个sample的表示格式为Float格式,有点类似SInt16,如果后边是NonInterleaved代表非交错的,对于这个音频来讲就是左右声道的是非交错存放的,实际的音频数据会存储在一个AudioBufferList结构中的变量mBuffers中,如果mFormatFlags指定的是NonInterleaved,那么左声道就在会在mBuffers[0]里面,右声道就在mBuffers[1]里面.</li>
<li>mBitsPerChannel 表示一个声道的音频数据用多少位来表示,上面我们用的是Float来表示, 所以这里使用的是 8 乘以 每个采样的字节数来赋值.</li>
<li>mBytesPerFrame 和 mBytesPerPacket 这两个的赋值需要根据mFormatFlags 的值来进行分配,如果是NonInterleaved非交错的情况下, 就赋值bytePerSample(因为左右声道是分开的).但如果是Interleaved的话,那就应该是 bytePerSample * channels (因为左右声道是交错存放),这样才能表示一个Frame里面到底有多少byte.</li>
</ul>
<p>讲了这么多 那我们怎么把这个ASDB给 Unit?</p>
<p>如下代码 设置ASBD给相应的Audio Unit</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AudioUnitSetProperty(remoteIOUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, <span class="number">1</span>, &amp;asbd, <span class="keyword">sizeof</span>(asbd));</div></pre></td></tr></table></figure>
<p>完整的代码如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//设置ASBD</span></div><div class="line">AudioStreamBasicDescription inputFormat;</div><div class="line">inputFormat.mSampleRate = <span class="number">44100</span>;</div><div class="line">inputFormat.mFormatID = kAudioFormatLinearPCM;</div><div class="line">inputFormat.mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsNonInterleaved;</div><div class="line">inputFormat.mFramesPerPacket = <span class="number">1</span>;</div><div class="line">inputFormat.mChannelsPerFrame = <span class="number">1</span>;</div><div class="line">inputFormat.mBytesPerPacket = <span class="number">2</span>;</div><div class="line">inputFormat.mBytesPerFrame = <span class="number">2</span>;</div><div class="line">inputFormat.mBitsPerChannel = <span class="number">16</span>;</div><div class="line"><span class="comment">//设置给输入端 配置麦克风输出的数据是什么格式</span></div><div class="line">OSStatus status = noErr;</div><div class="line">status = AudioUnitSetProperty(audioUnit,</div><div class="line">                              kAudioUnitProperty_StreamFormat,</div><div class="line">                              kAudioUnitScope_Output,</div><div class="line">                              InputBus,</div><div class="line">                              &amp;inputFormat,</div><div class="line">                              <span class="keyword">sizeof</span>(inputFormat));</div><div class="line">CheckStatus(status, <span class="string">@"AudioUnitGetProperty bus1 output ASBD error"</span>, <span class="literal">YES</span>);</div></pre></td></tr></table></figure>
<h3 id="Audio-Unit-分类"><a href="#Audio-Unit-分类" class="headerlink" title="Audio Unit 分类"></a>Audio Unit 分类</h3><figure class="highlight"><table><tr><td class="code"><pre><div class="line">CF_ENUM(UInt32) &#123;</div><div class="line">	kAudioUnitType_Output					= 'auou',</div><div class="line">	kAudioUnitType_MusicDevice				= 'aumu',</div><div class="line">	kAudioUnitType_MusicEffect				= 'aumf',</div><div class="line">	kAudioUnitType_FormatConverter			= 'aufc',</div><div class="line">	kAudioUnitType_Effect					= 'aufx',</div><div class="line">	kAudioUnitType_Mixer					= 'aumx',</div><div class="line">	kAudioUnitType_Panner					= 'aupn',</div><div class="line">	kAudioUnitType_Generator				= 'augn',</div><div class="line">	kAudioUnitType_OfflineEffect			= 'auol',</div><div class="line">	kAudioUnitType_MIDIProcessor			= 'aumi'</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">功能/作用</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Effect Unit</td>
<td style="text-align:left">提供声音特效处理</td>
<td style="text-align:left">kAudioUnitType_Effect</td>
</tr>
<tr>
<td style="text-align:left">Mixer Units</td>
<td style="text-align:left">提供Mix多路声音的功能</td>
<td style="text-align:left">kAudioUnitType_Mixer</td>
</tr>
<tr>
<td style="text-align:left">I/O Units</td>
<td style="text-align:left">I/O 采集音频与播放音频功能</td>
<td style="text-align:left">kAudioUnitType_Output</td>
</tr>
<tr>
<td style="text-align:left">AUConverter Units</td>
<td style="text-align:left">格式转换 eg:采样格式Float转SInt16、交错或平铺、单双声道的转换</td>
<td style="text-align:left">kAudioUnitType_FormatConverter</td>
</tr>
<tr>
<td style="text-align:left">Generator Units</td>
<td style="text-align:left">提供播放器功能</td>
<td style="text-align:left">kAudioUnitType_Generator</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">CF_ENUM(UInt32) &#123;</div><div class="line">	kAudioUnitSubType_PeakLimiter			= 'lmtr',</div><div class="line">	kAudioUnitSubType_DynamicsProcessor		= 'dcmp',</div><div class="line">	kAudioUnitSubType_LowPassFilter			= 'lpas',</div><div class="line">	kAudioUnitSubType_HighPassFilter		= 'hpas',</div><div class="line">	kAudioUnitSubType_BandPassFilter		= 'bpas',</div><div class="line">	kAudioUnitSubType_HighShelfFilter		= 'hshf',</div><div class="line">	kAudioUnitSubType_LowShelfFilter		= 'lshf',</div><div class="line">	kAudioUnitSubType_ParametricEQ			= 'pmeq',</div><div class="line">	kAudioUnitSubType_Distortion			= 'dist',</div><div class="line">	kAudioUnitSubType_Delay					= 'dely',</div><div class="line">	kAudioUnitSubType_SampleDelay			= 'sdly',</div><div class="line">	kAudioUnitSubType_NBandEQ				= 'nbeq'</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">CF_ENUM(UInt32) &#123;</div><div class="line">	kAudioUnitSubType_Reverb2				= 'rvb2',</div><div class="line">	kAudioUnitSubType_AUiPodEQ				= 'ipeq'</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Effect-Unit-子类型及用途说明"><a href="#Effect-Unit-子类型及用途说明" class="headerlink" title="Effect Unit 子类型及用途说明"></a>Effect Unit 子类型及用途说明</h4><table>
<thead>
<tr>
<th style="text-align:left">子类型</th>
<th style="text-align:left">用途说明</th>
<th style="text-align:left">子枚举类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">均衡效果器</td>
<td style="text-align:left">为声音的某些<a href="https://baike.baidu.com/item/%E9%A2%91%E5%B8%A6" target="_blank" rel="external">频带</a>增强或衰减能量，效果器需要指定多个频带,然后为各频带设置增益最终改变声音在音域上的能量分布</td>
<td style="text-align:left">kAudioUnitSubType_NBandEQ</td>
</tr>
<tr>
<td style="text-align:left">压缩效果器</td>
<td style="text-align:left">当声音较小或较大通过设置阀值来提高或降低声音能量 eg:作用时间、释放时间、以及触发值从而最终控制声音在时域上的能量范围</td>
<td style="text-align:left">kAudioUnitSubType_DynamicsProcessor</td>
</tr>
<tr>
<td style="text-align:left">混响效果器</td>
<td style="text-align:left">通过声音反射的延迟控制声音效果</td>
<td style="text-align:left">kAudioUnitSubType_Reverb2</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Effect Unit 下最常用的效果器就上边这三种, 像高通(High Pass)、低通(Low Pass)、带通(Band Pass)、延迟(Delay)、压限(Limiter) 等这些不是很常用,如果大家对这个很熟悉可以试试使用一下.</p>
</blockquote>
<h4 id="Mixer-Units-子类型及用途说明"><a href="#Mixer-Units-子类型及用途说明" class="headerlink" title="Mixer Units 子类型及用途说明"></a>Mixer Units 子类型及用途说明</h4><table>
<thead>
<tr>
<th style="text-align:left">子类型</th>
<th style="text-align:left">用途说明</th>
<th style="text-align:left">子枚举类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">3D Mixer</td>
<td style="text-align:left">仅支持 macOS</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">MultiChannelMixer</td>
<td style="text-align:left">多路声音混音效果器,可以接受多路音频输入,还可以分别调整每一路的音频增益和开关,并将多路音频合成一路</td>
<td style="text-align:left">kAudioUnitSubType_MultiChannelMixer</td>
</tr>
</tbody>
</table>
<h4 id="I-O-Units-子类型及用途说明"><a href="#I-O-Units-子类型及用途说明" class="headerlink" title="I/O Units 子类型及用途说明"></a>I/O Units 子类型及用途说明</h4><table>
<thead>
<tr>
<th style="text-align:left">子类型</th>
<th style="text-align:left">用途说明</th>
<th style="text-align:left">子枚举类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Remote I/O</td>
<td style="text-align:left">采集音频与播放音频,在Audio Unit中使用麦克风和扬声器的时候会用到这个Unit</td>
<td style="text-align:left">kAudioUnitType_Output</td>
</tr>
<tr>
<td style="text-align:left">Generic Output</td>
<td style="text-align:left">进行离线处理,或者说AUGraph中不使用扬声器来驱动整个数据流,而希望使用一个输出(可以放入内存队列或者磁盘I/O操作)来驱动数据流时</td>
<td style="text-align:left">kAudioUnitSubType_GenericOutput</td>
</tr>
</tbody>
</table>
<h4 id="AUConverter-Units-子类型及用途说明"><a href="#AUConverter-Units-子类型及用途说明" class="headerlink" title="AUConverter Units 子类型及用途说明"></a>AUConverter Units 子类型及用途说明</h4><table>
<thead>
<tr>
<th style="text-align:left">子类型</th>
<th style="text-align:left">用途说明</th>
<th style="text-align:left">子枚举类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AUConverter</td>
<td style="text-align:left">格式转换,当某些效果器对输入的音频格式有明确要求时,或者我们将音频数据输入给一些其它的编码器进行编码。。。</td>
<td style="text-align:left">kAudioUnitSubType_AUConverter</td>
</tr>
<tr>
<td style="text-align:left">Time Pitch</td>
<td style="text-align:left">变速变调效果器,调整声音音高. eg:会说话的Tom猫</td>
<td style="text-align:left">kAudioUnitSubType_NewTimePitch</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意: AUConverter  如果由FFMpeg解码出来的PCM 是SInt16格式 如果要用格式转换效果器unit必须转成Float32格式表示的数据.</p>
</blockquote>
<h4 id="Generator-Units-子类型及用途说明"><a href="#Generator-Units-子类型及用途说明" class="headerlink" title="Generator Units 子类型及用途说明"></a>Generator Units 子类型及用途说明</h4><table>
<thead>
<tr>
<th style="text-align:left">子类型</th>
<th style="text-align:left">用途说明</th>
<th style="text-align:left">子枚举类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AudioFilePlayer</td>
<td style="text-align:left">接收裸PCM 播放 一般大家可以用这个配合Remote I/O 做播放器</td>
<td style="text-align:left">kAudioUnitSubType_AudioFilePlayer</td>
</tr>
</tbody>
</table>
<p>相关shell命令 <strong>将音频文件转成pcm</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">ffmpeg -i test.mp3 -acodec pcm_s16le -f s16le output.pcm</div></pre></td></tr></table></figure>
<blockquote>
<p>brew install ffmpeg</p>
</blockquote>
<p><a href="https://github.com/sunyazhou13/AduioUnitDemo" target="_blank" rel="external">Demo实现耳返功能</a><br><a href="https://github.com/sunyazhou13/AudioUnitDemo2" target="_blank" rel="external">Demo2实现耳返+伴奏播放</a></p>
<h4 id="下面我分享一个变声中混响效果代码"><a href="#下面我分享一个变声中混响效果代码" class="headerlink" title="下面我分享一个变声中混响效果代码"></a>下面我分享一个变声中混响效果代码</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//声明部分  .h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KSYAudioReverbFilter</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"></div><div class="line">-(<span class="keyword">instancetype</span>)init;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setupWithAUGraph:(AUGraph)auGraph asbd:(<span class="keyword">const</span> AudioStreamBasicDescription *)asbd maxFrame:(<span class="built_in">CMItemCount</span>)max;</div><div class="line"></div><div class="line"><span class="comment">// Global, CrossFade, 0-&gt;100, 100</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> dryWetMix;</div><div class="line"><span class="comment">// Global, Decibels, -20-&gt;20, 0dB.</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> gain;</div><div class="line"><span class="comment">// Global, Secs, 0.0001-&gt;1.0, 0.008</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> minDelayTime;</div><div class="line"><span class="comment">// Global, Secs, 0.0001-&gt;1.0, 0.050</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> maxDelayTime;</div><div class="line"><span class="comment">// Global, Secs, 0.001-&gt;20.0, 1.0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> decayTimeAt0Hz;</div><div class="line"><span class="comment">// Global, Secs, 0.001-&gt;20.0, 0.5</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> decayTimeAtNyquist;</div><div class="line"><span class="comment">// Global, Integer, 1-&gt;1000, 1</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> randomizeReflections;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//实现部分</span></div><div class="line"></div><div class="line"><span class="comment">//通用的宏</span></div><div class="line"><span class="meta">#define RC_CHECK(rc, str) if (rc != noErr) \</span></div><div class="line">&#123; \</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Err :%@ %@ %@"</span>, @(rc), str, @(__func__)); \</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KSYAudioReverbFilter</span></span></div><div class="line"></div><div class="line">-(<span class="keyword">instancetype</span>)init&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)&#123;</div><div class="line">        <span class="keyword">self</span>.acDes = (AudioComponentDescription)&#123;kAudioUnitType_Effect, kAudioUnitSubType_Reverb2, kAudioUnitManufacturer_Apple, <span class="number">0</span>, <span class="number">0</span>&#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setupWithAUGraph:(AUGraph)auGraph asbd:(<span class="keyword">const</span> AudioStreamBasicDescription *)asbd maxFrame:(<span class="built_in">CMItemCount</span>)maxFrame</div><div class="line">&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">    OSStatus status = noErr;</div><div class="line">    <span class="built_in">NSAssert</span>(auGraph != <span class="literal">nil</span>, <span class="string">@"auGraph is null"</span>);</div><div class="line">    audioGraph = auGraph;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"setup :%@"</span>, <span class="built_in">NSStringFromCode</span>(_acDes.componentSubType));</div><div class="line">    status = AUGraphAddNode(auGraph, &amp;_acDes, &amp;_node);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (noErr != status)&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSString</span> *error = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"add node with type %u failed"</span>, _acDes.componentType];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    status = AUGraphNodeInfo(auGraph, _node, <span class="literal">NULL</span>, &amp;_audioUnit);</div><div class="line">    <span class="keyword">if</span> (noErr != status)&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"create audiouinit failed err:%@"</span>, @(status));</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    RC_CHECK(AudioUnitSetProperty(_audioUnit,</div><div class="line">                                  kAudioUnitProperty_StreamFormat,</div><div class="line">                                  kAudioUnitScope_Input, <span class="number">0</span>, asbd, <span class="keyword">sizeof</span>(AudioStreamBasicDescription)),</div><div class="line">             <span class="string">@"kAudioUnitProperty_StreamFormat kAudioUnitScope_Input err"</span>);</div><div class="line">    </div><div class="line">    RC_CHECK(AudioUnitSetProperty(_audioUnit,</div><div class="line">                                  kAudioUnitProperty_StreamFormat,</div><div class="line">                                  kAudioUnitScope_Output, <span class="number">0</span>, asbd, <span class="keyword">sizeof</span>(AudioStreamBasicDescription)),</div><div class="line">             <span class="string">@"kAudioUnitProperty_StreamFormat kAudioUnitScope_Output err"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// Set audio unit maximum frames per slice to max frames.</span></div><div class="line">    RC_CHECK(AudioUnitSetProperty(_audioUnit,</div><div class="line">                                  kAudioUnitProperty_MaximumFramesPerSlice,</div><div class="line">                                  kAudioUnitScope_Global, <span class="number">0</span>, &amp;maxFrame, (<span class="built_in">UInt32</span>)<span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>)),</div><div class="line">             <span class="string">@"set kAudioUnitProperty_MaximumFramesPerSlice err"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Setters</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setDryWetMix:(<span class="keyword">double</span>)dryWetMix</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_DryWetMix value:dryWetMix];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setGain:(<span class="keyword">double</span>)gain</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_Gain value:gain];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setMinDelayTime:(<span class="keyword">double</span>)minDelayTime</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_MinDelayTime value:minDelayTime];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setMaxDelayTime:(<span class="keyword">double</span>)maxDelayTime</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_MaxDelayTime value:maxDelayTime];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setDecayTimeAt0Hz:(<span class="keyword">double</span>)decayTimeAt0Hz</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_DecayTimeAt0Hz value:decayTimeAt0Hz];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setDecayTimeAtNyquist:(<span class="keyword">double</span>)decayTimeAtNyquist</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_DecayTimeAtNyquist value:decayTimeAtNyquist];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setRandomizeReflections:(<span class="keyword">double</span>)randomizeReflections</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_RandomizeReflections value:randomizeReflections];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//通用方法</span></div><div class="line">- (<span class="keyword">void</span>)setGlobalParam:(AudioUnitParameterID)paramId value:(AudioUnitParameterValue)value</div><div class="line">&#123;</div><div class="line"></div><div class="line">    RC_CHECK(AudioUnitSetParameter(_audioUnit,</div><div class="line">                                   paramId,</div><div class="line">                                   kAudioUnitScope_Global, <span class="number">0</span>, value, <span class="number">0</span>),</div><div class="line">             ([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set %u value %f err"</span>, paramId, value]));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>外部调用的话就是这样的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AURenderCallbackStruct renderCallbackStruct;</div><div class="line">renderCallbackStruct.inputProc = ksyme_RenderCallback;</div><div class="line">renderCallbackStruct.inputProcRefCon = (<span class="keyword">void</span> *)<span class="keyword">self</span>.apt;</div><div class="line">    </div><div class="line"><span class="keyword">if</span> (!_reverbFilter)&#123;</div><div class="line">    _reverbFilter = [[KSYAudioReverbFilter alloc] init];</div><div class="line">    [_reverbFilter setupWithAUGraph:auGraph asbd:format maxFrame:max];</div><div class="line">    _reverbFilter.renderCallBack = renderCallbackStruct;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="连接node"><a href="#连接node" class="headerlink" title="连接node"></a>连接node</h3><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AUGraphClearConnections(auGraph);</div><div class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">[array addObject:@(_mixFilter.node)];</div><div class="line"></div><div class="line">[array addObjectsFromArray:@[@(_reverbFilter.node),@(_delayFilter.node),@(_pitchFilter.node)]];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.count <span class="number">-1</span>; i++) &#123;</div><div class="line">    AUGraphConnectNodeInput(auGraph,[array[i] intValue], <span class="number">0</span>,[array[i+<span class="number">1</span>] intValue], <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心代码就是如何连接Node</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AUGraphConnectNodeInput(auGraph,reverbNode, <span class="number">0</span>, remoteIONode, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>0代表 bus0</p>
</blockquote>
<p>系统定义的API是这样的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">extern</span> OSStatus</div><div class="line">AUGraphConnectNodeInput(	AUGraph			inGraph,</div><div class="line">						AUNode			inSourceNode,</div><div class="line">						<span class="built_in">UInt32</span>			inSourceOutputNumber,</div><div class="line">						AUNode			inDestNode,</div><div class="line">						<span class="built_in">UInt32</span>			inDestInputNumber)		__OSX_AVAILABLE_STARTING(__MAC_10_0,__IPHONE_2_0);</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Audio Unit的相关技术学习点比较多大家灵活掌握运用,不懂没关系从简单的Unit开始学起.</p>
<p>全文完</p>
<p>参考列表:<br><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Reference/CoreAudioGlossary/Glossary/core_audio_glossary.html#//apple_ref/doc/uid/TP40004453-CH210-SW1" target="_blank" rel="external">iOS Audio相关术语(Glossary)</a><br><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/Introduction/Introduction.html" target="_blank" rel="external">参考</a><br><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitProgrammingGuide/Tutorial-BuildingASimpleEffectUnitWithAGenericView/Tutorial-BuildingASimpleEffectUnitWithAGenericView.html#//apple_ref/doc/uid/TP40003278-CH5-SW4" target="_blank" rel="external">如何自己制作一个Audio Unit</a><br><a href="https://www.jianshu.com/p/05cae433faea" target="_blank" rel="external">金山云直播音效实现</a><br><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/AudioUnitHostingFundamentals/AudioUnitHostingFundamentals.html#//apple_ref/doc/uid/TP40009492-CH3-SW12" target="_blank" rel="external">Audio Unit官方文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180430AudioEffectImplement/au_host_app1.jpg
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解RunLoop</title>
    <link href="https://www.sunyazhou.com/2018/04/02/20180402RunLoop/"/>
    <id>https://www.sunyazhou.com/2018/04/02/20180402RunLoop/</id>
    <published>2018-04-02T06:16:34.000Z</published>
    <updated>2018-05-07T07:06:41.933Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/0fa4569bca7b3a2d5c1ee360f47ac1dd213ecbac/20180402RunLoop/runloop6.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>RunLoop</code> 是 <code>iOS</code> 和 <code>OSX</code> 开发中非常基础的一个概念，这篇文章将从<code>CFRunLoop</code>的源码入手，介绍 <code>RunLoop</code> 的概念以及底层实现原理。之后会介绍一下在 <code>iOS</code> 中，苹果是如何利用<code>RunLoop</code>实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p>
<h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><ul>
<li>RunLoop 的概念</li>
<li>RunLoop 与线程的关系</li>
<li>RunLoop 对外的接口</li>
<li>RunLoop 的 Mode</li>
<li>RunLoop 的内部逻辑</li>
<li>RunLoop 的底层实现</li>
<li>苹果用 RunLoop 实现的功能<ol>
<li>AutoreleasePool</li>
<li>事件响应</li>
<li>手势识别</li>
<li>界面更新</li>
<li>定时器</li>
<li>PerformSelecter</li>
<li>关于GCD</li>
<li>关于网络请求</li>
</ol>
</li>
<li>RunLoop 的实际应用举例<ol>
<li>AFNetworking</li>
<li>AsyncDisplayKit</li>
</ol>
</li>
</ul>
<h3 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h3><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">function loop() &#123;</div><div class="line">    initialize();</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">var</span> message = get_next_message();</div><div class="line">        process_message(message);</div><div class="line">    &#125; <span class="keyword">while</span> (message != quit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种模型通常被称作 <a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event Loop</a>。 <code>Event Loop</code> 在很多系统和框架里都有实现，比如 <code>Node.js</code>的事件处理，比如 <code>Windows</code> 程序的消息循环，再比如 <code>OSX/iOS</code> 里的 <code>RunLoop</code>。实现这种模型的关键点在于：如何<code>管理事件/消息</code>，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
<p>所以，<code>RunLoop</code> 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 <code>Event Loop</code> 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “<code>接受消息</code>-&gt;<code>等待-&gt;</code>处理<code>” 的循环中，直到这个循环结束（比如传入</code>quit` 的消息），函数返回。</p>
<p><code>OSX/iOS</code> 系统中，提供了两个这样的对象：<code>NSRunLoop</code> 和 <code>CFRunLoopRef</code>。  </p>
<p><code>CFRunLoopRef</code> 是在 <code>CoreFoundation</code> 框架内的，它提供了纯 <code>C</code> 函数的 <code>API</code>，所有这些 <code>API</code> 都是线程安全的。  </p>
<p><code>NSRunLoop</code> 是基于 <code>CFRunLoopRef</code> 的封装，提供了面向对象的 <code>API</code>，但是这些 <code>API</code> 不是线程安全的。  </p>
<p>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c" target="_blank" rel="external">开源</a>的，你可以在这里 <a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">http://opensource.apple.com/tarballs/CF/</a> 下载到整个 <code>CoreFoundation</code> 的源码来查看。</p>
<p>(Update: Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：<a href="https://github.com/apple/swift-corelibs-foundation/" target="_blank" rel="external">https://github.com/apple/swift-corelibs-foundation/</a>，这个版本的源码可能和现有<code>iOS</code>系统中的实现略不一样，但更容易编译，而且已经适配了<code>Linux/Windows</code>。)</p>
<h3 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h3><p>首先，<code>iOS</code> 开发中能遇到两个线程对象: <code>pthread_t</code> 和 <code>NSThread</code>。过去苹果有份文档标明了 <code>NSThread</code> 只是 <code>pthread_t</code> 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 <code>mach thread</code>。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 <code>pthread_t</code> 和 <code>NSThread</code> 是一一对应的。比如，你可以通过 <code>pthread_main_thread_np()</code> 或 <code>[NSThread mainThread]</code> 来获取主线程；也可以通过 <code>pthread_self()</code> 或 <code>[NSThread currentThread]</code> 来获取当前线程。<code>CFRunLoop</code> 是基于 <code>pthread</code> 来管理的。</p>
<p>苹果不允许直接创建 <code>RunLoop</code>，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> 和 <code>CFRunLoopGetCurrent()</code>。 这两个函数内部的逻辑大概是下面这样:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></div><div class="line"><span class="keyword">static</span> CFMutableDictionaryRef loopsDic;</div><div class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></div><div class="line"><span class="keyword">static</span> CFSpinLock_t loopsLock;</div><div class="line"> </div><div class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></div><div class="line">CFRunLoopRef _CFRunLoopGet(<span class="keyword">pthread_t</span> thread) &#123;</div><div class="line">    OSSpinLockLock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</div><div class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></div><div class="line">        loopsDic = CFDictionaryCreateMutable();</div><div class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</div><div class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></div><div class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!loop) &#123;</div><div class="line">        <span class="comment">/// 取不到时，创建一个</span></div><div class="line">        loop = _CFRunLoopCreate();</div><div class="line">        CFDictionarySetValue(loopsDic, thread, loop);</div><div class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></div><div class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    OSSpinLockUnLock(&amp;loopsLock);</div><div class="line">    <span class="keyword">return</span> loop;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和<code>RunLoop</code>之间是一一对应的，其关系是保存在一个全局的 <code>Dictionary</code> 里。线程刚创建时并没有 <code>RunLoop</code>，如果你不主动获取，那它一直都不会有。<code>RunLoop</code> 的创建是发生在第一次获取时，<code>RunLoop</code> 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 <code>RunLoop</code>（主线程除外）.</p>
<h3 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h3><p>在 <code>CoreFoundation</code> 里面关于 <code>RunLoop</code> 有5个类:</p>
<ul>
<li><code>CFRunLoopRef</code></li>
<li><code>CFRunLoopModeRef</code></li>
<li><code>CFRunLoopSourceRef</code></li>
<li><code>CFRunLoopTimerRef</code></li>
<li><code>CFRunLoopObserverRef</code></li>
</ul>
<p>其中 <code>CFRunLoopModeRef</code> 类并没有对外暴露，只是通过 <code>CFRunLoopRef</code> 的接口进行了封装。他们的关系如下:</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_0.png" alt=""></p>
<p>一个 <code>RunLoop</code> 包含若干个 <code>Mode</code>，每个 <code>Mode</code>又包含若干个 <code>Source</code>/<code>Timer</code>/<code>Observer</code>。每次调用 <code>RunLoop</code> 的主函数时，只能指定其中一个 <code>Mode</code>，这个<code>Mode</code>被称作 <code>CurrentMode</code>。如果需要切换 <code>Mode</code>，只能退出 <code>Loop</code>，再重新指定一个 <code>Mode</code> 进入。这样做主要是为了分隔开不同组的 <code>Source</code>/<code>Timer</code>/<code>Observer</code>，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。<code>Source</code>有两个版本：<code>Source0</code> 和 <code>Source1</code>。</p>
<ul>
<li><code>Source0</code> 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 <code>Source</code> 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 <code>RunLoop</code>，让其处理这个事件。  </li>
<li><code>Source1</code> 包含了一个 <code>mach_port</code> 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 <code>Source</code> 能主动唤醒 <code>RunLoop</code> 的线程，其原理在下面会讲到。</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 <code>NSTimer</code> 是<code>toll-free bridged</code>的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 <code>RunLoop</code> 时，<code>RunLoop</code>会注册对应的时间点，当时间点到时，<code>RunLoop</code>会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 <code>Observer</code> 都包含了一个回调（函数指针），当 <code>RunLoop</code> 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</div><div class="line">    kCFRunLoopEntry         = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></div><div class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></div><div class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></div><div class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></div><div class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></div><div class="line">    kCFRunLoopExit          = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的 <code>Source</code>/<code>Timer</code>/<code>Observer</code> 被统称为 <code>__mode item__</code>，一个 <code>item</code> 可以被同时加入多个<code>mode</code>。但一个 <code>item</code> 被重复加入同一个 <code>mode</code> 时是不会有效果的。如果一个 <code>mode</code> 中一个 <code>item</code> 都没有，则 <code>RunLoop</code> 会直接退出，不进入循环。</p>
<h3 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h3><p><code>CFRunLoopMode</code> 和 <code>CFRunLoop</code> 的结构大致如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</div><div class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></div><div class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></div><div class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></div><div class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></div><div class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</div><div class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></div><div class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></div><div class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></div><div class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里有个概念叫 “<code>CommonModes</code>”：一个 <code>Mode</code> 可以将自己标记为”<code>Common</code>”属性（通过将其 <code>ModeName</code> 添加到 <code>RunLoop</code> 的 “<code>commonModes</code>” 中）。每当 <code>RunLoop</code> 的内容发生变化时，<code>RunLoop</code> 都会自动将 <code>_commonModeItems</code> 里的 <code>Source</code>/<code>Observer</code>/<code>Timer</code>同步到具有 “<code>Common</code>” 标记的所有<code>Mode</code>里。</p>
<p>应用场景举例：主线程的 <code>RunLoop</code> 里有两个预置的 <code>Mode</code>：<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>。这两个 <code>Mode</code> 都已经被标记为”<code>Common</code>”属性。<code>DefaultMode</code> 是 <code>App</code> 平时所处的状态，<code>TrackingRunLoopMode</code> 是追踪 <code>ScrollView</code>滑动时的状态。当你创建一个<code>Timer</code>并加到 <code>DefaultMode</code> 时，<code>Timer</code> 会得到重复回调，但此时滑动一个<code>TableView</code>时，<code>RunLoop</code> 会将 <code>mode</code> 切换为 <code>TrackingRunLoopMode</code>，这时 <code>Timer</code> 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个<code>Timer</code>，在两个 <code>Mode</code> 中都能得到回调，一种办法就是将这个 <code>Timer</code> 分别加入这两个 <code>Mode</code>。还有一种方式，就是将 <code>Timer</code> 加入到顶层的 <code>RunLoop</code> 的 “<code>commonModeItems</code>” 中。”<code>commonModeItems</code>” 被 <code>RunLoop</code> 自动更新到所有具有”<code>Common</code>”属性的 <code>Mode</code> 里去。</p>
<p><code>CFRunLoop</code>对外暴露的管理 <code>Mode</code> 接口只有下面2个:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</div><div class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</div></pre></td></tr></table></figure>
<p><code>Mode</code> 暴露的管理 <code>mode item</code> 的接口有下面几个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div><div class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div></pre></td></tr></table></figure>
<p>你只能通过 <code>mode name</code> 来操作内部的 <code>mode</code>，当你传入一个新的 <code>mode name</code> 但 <code>RunLoop</code> 内部没有对应 <code>mode</code> 时，<code>RunLoop</code>会自动帮你创建对应的 <code>CFRunLoopModeRef</code>。对于一个 <code>RunLoop</code> 来说，其内部的 <code>mode</code> 只能增加不能删除。</p>
<p>苹果公开提供的 <code>Mode</code> 有两个：<code>kCFRunLoopDefaultMode</code> (<code>NSDefaultRunLoopMode</code>) 和 <code>UITrackingRunLoopMode</code>，你可以用这两个 <code>Mode Name</code> 来操作其对应的<code>Mode</code>。</p>
<p>同时苹果还提供了一个操作 <code>Common</code> 标记的字符串：<code>kCFRunLoopCommonModes</code> (<code>NSRunLoopCommonModes</code>)，你可以用这个字符串来操作 <code>Common Items</code>，或标记一个 <code>Mode</code> 为 “<code>Common</code>”。使用时注意区分这个字符串和其他 <code>mode name</code>。</p>
<h3 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h3><p>根据苹果在<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="external">文档</a>里的说明，<code>RunLoop</code> 内部的逻辑大致如下:</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_1.png" alt=""></p>
<p>其内部代码整理如下 (太长了不想看可以直接跳过去，后面会有说明)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// 用DefaultMode启动</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/// RunLoop的实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunSpecific</span><span class="params">(runloop, modeName, seconds, stopAfterHandle)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</div><div class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></div><div class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></div><div class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</div><div class="line">    </div><div class="line">    <span class="comment">/// 内部函数，进入loop</span></div><div class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</div><div class="line">        </div><div class="line">        Boolean sourceHandledThisLoop = NO;</div><div class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line"> </div><div class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</div><div class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</div><div class="line">            <span class="comment">/// 执行被加入的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line">            </div><div class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></div><div class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</div><div class="line">            <span class="comment">/// 执行被加入的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line"> </div><div class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></div><div class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</div><div class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</div><div class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></div><div class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</div><div class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></div><div class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></div><div class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></div><div class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></div><div class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</div><div class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</div><div class="line">            </div><div class="line">            <span class="comment">/// 收到消息，处理消息。</span></div><div class="line">            handle_msg:</div><div class="line"> </div><div class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></div><div class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</div><div class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</div><div class="line">            &#125; </div><div class="line"> </div><div class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</div><div class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            &#125; </div><div class="line"> </div><div class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</div><div class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</div><div class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 执行加入到Loop的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line">            </div><div class="line"> </div><div class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></div><div class="line">                retVal = kCFRunLoopRunHandledSource;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</div><div class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></div><div class="line">                retVal = kCFRunLoopRunTimedOut;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</div><div class="line">                <span class="comment">/// 被外部调用者强制停止了</span></div><div class="line">                retVal = kCFRunLoopRunStopped;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</div><div class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></div><div class="line">                retVal = kCFRunLoopRunFinished;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></div><div class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></div><div class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h3><p>从上面代码可以看到，<code>RunLoop</code> 的核心是基于 <code>mach port</code> 的，其进入休眠时调用的函数是 <code>mach_msg()</code>。为了解释这个逻辑，下面稍微介绍一下 <code>OSX/iOS</code> 的系统架构。</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_3.png" alt=""></p>
<p>苹果官方将整个系统大致划分为上述4个层次：<br>应用层包括用户能接触到的图形应用，例如 <code>Spotlight</code>、<code>Aqua</code>、<code>SpringBoard</code> 等。<br>应用框架层即开发人员接触到的 <code>Cocoa</code>等框架。<br>核心框架层包括各种核心框架、<code>OpenGL</code> 等内容。<br><code>Darwin</code> 即操作系统的核心，包括系统内核、驱动、<code>Shell</code> 等内容，这一层是开源的，其所有源码都可以在 <a href="https://opensource.apple.com/" target="_blank" rel="external">opensource.apple.com</a> 里找到。</p>
<p><strong>我们在深入看一下 Darwin 这个核心的架构：</strong></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_4.png" alt=""></p>
<p>其中，在硬件层上面的三个组成部分：<code>Mach</code>、<code>BSD</code>、<code>IOKit</code> (还包括一些上面没标注的内容)，共同组成了 <code>XNU</code> 内核。<br><code>XNU</code> 内核的内环被称作 <code>Mach</code>，其作为一个微内核，仅提供了诸如处理器调度、<code>IPC</code> (进程间通信)等非常少量的基础服务。<br><code>BSD</code> 层可以看作围绕 <code>Mach</code> 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。<br><code>IOKit</code> 层是为设备驱动提供了一个面向对象(<code>C++</code>)的一个框架。</p>
<p><code>Mach</code> 本身提供的 <code>API</code> 非常有限，而且苹果也不鼓励使用 <code>Mach</code> 的 <code>API</code>，但是这些<code>API</code>非常基础，如果没有这些<code>API</code>的话，其他任何工作都无法实施。在 <code>Mach</code> 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， <code>Mach</code> 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”<code>消息</code>”是 <code>Mach</code> 中最基础的概念，消息在两个端口 (<code>port</code>) 之间传递，这就是 <code>Mach</code> 的 <code>IPC</code> (进程间通信) 的核心。</p>
<p><code>Mach</code> 的消息定义是在 <code>&lt;mach/message.h&gt;</code> 头文件的，很简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">  <span class="keyword">mach_msg_header_t</span> header;</div><div class="line">  <span class="keyword">mach_msg_body_t</span> body;</div><div class="line">&#125; <span class="keyword">mach_msg_base_t</span>;</div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">  <span class="keyword">mach_msg_bits_t</span> msgh_bits;</div><div class="line">  <span class="keyword">mach_msg_size_t</span> msgh_size;</div><div class="line">  <span class="keyword">mach_port_t</span> msgh_remote_port;</div><div class="line">  <span class="keyword">mach_port_t</span> msgh_local_port;</div><div class="line">  <span class="keyword">mach_port_name_t</span> msgh_voucher_port;</div><div class="line">  <span class="keyword">mach_msg_id_t</span> msgh_id;</div><div class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</div></pre></td></tr></table></figure>
<p>一条 <code>Mach</code> 消息实际上就是一个二进制数据包 (<code>BLOB</code>)，其头部定义了当前端口 <code>local_port</code> 和目标端口 <code>remote_port</code>，发送和接受消息是通过同一个 <code>API</code> 进行的，其 <code>option</code> 标记了消息传递的方向：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">mach_msg_return_t</span> mach_msg(</div><div class="line">			<span class="keyword">mach_msg_header_t</span> *msg,</div><div class="line">			<span class="keyword">mach_msg_option_t</span> option,</div><div class="line">			<span class="keyword">mach_msg_size_t</span> send_size,</div><div class="line">			<span class="keyword">mach_msg_size_t</span> rcv_size,</div><div class="line">			<span class="keyword">mach_port_name_t</span> rcv_name,</div><div class="line">			<span class="keyword">mach_msg_timeout_t</span> timeout,</div><div class="line">			<span class="keyword">mach_port_name_t</span> notify);</div></pre></td></tr></table></figure>
<p>为了实现消息的发送和接收，<code>mach_msg()</code> 函数实际上是调用了一个 <code>Mach</code> 陷阱 <code>(trap)</code>，即函数<code>mach_msg_trap()</code>，陷阱这个概念在 <code>Mach</code> 中等同于系统调用。当你在用户态调用<code>mach_msg_trap()</code> 时会触发陷阱机制，切换到内核态；内核态中内核实现的 <code>mach_msg()</code> 函数会完成实际的工作，如下图：</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_5.png" alt=""></p>
<p>这些概念可以参考维基百科: <a href="http://en.wikipedia.org/wiki/System_call" target="_blank" rel="external">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing" target="_blank" rel="external">Trap_(computing)</a>)。</p>
<p><code>RunLoop</code> 的核心就是一个 <code>mach_msg()</code> (见上面代码的第7步)，<code>RunLoop</code> 调用这个函数去接收消息，如果没有别人发送 <code>port</code> 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 <code>iOS</code> 的 <code>App</code>，然后在 <code>App</code> 静止时点击暂停，你会看到主线程调用栈是停留在 <code>mach_msg_trap()</code> 这个地方。</p>
<p>关于具体的如何利用 <code>mach port</code> 发送信息，可以看看 <a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="external">NSHipster 这一篇文章</a>，或者<a href="http://segmentfault.com/a/1190000002400329" target="_blank" rel="external">这里</a>的中文翻译.</p>
<p>关于<code>Mach</code>的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/" target="_blank" rel="external">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>
<h3 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h3><p>首先我们可以看一下<code>App</code>启动后<code>RunLoop</code>的状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">CFRunLoop &#123;</div><div class="line">    current mode = kCFRunLoopDefaultMode</div><div class="line">    common modes = &#123;</div><div class="line">        UITrackingRunLoopMode</div><div class="line">        kCFRunLoopDefaultMode</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    common mode items = &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// source0 (manual)</span></div><div class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = PurpleEventSignalCallback &#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</div><div class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// source1 (mach port)</span></div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = PurpleEventCallback&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</div><div class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</div><div class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1b</span>03,</div><div class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</div><div class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// Ovserver</span></div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></div><div class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></div><div class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _afterCACommitHandler&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// Timer</span></div><div class="line">        CFRunLoopTimer &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</div><div class="line">            next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</div><div class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</div><div class="line">    &#125;,</div><div class="line"> </div><div class="line">    modes ＝ &#123;</div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 = &#123;</div><div class="line">                CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</div><div class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            sources1 = (null),</div><div class="line">            observers = &#123;</div><div class="line">                CFRunLoopObserver &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</div><div class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</div><div class="line">            )&#125;,</div><div class="line">            timers = (null),</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 = &#123;</div><div class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</div><div class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            sources1 = &#123;</div><div class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</div><div class="line">                    callout = PurpleEventCallback&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            observers = (null),</div><div class="line">            timers = (null),</div><div class="line">        &#125;,</div><div class="line">        </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 = (null),</div><div class="line">            sources1 = (null),</div><div class="line">            observers = (null),</div><div class="line">            timers = (null),</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，系统默认注册了5个`Mode:</p>
<ol>
<li><code>kCFRunLoopDefaultMode</code>: <code>App</code>的默认 <code>Mode</code>，通常主线程是在这个 <code>Mode</code> 下运行的。</li>
<li><code>UITrackingRunLoopMode</code>: 界面跟踪 <code>Mode</code>，用于 <code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他 <code>Mode</code> 影响。</li>
<li><code>UIInitializationRunLoopMode</code>: 在刚启动 <code>App</code> 时第进入的第一个 <code>Mode</code>，启动完成后就不再使用。</li>
<li><code>GSEventReceiveRunLoopMode</code>: 接受系统事件的内部 <code>Mode</code>，通常用不到。</li>
<li><code>kCFRunLoopCommonModes</code>: 这是一个占位的 <code>Mode</code>，没有实际作用。</li>
</ol>
<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="external">这里</a>看到更多的苹果内部的 <code>Mode</code>，但那些 <code>Mode</code> 在开发中就很难遇到了。</p>
<p>当 <code>RunLoop</code> 进行回调时，一般都是通过一个很长的函数调用出去 (<code>call out</code>), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">/// 1. 通知Observers，即将进入RunLoop</span></div><div class="line">    <span class="comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></div><div class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line"> </div><div class="line">        <span class="comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</div><div class="line">        <span class="comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line"> </div><div class="line">        <span class="comment">/// 4. 触发 Source0 (非基于port的) 回调。</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line"> </div><div class="line">        <span class="comment">/// 6. 通知Observers，即将进入休眠</span></div><div class="line">        <span class="comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</div><div class="line"> </div><div class="line">        <span class="comment">/// 7. sleep to wait msg.</span></div><div class="line">        mach_msg() -&gt; mach_msg_trap();</div><div class="line">        </div><div class="line"> </div><div class="line">        <span class="comment">/// 8. 通知Observers，线程被唤醒</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</div><div class="line"> </div><div class="line">        <span class="comment">/// 9. 如果是被Timer唤醒的，回调Timer</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</div><div class="line"> </div><div class="line">        <span class="comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></div><div class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</div><div class="line"> </div><div class="line">        <span class="comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</div><div class="line"> </div><div class="line"> </div><div class="line">    &#125; <span class="keyword">while</span> (...);</div><div class="line"> </div><div class="line">    <span class="comment">/// 10. 通知Observers，即将退出RunLoop</span></div><div class="line">    <span class="comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></div><div class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>App启动后，苹果在主线程 <code>RunLoop</code> 里注册了两个 <code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<p>第一个 <code>Observer</code> 监视的事件是 <code>Entry</code>(即将进入<code>Loop</code>)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 <code>order</code> 是<code>-2147483647</code>，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 <code>Observer</code> 监视了两个事件： <code>BeforeWaiting</code>(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；<code>Exit</code>(即将退出<code>Loop</code>) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 <code>Observer</code> 的 <code>order</code> 是 <code>2147483647</code>，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、<code>Timer</code>回调内的。这些回调会被 <code>RunLoop</code> 创建好的 <code>AutoreleasePool</code> 环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>Pool</code> 了。</p>
<h4 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h4><p>苹果注册了一个 <code>Source1</code> (基于 <code>mach port</code> 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 <code>IOHIDEvent</code> 事件并由 <code>SpringBoard</code> 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="external">这里</a>。<code>SpringBoard</code> 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 <code>Event</code>，随后用 <code>mach port</code> 转发给需要的<code>App</code>进程。随后苹果注册的那个 <code>Source1</code> 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p>
<p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent</code> 处理并包装成 <code>UIEvent</code> 进行处理或分发，其中包括识别 <code>UIGesture</code>/<code>处理屏幕旋转</code>/发送给 <code>UIWindow</code> 等。通常事件比如 <code>UIButton</code> 点击、<code>touchesBegin</code>/<code>Move</code>/<code>End</code>/<code>Cancel</code> 事件都是在这个回调中完成的。</p>
<h4 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h4><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 <code>Cancel</code> 将当前的 <code>touchesBegin</code>/<code>Move</code>/<code>End</code> 系列回调打断。随后系统将对应的 <code>UIGestureRecognizer</code> 标记为待处理。</p>
<p>苹果注册了一个 <code>Observer</code> 监测 <code>BeforeWaiting</code> (<code>Loop</code>即将进入休眠) 事件，这个<code>Observer</code>的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 <code>GestureRecognizer</code>，并执行<code>GestureRecognizer</code>的回调。</p>
<p>当有 <code>UIGestureRecognizer</code> 的变化(<code>创建</code>/<code>销毁</code>/<code>状态改变</code>)时，这个回调都会进行相应处理。</p>
<h4 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h4><p>当在操作 <code>UI</code> 时，比如改变了 <code>Frame</code>、更新了 <code>UIView</code>/<code>CALayer</code> 的层次时，或者手动调用了 <code>UIView</code>/<code>CALayer</code> 的 <code>setNeedsLayout</code>/<code>setNeedsDisplay</code>方法后，这个 <code>UIView</code>/<code>CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 <code>Observer</code> 监听 <code>BeforeWaiting</code>(即将进入休眠) 和 <code>Exit</code> (即将退出<code>Loop</code>) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 <code>UIView</code>/<code>CAlayer</code> 以执行实际的绘制和调整，并更新 <code>UI</code> 界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</div><div class="line">    QuartzCore:CA::Transaction::observer_callback:</div><div class="line">        CA::Transaction::commit();</div><div class="line">            CA::Context::commit_transaction();</div><div class="line">                CA::Layer::layout_and_display_if_needed();</div><div class="line">                    CA::Layer::layout_if_needed();</div><div class="line">                        [CALayer layoutSublayers];</div><div class="line">                            [UIView layoutSubviews];</div><div class="line">                    CA::Layer::display_if_needed();</div><div class="line">                        [CALayer display];</div><div class="line">                            [UIView drawRect];</div></pre></td></tr></table></figure>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p><code>NSTimer</code> 其实就是 <code>CFRunLoopTimerRef</code>，他们之间是 <code>toll-free bridged</code> 的。一个 <code>NSTimer</code> 注册到 <code>RunLoop</code> 后，<code>RunLoop</code> 会为其重复的时间点注册好事件。例如 <code>10:00</code>, <code>10:10</code>, <code>10:20</code> 这几个时间点。<code>RunLoop</code>为了节省资源，并不会在非常准确的时间点回调这个<code>Timer</code>。<code>Timer</code> 有个属性叫做 <code>Tolerance</code> (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 <code>10:10</code> 时我忙着玩手机错过了那个点的公交，那我只能等 <code>10:20</code> 这一趟了。</p>
<p><code>CADisplayLink</code> 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 <code>NSTimer</code> 并不一样，其内部实际是操作了一个 <code>Source</code>）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 <code>NSTimer</code> 相似），造成界面卡顿的感觉。在快速滑动<code>TableView</code>时，即使一帧的卡顿也会让用户有所察觉。<code>Facebook</code> 开源的<code>AsyncDisplayLink</code> 就是为了解决界面卡顿的问题，其内部也用到了 <code>RunLoop</code>，这个稍后我会再单独写一页博客来分析。</p>
<h4 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h4><p>当调用 <code>NSObject</code> 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 <code>Timer</code> 并添加到当前线程的 <code>RunLoop</code> 中。所以如果当前线程没有 <code>RunLoop</code>，则这个方法会失效。</p>
<p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 <code>Timer</code> 加到对应的线程去，同样的，如果对应线程没有 <code>RunLoop</code> 该方法也会失效。</p>
<h4 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h4><p>实际上 <code>RunLoop</code> 底层也会用到 GCD 的东西， 例如 <code>dispatch_async()</code>。</p>
<blockquote>
<p>NSTimer 是用了 XNU 内核的 <code>mk_timer</code>来驱动的，而非 GCD 驱动的.</p>
</blockquote>
<p>当调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code> 时，<code>libDispatch</code> 会向主线程的 <code>RunLoop</code> 发送消息，RunLoop会被唤醒，并从消息中取得这个 <code>block</code>，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 <code>block</code>。但这个逻辑仅限于 <code>dispatch</code> 到主线程，<code>dispatch</code> 到其他线程仍然是由 <code>libDispatch</code> 处理的。</p>
<h4 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h4><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">CFSocket</div><div class="line">CFNetwork       -&gt;ASIHttpRequest</div><div class="line">NSURLConnection -&gt;AFNetworking</div><div class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</div></pre></td></tr></table></figure>
<ul>
<li><code>CFSocket</code> 是最底层的接口，只负责 <code>socket</code> 通信。</li>
<li><code>CFNetwork</code> 是基于 <code>CFSocket</code> 等接口的上层封装，<code>ASIHttpRequest</code> 工作于这一层。</li>
<li><code>NSURLConnection</code> 是基于 <code>CFNetwork</code> 的更高层的封装，提供面向对象的接口，<code>AFNetworking</code>工作于这一层。</li>
<li><code>NSURLSession</code> 是 <code>iOS7</code> 中新增的接口，表面上是和 <code>NSURLConnection</code>并列的，但底层仍然用到了 <code>NSURLConnection</code> 的部分功能 (比如 <code>com.apple.NSURLConnectionLoader</code> 线程)，<code>AFNetworking2</code> 和 <code>Alamofire</code> 工作于这一层。</li>
</ul>
<h5 id="下面主要介绍下-NSURLConnection-的工作过程。"><a href="#下面主要介绍下-NSURLConnection-的工作过程。" class="headerlink" title="下面主要介绍下 NSURLConnection 的工作过程。"></a>下面主要介绍下 NSURLConnection 的工作过程。</h5><p>通常使用 <code>NSURLConnection</code>时，你会传入一个 <code>Delegate</code>，当调用了 <code>[connection start]</code> 后，这个 <code>Delegate</code> 就会不停收到事件回调。实际上，<code>start</code> 这个函数的内部会会获取 <code>CurrentRunLoop</code>，然后在其中的 <code>DefaultMode</code> 添加了4个 <code>Source0</code>(即需要手动触发的<code>Source</code>)。<code>CFMultiplexerSource</code> 是负责各种 <code>Delegate</code> 回调的，<code>CFHTTPCookieStorage</code> 是处理各种 <code>Cookie</code> 的。</p>
<p>当开始网络传输时，我们可以看到 <code>NSURLConnection</code> 创建了两个新线程：<code>com.apple.NSURLConnectionLoader</code> 和 <code>com.apple.CFSocket.private</code>。其中 <code>CFSocket</code> 线程是处理底层 <code>socket</code> 连接的。<code>NSURLConnectionLoader</code> 这个线程内部会使用 <code>RunLoop</code> 来接收底层 <code>socket</code> 的事件，并通过之前添加的 <code>Source0</code> 通知到上层的 <code>Delegate</code>。</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_network.png" alt=""></p>
<p><code>NSURLConnectionLoader</code> 中的 <code>RunLoop</code> 通过一些基于 <code>mach port</code> 的<code>Source</code> 接收来自底层 <code>CFSocket</code> 的通知。当收到通知后，其会在合适的时机向 <code>CFMultiplexerSource</code> 等 <code>Source0</code> 发送通知，同时唤醒 <code>Delegate</code> 线程的 <code>RunLoop</code> 来让其处理这些通知。<code>CFMultiplexerSource</code> 会在 <code>Delegate</code> 线程的 <code>RunLoop</code> 对 <code>Delegate</code> 执行实际的回调。</p>
<h3 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h3><h4 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h4><p><a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m" target="_blank" rel="external">AFURLConnectionOperation</a> 这个类是基于 <code>NSURLConnection</code> 构建的，其希望能在后台线程接收 <code>Delegate</code> 回调。为此 <code>AFNetworking</code>单独创建了一个线程，并在这个线程中启动了一个 <code>RunLoop</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</div><div class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</div><div class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line">        [runLoop run];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</div><div class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</div><div class="line">        [_networkRequestThread start];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _networkRequestThread;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>RunLoop</code> 启动前内部必须要有至少一个 <code>Timer</code>/<code>Observer</code>/<code>Source</code>，所以 <code>AFNetworking</code> 在 <code>[runLoop run]</code> 之前先创建了一个新的 <code>NSMachPort</code> 添加进去了。通常情况下，调用者需要持有这个 <code>NSMachPort</code> (<code>mach_port</code>) 并在外部线程通过这个 <code>port</code> 发送消息到 <code>loop</code> 内；但此处添加 <code>port</code> 只是为了让 <code>RunLoop</code> 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    [<span class="keyword">self</span>.lock lock];</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</div><div class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</div><div class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</div><div class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当需要这个后台线程执行任务时，<code>AFNetworking</code> 通过调用 <code>[NSObject performSelector:onThread:..]</code> 将这个任务扔到了后台线程的 <code>RunLoop</code> 中。</p>
<h4 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h4><p><a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p><code>UI</code> 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：<code>排版</code>，<code>绘制</code>，<code>UI对象操作</code>。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 <code>CoreText</code>)、图片绘制 (例如预先解压)、元素绘制 (<code>Quartz</code>)等操作。<br><code>UI</code>对象操作通常包括 <code>UIView</code>/<code>CALayer</code> 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如<code>TextView</code>创建时可能需要提前计算出文本的大小）。<code>ASDK</code> 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，<code>ASDK</code> 创建了一个名为 <code>ASDisplayNode</code> 的对象，并在内部封装了 <code>UIView</code>/<code>CALayer</code>，它具有和 <code>UIView</code>/<code>CALayer</code> 相似的属性，例如 <code>frame</code>、<code>backgroundColor</code>等。所有这些属性都可以在后台线程更改，开发者可以只通过 <code>Node</code> 来操作其内部的 <code>UIView</code>/<code>CALayer</code>，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 <code>UIView</code>/<code>CALayer</code> 去。</p>
<p><code>ASDK</code> 仿照 <code>QuartzCore</code>/<code>UIKit</code> 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 <code>RunLoop</code> 中添加一个 <code>Observer</code>，监听了 <code>kCFRunLoopBeforeWaiting</code> 和 <code>kCFRunLoopExit</code> 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。<br>具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m" target="_blank" rel="external">_ASAsyncTransactionGroup</a>。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><code>RunLoop</code> 需要深入理解</p>
<p>全文完</p>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="external">参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/0fa4569bca7b3a2d5c1ee360f47ac1dd213ecbac/20180402Run
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 4 中的数组技巧</title>
    <link href="https://www.sunyazhou.com/2018/03/14/20180314Swft4-Array-skills/"/>
    <id>https://www.sunyazhou.com/2018/03/14/20180314Swft4-Array-skills/</id>
    <published>2018-03-14T02:17:56.000Z</published>
    <updated>2018-03-14T12:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>年前买了本<a href="https://objccn.io/products/advanced-swift/" target="_blank" rel="external">Swift 进阶</a>(swift4.0),过完年回来正在一点点学习,不得不说喵神写的东西还是不错的,￥69元对广大程序员来说已经不算啥了.如果感兴趣可以买一本,真心不错</p>
<p>当我从头来学习数组的时候发现好多函数真的太有用了</p>
<h2 id="Swift-4-0-中的可变数组技巧"><a href="#Swift-4-0-中的可变数组技巧" class="headerlink" title="Swift 4.0 中的可变数组技巧"></a>Swift 4.0 中的可变数组技巧</h2><p>我们可用 Xcode 创建playground 来进行练习</p>
<p><strong>首先创建个数组</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> array = <span class="type">NSMutableArray</span>(array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> , <span class="number">5</span>, <span class="number">6</span>])</div></pre></td></tr></table></figure>
<p><strong>for in 循环遍历</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array &#123;</div><div class="line">    <span class="built_in">print</span>(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">1 2 3 4 5 6</div></pre></td></tr></table></figure>
<p><strong>想要扣除第一个元素剩余的元素进行迭代遍历呢？</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array.<span class="built_in">dropFirst</span>()&#123;</div><div class="line">    <span class="built_in">print</span>(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">2 3 4 5 6</div></pre></td></tr></table></figure>
<blockquote>
<p>dropFirst() 函数参数是可以添加数值的  for x in array.dropFirst(3) 打印:4 5 6.</p>
</blockquote>
<p>有 <code>first</code> 的地方基本就有<code>last</code></p>
<p><strong>想要扣除最后 3 个元素以外的元素进行遍历？</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array.<span class="built_in">dropLast</span>(<span class="number">3</span>)&#123;</div><div class="line">    <span class="built_in">print</span>(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">1 2 3</div></pre></td></tr></table></figure>
<p><strong>带下标和数组元素遍历</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (num, element) <span class="keyword">in</span> array.enumerated() &#123;</div><div class="line">    <span class="built_in">print</span>(num, element)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印 左边下标 右边元素</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">0 1</div><div class="line">1 2</div><div class="line">2 3</div><div class="line">3 4</div><div class="line">4 5</div><div class="line">5 6</div></pre></td></tr></table></figure>
<blockquote>
<p>左边下标 右边元素</p>
</blockquote>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;年前买了本&lt;a href=&quot;https://objccn.io/products/advanced-swift/&quot; target=&quot;_bla
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>什么是符号表?</title>
    <link href="https://www.sunyazhou.com/2018/03/08/20180308What-is-the-dSYM/"/>
    <id>https://www.sunyazhou.com/2018/03/08/20180308What-is-the-dSYM/</id>
    <published>2018-03-08T03:14:12.000Z</published>
    <updated>2018-03-11T23:32:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/home_page_log.jpeg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS 开发中经常回定位 bug 通过崩溃堆栈,此时我们需要借助符号表来恢复内存地址对应代码调用信息,为了解开这个大家耳熟能详却总有人问的问题的面纱,我在 bugle 平台和一些文章中收集了相关知识整理出来,以便后续方便记忆.</p>
<h2 id="本周主要内容如下"><a href="#本周主要内容如下" class="headerlink" title="本周主要内容如下"></a>本周主要内容如下</h2><ul>
<li>什么是符号表？</li>
<li>为什么要配置符号表？</li>
<li>dSYM文件？</li>
</ul>
<h3 id="什么是符号表？"><a href="#什么是符号表？" class="headerlink" title="什么是符号表？"></a>什么是符号表？</h3><p>符号表是内存地址与函数名、文件名、行号的映射表。符号表元素如下所示：</p>
<p><code>&lt;起始地址&gt;</code> <code>&lt;结束地址&gt;</code> <code>&lt;函数&gt;</code> [<code>&lt;文件名&gt;</code>:<code>&lt;行号&gt;</code>]  </p>
<h3 id="为什么要配置符号表？"><a href="#为什么要配置符号表？" class="headerlink" title="为什么要配置符号表？"></a>为什么要配置符号表？</h3><p>为了能快速并准确地定位用户APP发生<code>Crash</code>的代码<code>位置</code>，我们可以使用符号表对APP发生<code>Crash</code>的程序<code>堆栈</code>进行<code>解析</code>和<code>还原</code>。</p>
<p>举一个例子：</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/f84e46105c453408a030c50d802695917bf5ea4c/20180308What-is-the-dSYM/stack_symbol.png" alt=""></p>
<p>上图是我们通过符号表来解析出来崩溃堆栈的调用</p>
<h3 id="什么是dSYM文件？"><a href="#什么是dSYM文件？" class="headerlink" title="什么是dSYM文件？"></a>什么是dSYM文件？</h3><p>iOS平台中，<code>dSYM</code>文件是指具有调试信息的目标文件，文件名通常为： <code>com.公司名.dSYM</code>。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/test_dSYM.png" alt=""></p>
<p>一般都是和Xcode 工程名的 aget一样的名字</p>
<blockquote>
<p>为了方便找回Crash对应的dSYM文件和还原堆栈，建议每次构建或者发布APP版本的时候，备份好dSYM文件</p>
</blockquote>
<h4 id="如何定位dSYM文件？"><a href="#如何定位dSYM文件？" class="headerlink" title="如何定位dSYM文件？"></a>如何定位dSYM文件？</h4><p>一般情况下，项目编译完<code>dSYM</code>文件跟<code>app</code>文件在同一个目录下，下面以<code>XCode</code>作为IDE详细说明定位<code>dSYM</code>文件</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/dSYM1%402x.png" alt=""></p>
<p><img src="https://github.com/sunyazhou13/sunyazhou13.github.io-images/blob/master/20180308What-is-the-dSYM/dSYM2@2x.png?raw=true" alt=""></p>
<blockquote>
<p>这里用 release 模式做的测试 </p>
</blockquote>
<p>我们看到 和工程 <code>target</code>一样的名称的 <code>.dSYM</code>.</p>
<h4 id="XCode编译后没有生成dSYM文件"><a href="#XCode编译后没有生成dSYM文件" class="headerlink" title="XCode编译后没有生成dSYM文件?"></a>XCode编译后没有生成dSYM文件?</h4><p>XCode在 <code>Release</code>编译环境下默认会生成<code>dSYM</code>文件，而<code>Debug</code>编译环境下默认不会生成</p>
<p>如果要在<code>Debug</code>对应的<code>Xcode</code>配置如下:</p>
<p><code>XCode -&gt; Build Settings -&gt; Code Generation -&gt; Generate Debug Symbols -&gt; Yes</code><br><code>XCode -&gt; Build Settings -&gt; Build Option -&gt; Debug Information Format -&gt; DWARF with dSYM File</code></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/dsym3%402x.png" alt=""><br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/dsym4%402x.png" alt=""></p>
<h4 id="开启Bitcode之后需要注意哪些问题"><a href="#开启Bitcode之后需要注意哪些问题" class="headerlink" title="开启Bitcode之后需要注意哪些问题?"></a>开启Bitcode之后需要注意哪些问题?</h4><ul>
<li>在点<code>Upload to App Store</code>上传到<code>App Store</code>服务器的时候需要声明符号文件(<code>dSYM</code>文件)的生成:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/3d0ace06f1a780aa3691cc55af98d2403a7cfce1/20180308What-is-the-dSYM/dsym5.jpg" alt=""></p>
<ul>
<li>在配置符号表文件之前，需要从App Store中把该版本对应的dSYM文件下载回本地,然后用符号表工具生成和上传符号表文件。</li>
</ul>
<p>这里找回<code>ipa</code>版本对应的dSYM文件有两种方式</p>
<ol>
<li><p>通过Xcode的归档文件找回dSYM,打开<code>Xcode</code> 顶部菜单栏 -&gt; <code>Window</code> -&gt; <code>Organizer</code> 窗口,如下图:<br> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/BitcodedSYM-2.jpg" alt=""><br> 打开 <code>Xcode</code> 顶部菜单栏，选择<code>Archive</code> 标签:<br> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/BitcodedSYM-3.jpg" alt=""><br> 找到发布的归档包，右键点击对应归档包，选择<code>Show in Finder</code>操作:<br> <img src="https://bugly.qq.com/docs/img/symbol-ios/BitcodedSYM-4.jpg?v=20180119105842" alt=""><br> 右键选择定位到的归档文件，选择显示包内容操作:<br> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/BitcodedSYM-5.jpg" alt=""><br> 选择<code>dSYMs</code>目录，目录内即为下载到的 <code>dSYM</code> 文件:<br> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/BitcodedSYM-6.jpg" alt=""></p>
</li>
<li><p>通过<a href="https://itunesconnect.apple.com/" target="_blank" rel="external">iTunes Connect</a>找回</p>
<p> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/757ac10eb4448e952a1f9b42d71073de424da159/20180308What-is-the-dSYM/itunes_connect%402x.png" alt=""></p>
<p> 在“所有构件版本（All Builds）”中选择某一个版本，点“下载<code>dSYM</code>（Download dSYM）”下载dSYM文件.</p>
</li>
</ol>
<blockquote>
<p>注意:<em>一个<code>Archiver</code>与<code>dSYM</code>文件一一对应,搞错了容易翻译不出来来源码的调用</em></p>
</blockquote>
<p>参考如下:</p>
<p><a href="https://bugly.qq.com/docs/user-guide/symbol-configuration-ios/?v=1520478187041#dsym_1" target="_blank" rel="external">Bugly iOS 符号表配置</a><br><a href="https://techblog.toutiao.com/2017/07/05/session413/" target="_blank" rel="external">App 启动时间：过去，现在和未来</a></p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/home_page_log.jpeg&quot; 
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形渲染的流程</title>
    <link href="https://www.sunyazhou.com/2018/03/05/20180305Computer-graphics-rendering-process/"/>
    <id>https://www.sunyazhou.com/2018/03/05/20180305Computer-graphics-rendering-process/</id>
    <published>2018-03-05T04:11:41.000Z</published>
    <updated>2018-03-05T13:00:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180305Computer-graphics-rendering-process/%20Ivan-Sutherland.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在网上找到了一篇有价值的文章,来说明计算机中的图像渲染流程以及像素点计算和坐标点相关的知识.</p>
<h2 id="计算机图形渲染的流程"><a href="#计算机图形渲染的流程" class="headerlink" title="计算机图形渲染的流程"></a>计算机图形渲染的流程</h2><p>计算机的绘图过程可以简单用流水线来说明，而产品(数据)就是经过流水线作业(渲染)到屏幕的图像。这条流水线可以简化为(本文的概念):绘图位置座标指定;着色指定;输出指定;下图简单解释了这一个流水线过程。计算机绘图需要一个输入绘图数据，这个数据可以是用户指定的，也可以是操作系统决定的，也可以是混合的。这些数据是分组的。</p>
<ul>
<li>座标生成：当绘图数据送入座标生成系统后，流水线就会对其进行座标分派，图1右上的线框图抽象描述了这个过程。</li>
<li>着色指定：当座标系统生成出带座标的绘图数据后就需要送入着色器，着色器指定了这些线框的填充颜色或纹理。</li>
<li>渲染：着色器将绘图数据加上着色数据后就被送入渲染器，渲染器根据绘图数据描述，将像素填充到描述的线框组里并送入帧缓存，然后然后送入显示器，显示器获取到帧缓存的数据后再根据数据的描述来绘图到屏幕上。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180305Computer-graphics-rendering-process/render1.png" alt=""></p>
<h2 id="像素与点（point）与点（dot）"><a href="#像素与点（point）与点（dot）" class="headerlink" title="像素与点（point）与点（dot）"></a>像素与点（point）与点（dot）</h2><p>像素与点（point），点（dot）这三个单位很容易令人混淆，原因在于它们在很多场合上是可以互换的。但是本文需要区分这两者的概念。</p>
<p>像素指的是一种数据结构，这个数据结构包含了RGB三个数据，分别对应的是红色，绿色，蓝色。我们说一张计算机生成的位图时，我们会说这图是多少像素x多少像素，例如800x600像素。值得注意的是，像素没有一个固定的尺寸单位，它只是一个抽象概念。</p>
<p>点（dot）指的是显示器屏幕的点或打印的点，是具体指代的事物。我们想说的DPI即dot per inch，每英寸多少个点。一般来说1个点对应一个像素，常见的打印尺寸是72DPI，即每英寸72点，也就是包含72个像素的数据。当像素被计算机输出成点投射都屏幕或纸面上时，它才具备了尺寸的概念，即点（dot）。</p>
<p>点（point）指的是座标点，是一个数据结构，包含了两个数据（或三个）X和Y(和Z)座标。绘图数据里是包含了这个座标数据的。对于没有使用HiDPI的操作系统来说，一个座标点对应一个像素。</p>
<h2 id="点（point）不一定等于像素"><a href="#点（point）不一定等于像素" class="headerlink" title="点（point）不一定等于像素"></a>点（point）不一定等于像素</h2><p>一般来说，点（dot）与像素是可以互换指代的，而且我们在Retina的概念被提出前一直这样使用它们。但是，现在这两个概念必须要区分出来。像素只是一个描述RGB的数据结构，它没有任何尺寸单位，它更不是一个矩形。当像素被输出到屏幕或纸张上时，我们应该用点来指代这种含有颜色，有尺寸的具体事物。</p>
<p>普通的显示屏幕或打印机，我们会说屏幕上的一个点（dot）是由一个像素（RGB数据）组成的，打印后的点是由一个像素经过色彩转换（CMYK数据）组成的。</p>
<p>对于打印机来说，一般的DPI是72。也就是指我们在显示器屏幕上看到720x720像素的位图，在打印出来后的面积是10x10英寸，但是屏幕上的位图面积并不会跟打印出来的面积一致。因为屏幕上的一个点与打印的点的尺寸不一样。</p>
<p>PPI指的是每英寸多少像素，与DPI有一定概念上的区别。PPI一般指的是屏幕的点密度，DPI指的是打印点的密度。PPI不是固定的，不同屏幕尺寸结合不同的分辨率会有不同的PPI，但是DPI则是相对固定在72。</p>
<p>HiDPI是苹果的一项绘图技术，结合这种技术，计算机座标系统上的一个点（point）不再对应一个像素，一般来说会是一个座标点对应四个像素，而一个像素对应屏幕的一个物理点（dot）。</p>
<p>由于像素是一组色彩数据，所以绘图数据在经过着色器后才包含了它。举个例子，绘图数据在送入着色器前是描述一个100x100的矩形，经过着色器指定色彩属性后会被送入一个HiDPI系统，这个系统将200x200个像素的数据添加到绘图数据里。在经过渲染器后，相当于将200x200个像素填充进100x100这个矩形线框。</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180305Computer-graphics-rendering-process/render2.png" alt=""></p>
<h2 id="帧缓存与显示器屏幕"><a href="#帧缓存与显示器屏幕" class="headerlink" title="帧缓存与显示器屏幕"></a>帧缓存与显示器屏幕</h2><p>帧缓存是储存计算机渲染后的图形数据的，这些数据包括座标，像素，分辨率等等。。简单来说就是描述图象的数据，当这些描述数据送入显示器后，显示器就知道怎么绘图了。</p>
<p>一般来说的屏幕分辨率指的是渲染器生产出来的像素数据排列，例如1280x800像素。值得注意的是这个屏幕分辨率与显示器屏幕的物理点排列没关系的。屏幕分辨率是可设置的，显示器的物理点排列是固定的。例如帧缓存里的分辨率是1280x800像素，但是显示器屏幕是1920x1200点排列的，那么显示器会怎么将帧缓存里的数据呈现到屏幕上呢？答案是通过自适应放缩，是经过显示器内部芯片来转换的。</p>
<p>13寸的RMBP在分辨率设置里是这样描述的，看起来像1280x800像素，看起来像1440x900像素。我们需要这样理解，1280x800像素是相对于旧款不带Retina的机器，也就是绘图数据送入着色器前的座标系统与渲染后的座标是1:1对应的参考值。实际上在经过渲染后，它的实际像素是2560x1600，也就是帧缓存里是数据是2560x1600像素。同样地看起来1440x900像素实际渲染后的像素是2880x1800。由于13寸的屏幕实际点排列是2560x1600，所以帧缓存2880x1800像素在输出到屏幕后会被自适应缩放掉。</p>
<h2 id="DPI与Retina"><a href="#DPI与Retina" class="headerlink" title="DPI与Retina"></a>DPI与Retina</h2><p>操作系统标准的桌面打印DPI是72，但是随着HiDPI技术和高PPI屏幕出现后，这个标准也许会有一定的变化。我们在Retina的OS X下用Photoshop新建一个文件时默认的DPI指定在144上了，这是标准转变的一个信号。</p>
<p>在没有使用类似HiDPI技术的操作系统上，屏幕分辨率对应的打印DPI是72。使用HiDPI的Retina机器的打印DPI是144，用以保证在统一尺下具有更多的点密度。这点对于印前工作非常重要。</p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180305Computer-graphics-rendering-process/%
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Learning AV Foundation(五)播放视频</title>
    <link href="https://www.sunyazhou.com/2018/03/04/Learning-AV-Foundation-Playing-Video/"/>
    <id>https://www.sunyazhou.com/2018/03/04/Learning-AV-Foundation-Playing-Video/</id>
    <published>2018-03-04T08:56:06.000Z</published>
    <updated>2018-03-04T09:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/5k-airplay.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很久没有写Learning AV Foundation相关的文章了,言归正传<br>本篇介绍一下简单的视频播放</p>
<p>了解视频播放之前我们来看戏<code>AVPlayer</code>需要的一些组件模型</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/AVPlayer.png" alt="AVPlayer组件模型"></p>
<h2 id="AVPlayer"><a href="#AVPlayer" class="headerlink" title="AVPlayer"></a>AVPlayer</h2><p><code>AVPlayer</code>是一个用来播放基于基于时间的视听媒体的控制对象,支持播放:</p>
<ul>
<li>本地 媒体文件</li>
<li>异步下载 媒体文件</li>
<li>HTTP Live Streaming协议的流媒体 文件</li>
</ul>
<p><code>AVPlayer</code> 是个 逻辑层组件</p>
<p>(应用可以分为如下几层)</p>
<blockquote>
<p>UI层<br>业务逻辑层<br>持久层+网络层  </p>
</blockquote>
<p>如果播放<code>MP3</code>或<code>AAC</code>等音频文件, 是没有啥UI可视化的页面的。要是播放一个<code>QuickTime</code>的电影或一个<code>MPEG-4</code>视频, 就会搞得很不适应.<br>如果要播放视频等功能设计到UI的话，可以使用<code>AVPlayerLayer</code>类。</p>
<blockquote>
<p>注意: <em><code>AVPlayer</code>只管理一个单独资源的播放, 如果播放多个可以使用<code>AVPlayer</code>的子类<code>AVQueuePlayer</code>, 用它来管理一个资源队列, 当需要在一个序列中播放多个条目或者 为音频、视频资源设置播放循环时刻使用这个类</em>.</p>
</blockquote>
<h2 id="AVPlayerLayer"><a href="#AVPlayerLayer" class="headerlink" title="AVPlayerLayer"></a>AVPlayerLayer</h2><p><code>AVPlayerLayer</code>构建于 <code>Core Animation</code>之上, 是<code>AV Foundation</code>中能找到的位数不多的UI组件. <code>Core Animation</code> 是<code>Mac</code>和<code>iOS</code>平台上负责图形渲染与动画的基础框架,主要用于这些平台的美化和动画流畅度的提升. <code>Core Animation</code>本身具有基于时间的属性,并且由于它基于<code>OpenGL</code>,所以具有很好的性能.</p>
<p><code>AVPlayerLayer</code>扩展了<code>Core Animation</code> 的<code>CALayer</code>类, 并通过框架显示视频内容到屏幕上.<br>我们知道Layer是不响应事件的.</p>
<p>创建<code>AVPlayerLayer</code>需要实例化一个<code>AVPlayer</code>的对象，<code>AVPlayerLayer</code>有一个<code>videoGravity</code>属性可以设置三种类似填充模式的东西,用来拉扯和缩放的视频. 下面列举了16:9的视频置于4:3矩形范围来说明不同的<code>gravity</code>.</p>
<p>如下图:</p>
<p><strong>AVLayerVideoGravityResizeAspect</strong>保持缩放比例<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/AVLayerVideoGravityResizeAspect.png" alt=""></p>
<p><strong>AVLayerVideoGravityResizeAspectFill</strong>填充<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/AVLayerVideoGravityResizeAspectFill.png" alt=""></p>
<p><strong>AVLayerVideoGravityResize</strong>拉伸</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/AVLayerVideoGravityResize.png" alt=""></p>
<h2 id="AVPlayerItem"><a href="#AVPlayerItem" class="headerlink" title="AVPlayerItem"></a>AVPlayerItem</h2><p>我们需要使用<code>AVPlayer</code>播放<code>AVAsset</code>,前面我知道<code>AVAsset</code>元数据里面有<code>创建时间</code>、<code>元数据</code>和<code>时长</code>等信息.但是并没有媒体中特定位置的方法.</p>
<p><strong>这是因为<code>AVAsset</code>模型只包含媒体资源的静态信息.这些不变的属性用来描述对象的静态信息.这就意味着仅使用<code>AVAsset</code>对象是不能实现播放功能的.如果播放我们需要使用<code>AVPlayerItem</code></strong></p>
<p><strong><code>AVPlayerItem</code>可以理解成是一个动态的<code>AVAsset</code>模型,</strong><br><code>AVPlayerItem</code>有<code>seekToTime:</code>方法和<code>presentationSize:</code>,<code>AVPlayerItem</code>由一个或多个媒体曲目组成.</p>
<p><code>AVPlayerItem</code>里面有<code>`AVPlayerItemTrack</code>轨道属性.</p>
<h2 id="播放示例"><a href="#播放示例" class="headerlink" title="播放示例"></a>播放示例</h2><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">	<span class="keyword">self</span>.localURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"hubblecast"</span> withExtension:<span class="string">@"m4v"</span>];</div><div class="line"></div><div class="line">    <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:<span class="keyword">self</span>.localURL];</div><div class="line">    </div><div class="line">    <span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</div><div class="line">    </div><div class="line">    <span class="built_in">AVPlayer</span> *player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:item];</div><div class="line">    </div><div class="line">    <span class="built_in">AVPlayerLayer</span> *layer = [<span class="built_in">AVPlayerLayer</span> playerLayerWithPlayer:player];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.view.layer addSublayer:layer];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>AVPlayerItem</code>并没有任何代理告知我们是否已经开始播放,所以一般的搞法都是使用<code>KVO</code>去监听它的一个属性,<code>AVPlayerItemStatus</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">AVPlayerItemStatus</span>) &#123;</div><div class="line">	<span class="built_in">AVPlayerItemStatusUnknown</span>,</div><div class="line">	<span class="built_in">AVPlayerItemStatusReadyToPlay</span>,</div><div class="line">	<span class="built_in">AVPlayerItemStatusFailed</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当它的<code>status</code>变成<code>AVPlayerItemStatusReadyToPlay</code>就说明已载入完成准备播放.</p>
<h2 id="CMTime"><a href="#CMTime" class="headerlink" title="CMTime"></a>CMTime</h2><p>使用<code>CMTime</code>来处理各种音视频相关的时间操作,他是<code>CoreMedia</code>framework中的结构体.专门用于处理精确的时间,我们以前用的<code>NSTimeInterval</code>是存在计算不精确的问题(苹果官方说的).</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">CMTimeValue</span>	value;		<span class="comment">//分子</span></div><div class="line">	<span class="built_in">CMTimeScale</span>	timescale; <span class="comment">//分母</span></div><div class="line">	<span class="built_in">CMTimeFlags</span>	flags;		<span class="comment">//标记是否失效 eg. kCMTimeFlags_Valid, kCMTimeFlags_PositiveInfinity</span></div><div class="line">	<span class="built_in">CMTimeEpoch</span>	epoch;		</div><div class="line">&#125; <span class="built_in">CMTime</span>;</div></pre></td></tr></table></figure>
<p>这个结构体最关键的即使<code>value</code>(64位整形)和<code>timescale</code>(32位整形).</p>
<p>它表达时间的方式以分数表示比如:</p>
<p><code>0.5</code>秒</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">CMTime</span> halfSecond = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//0.5秒</span></div><div class="line"><span class="built_in">CMTime</span> fiveSecond = <span class="built_in">CMTimeMake</span>(<span class="number">5</span>, <span class="number">1</span>); <span class="comment">//5秒</span></div><div class="line"><span class="built_in">CMTime</span> oneSample = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">44100</span>); <span class="comment">//一个抽样的样本</span></div><div class="line"><span class="built_in">CMTime</span> zeroTime = kCMTimeZero;</div></pre></td></tr></table></figure>
<h2 id="创建自己的播放器"><a href="#创建自己的播放器" class="headerlink" title="创建自己的播放器"></a>创建自己的播放器</h2><p>首先需要封装一个<code>player</code>,</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"TransportProtocol.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">AVPlayer</span>;</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerView</span> : <span class="title">UIView</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> &lt;TransportProtocol&gt;  transport;</div><div class="line">- (<span class="keyword">id</span>)initWithPlayer:(<span class="built_in">AVPlayer</span> *)player;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>.m文件实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"PlayerView.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"THOverlayView.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerView</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) THOverlayView *overlayView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PlayerView</span></span></div><div class="line">+ (Class)layerClass&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">AVPlayerLayer</span> <span class="keyword">class</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithPlayer:(<span class="built_in">AVPlayer</span> *)player&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:<span class="built_in">CGRectZero</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">        <span class="keyword">self</span>.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</div><div class="line">        [(<span class="built_in">AVPlayerLayer</span> *)[<span class="keyword">self</span> layer] setPlayer:player];</div><div class="line">        [[<span class="built_in">NSBundle</span> mainBundle] loadNibNamed:<span class="string">@"THOverlayView"</span> owner:<span class="keyword">self</span> options:<span class="literal">nil</span>];</div><div class="line">        [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.overlayView];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)layoutSubviews&#123;</div><div class="line">    [<span class="keyword">super</span> layoutSubviews];</div><div class="line">    <span class="keyword">self</span>.overlayView.frame = <span class="keyword">self</span>.bounds;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span> &lt;TransportProtocol&gt;)transport&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.overlayView;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>transport 是播放器的视图点击视图代理等集成了 在一起</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TransportDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)play;</div><div class="line">- (<span class="keyword">void</span>)pause;</div><div class="line">- (<span class="keyword">void</span>)stop;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)scrubbingDidStart;</div><div class="line">- (<span class="keyword">void</span>)scrubbedToTime:(<span class="built_in">NSTimeInterval</span>)time;</div><div class="line">- (<span class="keyword">void</span>)scrubbingDidEnd;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)jumpedToTime:(<span class="built_in">NSTimeInterval</span>)time;</div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)subtitleSelected:(<span class="built_in">NSString</span> *)subtitle;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TransportProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> &lt;TransportDelegate&gt; delegate;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title;</div><div class="line">- (<span class="keyword">void</span>)setCurrentTime:(<span class="built_in">NSTimeInterval</span>)time duration:(<span class="built_in">NSTimeInterval</span>)duration;</div><div class="line">- (<span class="keyword">void</span>)setScrubbingTime:(<span class="built_in">NSTimeInterval</span>)time;</div><div class="line">- (<span class="keyword">void</span>)playbackComplete;</div><div class="line">- (<span class="keyword">void</span>)setSubtitles:(<span class="built_in">NSArray</span> *)subtitles;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>THOverlayView文件是顶层视图点击播放等等控件.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerController</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIView</span> *view;</div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)assetURL;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>播放器的实现文件如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"PlayerController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"TransportProtocol.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"PlayerView.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"AVAsset+Additions.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"UIAlertView+Additions.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"THThumbnail.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">// AVPlayerItem's status property</span></div><div class="line"><span class="meta">#define STATUS_KEYPATH @<span class="meta-string">"status"</span></span></div><div class="line"></div><div class="line"><span class="comment">// Refresh interval for timed observations of AVPlayer</span></div><div class="line"><span class="meta">#define REFRESH_INTERVAL 0.5f</span></div><div class="line"></div><div class="line"><span class="comment">// Define this constant for the key-value observation context.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *PlayerItemStatusContext;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerController</span> () &lt;<span class="title">TransportDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVAsset</span>               *asset;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVPlayerItem</span>          *playerItem;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVPlayer</span>              *player;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) PlayerView            *playerView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;TransportProtocol&gt;  transport;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>                    timeObserver;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>                    itemEndObserver;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span>                 lastPlaybackRate;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">AVAssetImageGenerator</span> *imageGenerator;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PlayerController</span></span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Setup</span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)assetURL &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _asset = [<span class="built_in">AVAsset</span> assetWithURL:assetURL];                           <span class="comment">// 1</span></div><div class="line">        [<span class="keyword">self</span> prepareToPlay];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)prepareToPlay &#123;</div><div class="line">    <span class="built_in">NSArray</span> *keys = @[</div><div class="line">                      <span class="string">@"tracks"</span>,</div><div class="line">                      <span class="string">@"duration"</span>,</div><div class="line">                      <span class="string">@"commonMetadata"</span>,</div><div class="line">                      <span class="string">@"availableMediaCharacteristicsWithMediaSelectionOptions"</span></div><div class="line">                      ];</div><div class="line">    <span class="keyword">self</span>.playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:<span class="keyword">self</span>.asset          <span class="comment">// 2</span></div><div class="line">                           automaticallyLoadedAssetKeys:keys];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span>                                       <span class="comment">// 3</span></div><div class="line">                      forKeyPath:STATUS_KEYPATH</div><div class="line">                         options:<span class="number">0</span></div><div class="line">                         context:&amp;PlayerItemStatusContext];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:<span class="keyword">self</span>.playerItem];          <span class="comment">// 4</span></div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.playerView = [[PlayerView alloc] initWithPlayer:<span class="keyword">self</span>.player];    <span class="comment">// 5</span></div><div class="line">    <span class="keyword">self</span>.transport = <span class="keyword">self</span>.playerView.transport;</div><div class="line">    <span class="keyword">self</span>.transport.delegate = <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (context == &amp;PlayerItemStatusContext) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;                        <span class="comment">// 1</span></div><div class="line">            </div><div class="line">            [<span class="keyword">self</span>.playerItem removeObserver:<span class="keyword">self</span> forKeyPath:STATUS_KEYPATH];</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.playerItem.status == <span class="built_in">AVPlayerItemStatusReadyToPlay</span>) &#123;</div><div class="line">                </div><div class="line">                <span class="comment">// Set up time observers.                                   // 2</span></div><div class="line">                [<span class="keyword">self</span> addPlayerItemTimeObserver];</div><div class="line">                [<span class="keyword">self</span> addItemEndObserverForPlayerItem];</div><div class="line">                </div><div class="line">                <span class="built_in">CMTime</span> duration = <span class="keyword">self</span>.playerItem.duration;</div><div class="line">                </div><div class="line">                <span class="comment">// Synchronize the time display                             // 3</span></div><div class="line">                [<span class="keyword">self</span>.transport setCurrentTime:<span class="built_in">CMTimeGetSeconds</span>(kCMTimeZero)</div><div class="line">                                      duration:<span class="built_in">CMTimeGetSeconds</span>(duration)];</div><div class="line">                </div><div class="line">                <span class="comment">// Set the video title.</span></div><div class="line">                [<span class="keyword">self</span>.transport setTitle:<span class="keyword">self</span>.asset.title];                 <span class="comment">// 4</span></div><div class="line">                </div><div class="line">                [<span class="keyword">self</span>.player play];                                         <span class="comment">// 5</span></div><div class="line">                </div><div class="line">                [<span class="keyword">self</span> loadMediaOptions];</div><div class="line">                [<span class="keyword">self</span> generateThumbnails];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                [<span class="built_in">UIAlertView</span> showAlertWithTitle:<span class="string">@"Error"</span></div><div class="line">                                        message:<span class="string">@"Failed to load video"</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)loadMediaOptions &#123;</div><div class="line">    <span class="built_in">NSString</span> *mc = <span class="built_in">AVMediaCharacteristicLegible</span>;                            <span class="comment">// 1</span></div><div class="line">    <span class="built_in">AVMediaSelectionGroup</span> *group =</div><div class="line">    [<span class="keyword">self</span>.asset mediaSelectionGroupForMediaCharacteristic:mc];          <span class="comment">// 2</span></div><div class="line">    <span class="keyword">if</span> (group) &#123;</div><div class="line">        <span class="built_in">NSMutableArray</span> *subtitles = [<span class="built_in">NSMutableArray</span> array];                 <span class="comment">// 3</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">AVMediaSelectionOption</span> *option <span class="keyword">in</span> group.options) &#123;</div><div class="line">            [subtitles addObject:option.displayName];</div><div class="line">        &#125;</div><div class="line">        [<span class="keyword">self</span>.transport setSubtitles:subtitles];                            <span class="comment">// 4</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span>.transport setSubtitles:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)subtitleSelected:(<span class="built_in">NSString</span> *)subtitle &#123;</div><div class="line">    <span class="built_in">NSString</span> *mc = <span class="built_in">AVMediaCharacteristicLegible</span>;</div><div class="line">    <span class="built_in">AVMediaSelectionGroup</span> *group =</div><div class="line">    [<span class="keyword">self</span>.asset mediaSelectionGroupForMediaCharacteristic:mc];          <span class="comment">// 1</span></div><div class="line">    <span class="built_in">BOOL</span> selected = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">AVMediaSelectionOption</span> *option <span class="keyword">in</span> group.options) &#123;</div><div class="line">        <span class="keyword">if</span> ([option.displayName isEqualToString:subtitle]) &#123;</div><div class="line">            [<span class="keyword">self</span>.playerItem selectMediaOption:option                       <span class="comment">// 2</span></div><div class="line">                         inMediaSelectionGroup:group];</div><div class="line">            selected = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!selected) &#123;</div><div class="line">        [<span class="keyword">self</span>.playerItem selectMediaOption:<span class="literal">nil</span>                              <span class="comment">// 3</span></div><div class="line">                     inMediaSelectionGroup:group];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Time Observers</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addPlayerItemTimeObserver &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// Create 0.5 second refresh interval - REFRESH_INTERVAL == 0.5</span></div><div class="line">    <span class="built_in">CMTime</span> interval =</div><div class="line">    <span class="built_in">CMTimeMakeWithSeconds</span>(REFRESH_INTERVAL, <span class="built_in">NSEC_PER_SEC</span>);              <span class="comment">// 1</span></div><div class="line">    </div><div class="line">    <span class="comment">// Main dispatch queue</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();                     <span class="comment">// 2</span></div><div class="line">    </div><div class="line">    <span class="comment">// Create callback block for time observer</span></div><div class="line">    __<span class="keyword">weak</span> PlayerController *weakSelf = <span class="keyword">self</span>;                             <span class="comment">// 3</span></div><div class="line">    <span class="keyword">void</span> (^callback)(<span class="built_in">CMTime</span> time) = ^(<span class="built_in">CMTime</span> time) &#123;</div><div class="line">        <span class="built_in">NSTimeInterval</span> currentTime = <span class="built_in">CMTimeGetSeconds</span>(time);</div><div class="line">        <span class="built_in">NSTimeInterval</span> duration = <span class="built_in">CMTimeGetSeconds</span>(weakSelf.playerItem.duration);</div><div class="line">        [weakSelf.transport setCurrentTime:currentTime duration:duration];  <span class="comment">// 4</span></div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">// Add observer and store pointer for future use</span></div><div class="line">    <span class="keyword">self</span>.timeObserver =                                                     <span class="comment">// 5</span></div><div class="line">    [<span class="keyword">self</span>.player addPeriodicTimeObserverForInterval:interval</div><div class="line">                                              queue:queue</div><div class="line">                                         usingBlock:callback];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addItemEndObserverForPlayerItem &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *name = <span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> mainQueue];</div><div class="line">    </div><div class="line">    __<span class="keyword">weak</span> PlayerController *weakSelf = <span class="keyword">self</span>;                             <span class="comment">// 1</span></div><div class="line">    <span class="keyword">void</span> (^callback)(<span class="built_in">NSNotification</span> *note) = ^(<span class="built_in">NSNotification</span> *notification) &#123;</div><div class="line">        [weakSelf.player seekToTime:kCMTimeZero                             <span class="comment">// 2</span></div><div class="line">                  completionHandler:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                      [weakSelf.transport playbackComplete];                          <span class="comment">// 3</span></div><div class="line">                  &#125;];</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.itemEndObserver =                                                  <span class="comment">// 4</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:name</div><div class="line">                                                      object:<span class="keyword">self</span>.playerItem</div><div class="line">                                                       queue:queue</div><div class="line">                                                  usingBlock:callback];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - THTransportDelegate Methods</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)play &#123;</div><div class="line">    [<span class="keyword">self</span>.player play];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)pause &#123;</div><div class="line">    <span class="keyword">self</span>.lastPlaybackRate = <span class="keyword">self</span>.player.rate;</div><div class="line">    [<span class="keyword">self</span>.player pause];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line">    [<span class="keyword">self</span>.player setRate:<span class="number">0.0</span>f];</div><div class="line">    [<span class="keyword">self</span>.transport playbackComplete];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)jumpedToTime:(<span class="built_in">NSTimeInterval</span>)time &#123;</div><div class="line">    [<span class="keyword">self</span>.player seekToTime:<span class="built_in">CMTimeMakeWithSeconds</span>(time, <span class="built_in">NSEC_PER_SEC</span>)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)scrubbingDidStart &#123;                                                 <span class="comment">// 1</span></div><div class="line">    <span class="keyword">self</span>.lastPlaybackRate = <span class="keyword">self</span>.player.rate;</div><div class="line">    [<span class="keyword">self</span>.player pause];</div><div class="line">    [<span class="keyword">self</span>.player removeTimeObserver:<span class="keyword">self</span>.timeObserver];</div><div class="line">    <span class="keyword">self</span>.timeObserver = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)scrubbedToTime:(<span class="built_in">NSTimeInterval</span>)time &#123;                               <span class="comment">// 2</span></div><div class="line">    [<span class="keyword">self</span>.playerItem cancelPendingSeeks];</div><div class="line">    [<span class="keyword">self</span>.player seekToTime:<span class="built_in">CMTimeMakeWithSeconds</span>(time, <span class="built_in">NSEC_PER_SEC</span>) toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)scrubbingDidEnd &#123;                                                   <span class="comment">// 3</span></div><div class="line">    [<span class="keyword">self</span> addPlayerItemTimeObserver];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastPlaybackRate &gt; <span class="number">0.0</span>f) &#123;</div><div class="line">        [<span class="keyword">self</span>.player play];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Thumbnail Generation</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)generateThumbnails &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.imageGenerator =                                                   <span class="comment">// 1</span></div><div class="line">    [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:<span class="keyword">self</span>.asset];</div><div class="line">    </div><div class="line">    <span class="comment">// Generate the @2x equivalent</span></div><div class="line">    <span class="keyword">self</span>.imageGenerator.maximumSize = <span class="built_in">CGSizeMake</span>(<span class="number">200.0</span>f, <span class="number">0.0</span>f);             <span class="comment">// 2</span></div><div class="line">    </div><div class="line">    <span class="built_in">CMTime</span> duration = <span class="keyword">self</span>.asset.duration;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableArray</span> *times = [<span class="built_in">NSMutableArray</span> array];                         <span class="comment">// 3</span></div><div class="line">    <span class="built_in">CMTimeValue</span> increment = duration.value / <span class="number">20</span>;</div><div class="line">    <span class="built_in">CMTimeValue</span> currentValue = <span class="number">2.0</span> * duration.timescale;</div><div class="line">    <span class="keyword">while</span> (currentValue &lt;= duration.value) &#123;</div><div class="line">        <span class="built_in">CMTime</span> time = <span class="built_in">CMTimeMake</span>(currentValue, duration.timescale);</div><div class="line">        [times addObject:[<span class="built_in">NSValue</span> valueWithCMTime:time]];</div><div class="line">        currentValue += increment;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSUInteger</span> imageCount = times.count;                            <span class="comment">// 4</span></div><div class="line">    __block <span class="built_in">NSMutableArray</span> *images = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    </div><div class="line">    <span class="built_in">AVAssetImageGeneratorCompletionHandler</span> handler;                         <span class="comment">// 5</span></div><div class="line">    </div><div class="line">    handler = ^(<span class="built_in">CMTime</span> requestedTime,</div><div class="line">                <span class="built_in">CGImageRef</span> imageRef,</div><div class="line">                <span class="built_in">CMTime</span> actualTime,</div><div class="line">                <span class="built_in">AVAssetImageGeneratorResult</span> result,</div><div class="line">                <span class="built_in">NSError</span> *error) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorSucceeded</span>) &#123;                     <span class="comment">// 6</span></div><div class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</div><div class="line">            <span class="keyword">id</span> thumbnail =</div><div class="line">            [THThumbnail thumbnailWithImage:image time:actualTime];</div><div class="line">            [images addObject:thumbnail];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, [error localizedDescription]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// If the decremented image count is at 0, we're all done.</span></div><div class="line">        <span class="keyword">if</span> (--imageCount == <span class="number">0</span>) &#123;                                            <span class="comment">// 7</span></div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="built_in">NSString</span> *name = THThumbnailsGeneratedNotification;</div><div class="line">                <span class="built_in">NSNotificationCenter</span> *nc = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</div><div class="line">                [nc postNotificationName:name object:images];</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.imageGenerator generateCGImagesAsynchronouslyForTimes:times       <span class="comment">// 8</span></div><div class="line">                                              completionHandler:handler];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Housekeeping</span></div><div class="line"></div><div class="line">- (<span class="built_in">UIView</span> *)view &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.playerView;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.itemEndObserver) &#123;                                             <span class="comment">// 5</span></div><div class="line">        <span class="built_in">NSNotificationCenter</span> *nc = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</div><div class="line">        [nc removeObserver:<span class="keyword">self</span>.itemEndObserver</div><div class="line">                      name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></div><div class="line">                    object:<span class="keyword">self</span>.player.currentItem];</div><div class="line">        <span class="keyword">self</span>.itemEndObserver = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这里说一下如何监听时间从而得知播放时间回调</p>
<h3 id="监听时间"><a href="#监听时间" class="headerlink" title="监听时间"></a>监听时间</h3><p>当播放器播放的时候我们无法得知播放到播放器的哪个位置,为了解决这个问题<code>AVPlayerItem</code>添加了两个监听播放的方法以及具体的用法<code>API</code>.</p>
<h4 id="定期监听"><a href="#定期监听" class="headerlink" title="定期监听"></a>定期监听</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)addPeriodicTimeObserverForInterval:(<span class="built_in">CMTime</span>)interval</div><div class="line">                                   queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue</div><div class="line">                              usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> time))block;</div></pre></td></tr></table></figure>
<p>这里主要是为了随着时间的变化移动播放器seek位置更新时间显示,通过<code>AVPlayer</code>的<code>addPeriodicTimeObserverForInterval:queue:usingBlock:</code> 来监听播放时间的变化</p>
<ul>
<li><code>interv</code><em>监听周期的间隔<code>CMTime</code></em></li>
<li><code>queue</code> <em>通知发送的顺序调度队列,一般我们都放在主线程回掉.(注意这里不能放在并行队列中)</em></li>
<li><code>block</code> <em>指定周期的时间回调.</em></li>
</ul>
<p>下面是示例代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addPlayerItemTimeObserver &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// Create 0.5 second refresh interval - REFRESH_INTERVAL == 0.5</span></div><div class="line">    <span class="built_in">CMTime</span> interval =</div><div class="line">    <span class="built_in">CMTimeMakeWithSeconds</span>(REFRESH_INTERVAL, <span class="built_in">NSEC_PER_SEC</span>);              <span class="comment">// 1</span></div><div class="line">    </div><div class="line">    <span class="comment">// Main dispatch queue</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();                     <span class="comment">// 2</span></div><div class="line">    </div><div class="line">    <span class="comment">// Create callback block for time observer</span></div><div class="line">    __<span class="keyword">weak</span> PlayerController *weakSelf = <span class="keyword">self</span>;                             <span class="comment">// 3</span></div><div class="line">    <span class="keyword">void</span> (^callback)(<span class="built_in">CMTime</span> time) = ^(<span class="built_in">CMTime</span> time) &#123;</div><div class="line">        <span class="built_in">NSTimeInterval</span> currentTime = <span class="built_in">CMTimeGetSeconds</span>(time);</div><div class="line">        <span class="built_in">NSTimeInterval</span> duration = <span class="built_in">CMTimeGetSeconds</span>(weakSelf.playerItem.duration);</div><div class="line">        [weakSelf.transport setCurrentTime:currentTime duration:duration];  <span class="comment">// 4</span></div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">// Add observer and store pointer for future use</span></div><div class="line">    <span class="keyword">self</span>.timeObserver =                                                     <span class="comment">// 5</span></div><div class="line">    [<span class="keyword">self</span>.player addPeriodicTimeObserverForInterval:interval</div><div class="line">                                              queue:queue</div><div class="line">                                         usingBlock:callback];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="边界监听"><a href="#边界监听" class="headerlink" title="边界监听"></a>边界监听</h4><p>什么叫边界监听呢?就是播放器播放到某个时间的触发的 时间位置.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)addBoundaryTimeObserverForTimes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)times</div><div class="line">                                queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue</div><div class="line">                           usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</div></pre></td></tr></table></figure>
<ul>
<li><code>times</code> <em>CMTime值组成一个<code>NSArray</code>,这里面定义的一个时间点的数组.eg: 25% 50% 75%等时间点.</em></li>
<li><code>queue</code> <em>通知发送的顺序调度队列,一般我们都放在主线程回掉.(注意这里不能放在并行队列中)</em></li>
<li><code>block</code> <em>指定周期的时间回调.</em></li>
</ul>
<h3 id="显示字幕"><a href="#显示字幕" class="headerlink" title="显示字幕"></a>显示字幕</h3><p><code>AVPlayerLayer</code>里有两个类来处理字幕</p>
<ul>
<li>AVMediaSelectionGroup</li>
<li>AVMediaSelectionOption</li>
</ul>
<p><code>AVMediaSelectionOption</code> 用于表示<code>AVAsset</code>备用媒体显示.在前几篇中我讲过一个媒体元数据中有<code>音频轨</code>、<code>视频轨</code>、<code>字幕轨</code>,<code>备用相机角度</code>等.</p>
<p>我们如果想找出字幕的话需要用到<code>AVAsset</code>的<code>availableMediaCharacteristicsWithMediaSelectionOptions</code>属性.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMediaCharacteristic</span>&gt; *availableMediaCharacteristicsWithMediaSelectionOptions <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_8, <span class="number">5</span>_0);</div></pre></td></tr></table></figure>
<p>这个属性会返回一个数组的<code>字符串</code>,这些<code>字符串</code>用于表示保存在资源中可用选项的媒体特征,其实数组中包含的字符串的值为如下：</p>
<ul>
<li>AVMediaCharacteristicVisual 视频</li>
<li>AVMediaCharacteristicAudible 音频</li>
<li>AVMediaCharacteristicLegible 字幕或隐藏式字幕</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">AVMediaSelectionGroup</span> *)mediaSelectionGroupForMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_8, <span class="number">5</span>_0);</div></pre></td></tr></table></figure>
<p>请求可用媒体特性数据后,调用<code>AVAsset</code>的<code>mediaSelectionGroupForMediaCharacteristic:</code>方法.为其传递要检索的选项的特定媒体特征.这个方法返回一个<code>AVMediaSelectionGroup</code>,它作为一个或多个互斥的<code>AVMediaSelectionGroup</code>实例的容器.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadMediaOptions &#123;</div><div class="line">    <span class="built_in">NSString</span> *mc = <span class="built_in">AVMediaCharacteristicLegible</span>;                            <span class="comment">// 1</span></div><div class="line">    <span class="built_in">AVMediaSelectionGroup</span> *group =</div><div class="line">        [<span class="keyword">self</span>.asset mediaSelectionGroupForMediaCharacteristic:mc];          <span class="comment">// 2</span></div><div class="line">    <span class="keyword">if</span> (group) &#123;</div><div class="line">        <span class="built_in">NSMutableArray</span> *subtitles = [<span class="built_in">NSMutableArray</span> array];                 <span class="comment">// 3</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">AVMediaSelectionOption</span> *option <span class="keyword">in</span> group.options) &#123;</div><div class="line">            [subtitles addObject:option.displayName];</div><div class="line">        &#125;</div><div class="line">        [<span class="keyword">self</span>.transport setSubtitles:subtitles];                            <span class="comment">// 4</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span>.transport setSubtitles:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AirPlay"><a href="#AirPlay" class="headerlink" title="AirPlay"></a>AirPlay</h2><p>AirPlay相信大部分iOS开发者都耳熟能详,这个东西是用于无线方式将流媒体音频/视频内容在<code>Apple TV</code>上播放.或者将纯音频内容在多种第三方音频系统中播放(如汽车中内置的CarPlay).如果大家有<code>Apple TV</code>或其它音频系统中的一个,就会觉得这个功能实在太实用了.其实把这个功能整合到我们的APP中十分容易.</p>
<p><code>AVPlayer</code>有一个属性是<code>allowsExternalPlayback</code>,允许启用或者禁用<code>AirPlay</code>播放功能.该属性默认是<code>YES</code>,即在不做任何额外编码的情况下,播放器应用程序也会自动支持<code>AirPlay</code>功能.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> allowsExternalPlayback <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">6</span>_0);</div></pre></td></tr></table></figure>
<p>不过从iOS11之后才有专门针对AirPlay的framework功能API,在以前我们使用<code>Media Player</code>中的<code>MPVolumeView</code>来实现.</p>
<p>示例代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MPVolumeView *volumeView = [[MPVolumeView alloc] init];</div><div class="line">   volumeView.showsVolumeSlider = NO;</div><div class="line">   [volumeView sizeToFit];</div><div class="line">   [transportView addSubview:volumeView];</div></pre></td></tr></table></figure>
<p>当AirPlay可用时,而且WIFI 网络启用时才会显示线路选择按钮.这两个条件只有一个不满足, MPVolumeView 就会自动隐藏按钮.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章讲述了 如何使用AVPlayer以及AVPlayerItem 的一些属性 监听播放进度回调,取 字幕等等.</p>
<p><a href="https://github.com/sunyazhou13/Learning-AV-Foundation-Demos" target="_blank" rel="external">详细demo请参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/5k-airpl
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="Learning AV Foundation" scheme="https://www.sunyazhou.com/tags/Learning-AV-Foundation/"/>
    
  </entry>
  
  <entry>
    <title>NLP分词WordEmbeding</title>
    <link href="https://www.sunyazhou.com/2018/02/04/20180204Word-Embeding/"/>
    <id>https://www.sunyazhou.com/2018/02/04/20180204Word-Embeding/</id>
    <published>2018-02-04T04:24:30.000Z</published>
    <updated>2018-02-04T04:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180204Word-Embeding/wordembeding.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习过程中记录一下python代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 加载包</span></div><div class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> Word2Vec</div><div class="line"><span class="keyword">from</span> gensim.models.word2vec <span class="keyword">import</span> LineSentence</div><div class="line"></div><div class="line"><span class="comment"># 训练模型</span></div><div class="line"><span class="comment"># sentences = LineSentence('wiki.zh.word.text')</span></div><div class="line"><span class="comment"># size：词向量的维度</span></div><div class="line"><span class="comment"># window：上下文环境的窗口大小</span></div><div class="line"><span class="comment"># min_count：忽略出现次数低于min_count的词</span></div><div class="line"><span class="comment"># model = Word2Vec(sentences, size=128, window=5, min_count=5, workers=4)</span></div><div class="line"></div><div class="line"><span class="comment"># 保存模型</span></div><div class="line"><span class="comment"># model.save('word_embedding_128')</span></div><div class="line"></div><div class="line"><span class="comment"># 如果已经保存过模型，则直接加载即可</span></div><div class="line"><span class="comment"># 前面训练并保存的代码都可以省略</span></div><div class="line">model = Word2Vec.load(<span class="string">"word_embedding_128"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 使用模型</span></div><div class="line"><span class="comment"># 返回和一个词语最相关的多个词语以及对应的相关度</span></div><div class="line">items = model.most_similar(<span class="string">u'中国'</span>)</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">	<span class="comment"># 词的内容，词的相关度</span></div><div class="line">	<span class="keyword">print</span> item[<span class="number">0</span>], item[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment"># 返回两个词语之间的相关度</span></div><div class="line">model.similarity(<span class="string">u'男人'</span>,  <span class="string">u'女人'</span>)</div></pre></td></tr></table></figure>
<p>参考分词如下:  </p>
<p><a href="https://www.ltp-cloud.com/demo/" target="_blank" rel="external">哈工大分词</a><br><a href="https://github.com/fxsjy/jieba" target="_blank" rel="external">jieba分词</a><br><a href="https://nlp.stanford.edu/software/segmenter.shtml" target="_blank" rel="external">stanford分词</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180204Word-Embeding/wordembeding.png&quot; alt=&quot;
    
    </summary>
    
      <category term="python开发" scheme="https://www.sunyazhou.com/categories/python%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="python开发" scheme="https://www.sunyazhou.com/tags/python%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
