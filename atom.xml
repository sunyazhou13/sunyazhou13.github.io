<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迈腾大队长</title>
  <subtitle>不断学习, 与时俱进. - 始于2017</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sunyazhou.com/"/>
  <updated>2020-10-16T08:15:07.908Z</updated>
  <id>https://www.sunyazhou.com/</id>
  
  <author>
    <name>sunyazhou</name>
    <email>sunyazhou13@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>修复Xcode Source Editor在masOS的扩展中不显示</title>
    <link href="https://www.sunyazhou.com/2020/10/16/20201016XcodeSourceEditorNotWork/"/>
    <id>https://www.sunyazhou.com/2020/10/16/20201016XcodeSourceEditorNotWork/</id>
    <published>2020-10-16T08:05:42.000Z</published>
    <updated>2020-10-16T08:15:07.908Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201016XcodeSourceEditorNotWork/XcodeSourceEditorCover.jpg"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="问题描述">问题描述</h2>
<p>这几天要对代码进行对齐发现经常用的 XAlign插件不起作用了,一看设置中发现 扩展中没有了Xcode Source Editor <img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201016XcodeSourceEditorNotWork/XcodeSourceEditor.png"></p>
<p>通过网络上查询找到一篇靠谱的方式 特记录下来</p>
<p>终端输入如下 即可出来</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ PATH=/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support:<span class="string">"<span class="variable">$PATH</span>"</span></span><br><span class="line">$ lsregister -f /Applications/Xcode.app</span><br></pre></td></tr></table></figure>
<p>引起的原因</p>
<p>当Xcode的多个副本在同一台机器上时，扩展可能会完全停止工作。在这种情况下，Apple Developer Relations建议重新注册你的Xcode主拷贝到Launch Services(最简单的方法是暂时将lsregister的位置先添加到PATH中):</p>
<p>参考 <a href="https://nshipster.com/xcode-source-extensions/" target="_blank" rel="noopener">https://nshipster.com/xcode-source-extensions/</a></p>
<h1 id="总结">总结</h1>
<p>记录经常遇到的问题.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201016XcodeSourceEditorNotWork/XcodeSourceEditorCover.jpg
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Pod spec集成第三framework和.a工作记录</title>
    <link href="https://www.sunyazhou.com/2020/10/10/20201010PodSpec/"/>
    <id>https://www.sunyazhou.com/2020/10/10/20201010PodSpec/</id>
    <published>2020-10-09T23:52:18.000Z</published>
    <updated>2020-10-10T00:46:45.792Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201010PodSpec/cocoapods.png"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<p>最近开发过程经常遇到工程中集成第三方工程中的时候 使用pod的方式集成.总忘记链接 第三方库的方式和podspec的写法.所以记录下来容易忘记的内容</p>
<h2 id="podspec-创建">podspec 创建</h2>
<p>我们在测试工程目录下创建一个目录 起名叫 demoframeworks 然后在这个目录下执行如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pod spec create spec名称</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>spec名称</code> 自己起个名字哈</p>
</blockquote>
<p>本地会生成一个spec模板 然后用文本编辑器编译一下spec文件,这里我们拿声网的sdk举例.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|spec|</span></span><br><span class="line">  spec.name         = <span class="string">"specdemo"</span></span><br><span class="line">  spec.version      = <span class="string">"0.0.1"</span></span><br><span class="line">  spec.summary      = <span class="string">"test pod spec"</span></span><br><span class="line">  spec.description  = <span class="string">"demo test测试"</span></span><br><span class="line"></span><br><span class="line">  spec.homepage     = <span class="string">"https://www.sunyazhou.com/"</span></span><br><span class="line">  spec.license      = <span class="string">"MIT"</span></span><br><span class="line">  spec.author             = &#123; <span class="string">"東引甌越"</span> =&gt; <span class="string">"https://www.sunyazhou.com/"</span> &#125;</span><br><span class="line">  spec.source       = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"git@gitee.com:sunyazhou/sunyazhou13.github.io-images.git"</span>&#125;</span><br><span class="line">  <span class="comment">#加载第三方framework写法</span></span><br><span class="line">  spec.vendored_frameworks = <span class="string">'AgoraRtcCryptoLoader.framework'</span>,<span class="string">'AgoraRtcEngineKit.framework'</span>,<span class="string">'AgoraRtmKit.framework'</span>,<span class="string">'AgoraSigKit.framework'</span></span><br><span class="line">  <span class="comment">#加载第三方.a</span></span><br><span class="line">  <span class="comment">#spec.vendored_libraries = 'libProj4.a', 'libJavaScriptCore.a'</span></span><br><span class="line">  <span class="comment">#系统内置动态库的依赖</span></span><br><span class="line">  spec.frameworks = <span class="string">'Photos'</span>,<span class="string">'PhotosUI'</span>,<span class="string">'CoreMedia'</span>,<span class="string">'Foundation'</span>,<span class="string">'CoreGraphics'</span>,<span class="string">'CoreMotion'</span>,<span class="string">'QuartzCore'</span>,<span class="string">'MobileCoreServices'</span>,<span class="string">'Security'</span>,<span class="string">'CoreText'</span>,<span class="string">'VideoToolbox'</span>,<span class="string">'CoreTelephony'</span>,<span class="string">'AudioToolbox'</span>,<span class="string">'SystemConfiguration'</span>,<span class="string">'AVFoundation'</span>, <span class="string">'CoreLocation'</span>,<span class="string">'AdSupport'</span>,<span class="string">'OpenGLES'</span>,<span class="string">'CoreML'</span></span><br><span class="line">  <span class="comment">#内置静态库的依赖</span></span><br><span class="line">  spec.libraries = <span class="string">"iconv"</span>, <span class="string">"c++"</span>, <span class="string">"z.1.1.3"</span> ,<span class="string">"z"</span>,<span class="string">"resolv"</span> ,<span class="string">"sqlite3"</span>,<span class="string">"icucore"</span>,<span class="string">"z.1.2.5"</span>  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然后在Podfile内容里面添加</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">target <span class="string">'PodSpecDemo'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Comment the next line if you don't want to use dynamic frameworks</span></span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 添加这行</span></span><br><span class="line">  pod <span class="string">'specdemo'</span>, :path=&gt;<span class="string">'./demoframeworks'</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>注意这里的<code>specdemo</code>是我们给集成本地pod起的名字 最好和创建的spec名字保持一致.</p>
<p>然后 pod install</p>
<p>最后工程就变成了我们想要的样子</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201010PodSpec/cocoapods1.png"></p>
<h1 id="总结">总结</h1>
<p>记录经常忘记的知识点 防止着急用的时候各种找,更多spec的写法 <a href="https://guides.cocoapods.org/syntax/podspec.html#vendored_libraries" target="_blank" rel="noopener">参考官方的api</a></p>
<p><a href="https://github.com/sunyazhou13/PodSpecDemo" target="_blank" rel="noopener">Demo工程点击这里下载</a></p>
<p>工程中移除了framework 因为github不允许上传超过100m以上的文件.很坑 大家下载后看下写法就好了.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201010PodSpec/cocoapods.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用Xcode配置文件来管理不同的环境设置</title>
    <link href="https://www.sunyazhou.com/2020/10/04/20201004XcodeBuildXcconfigFile/"/>
    <id>https://www.sunyazhou.com/2020/10/04/20201004XcodeBuildXcconfigFile/</id>
    <published>2020-10-04T03:58:03.000Z</published>
    <updated>2020-10-04T06:48:31.121Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/XcodeBuildConfigrationFile1.png"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="背景">背景</h2>
<p>最近工程遇到了一个环境切换的问题,想到了 *.xcconfig 文件的用处. 查了一圈搜索引擎大家的搞法真是各种抄袭.遇到的问题没有一个能正式解决的</p>
<p>下面是我遇到的问题,我尝试解决一下.</p>
<ul>
<li>创建xcconfig后 cocoapods有警告</li>
<li>xcconfig继承 需要注意的点</li>
<li>解决完警告 编译打印问题</li>
</ul>
<h3 id="创建">创建</h3>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/xcconfig1.png"></p>
<p>下面这里默认勾选tagget (Xcode 不会默认勾选) <img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/xcconfig2.png"></p>
<p>创建完了 选择我们自己的配置 <img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/xcconfig3.png"></p>
<h4 id="先说第一个警告问题">先说第一个警告问题</h4>
<p>搞完后我们来看下pod install后出现的警告</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/xcconfig4.png"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[!] CocoaPods did not <span class="built_in">set</span> the base configuration of your project because your project already has a custom config <span class="built_in">set</span>. In order <span class="keyword">for</span> CocoaPods integration to work at all, please either <span class="built_in">set</span> the base configurations of the target `XcodeConfigDemo` to `Target Support Files/Pods-XcodeConfigDemo/Pods-XcodeConfigDemo.debug.xcconfig` or include the `Target Support Files/Pods-XcodeConfigDemo/Pods-XcodeConfigDemo.debug.xcconfig` <span class="keyword">in</span> your build configuration (`XcodeConfigDemo/DemoDebug.xcconfig`).</span><br><span class="line"></span><br><span class="line">[!] CocoaPods did not <span class="built_in">set</span> the base configuration of your project because your project already has a custom config <span class="built_in">set</span>. In order <span class="keyword">for</span> CocoaPods integration to work at all, please either <span class="built_in">set</span> the base configurations of the target `XcodeConfigDemo` to `Target Support Files/Pods-XcodeConfigDemo/Pods-XcodeConfigDemo.release.xcconfig` or include the `Target Support Files/Pods-XcodeConfigDemo/Pods-XcodeConfigDemo.release.xcconfig` <span class="keyword">in</span> your build configuration (`XcodeConfigDemo/DemoRelease.xcconfig`).</span><br></pre></td></tr></table></figure>
<p>先说如何解决 当我们生成了自己的.xcconfig文件后默认是cocoapods的配置,让我们改成了自己的并没有管理cocoapod.所以cocoapods对工程的build setting有可能因为我们的改动而不生效,为了解决这个问题我们需要在自己的xcconfig中导入cocoapods的 xcconfig</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/xcconfig5.png"></p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/xcconfig6.png"></p>
<p>这里我顺便声明了2个变量 在 debug和release配置里,为了下面测试变量在工程中使用.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// debug</span><br><span class="line">SUNYAZHOU_COM = @<span class="string">"https://www.sunyazhou.com/"</span></span><br><span class="line">SYZ_TEST = @<span class="string">"https://xxxxx.com/"</span></span><br><span class="line"><span class="comment">#include "../Pods/Target Support Files/Pods-XcodeConfigDemo/Pods-XcodeConfigDemo.release.xcconfig"</span></span><br><span class="line"><span class="comment">#include "DemoCommon.xcconfig"</span></span><br><span class="line"></span><br><span class="line">//release</span><br><span class="line">SUNYAZHOU_COM = @<span class="string">"https://www.sunyazhou.com/"</span></span><br><span class="line">SYZ_TEST = @<span class="string">"https://xxxxx.com/"</span></span><br><span class="line"><span class="comment">#include "../Pods/Target Support Files/Pods-XcodeConfigDemo/Pods-XcodeConfigDemo.debug.xcconfig"</span></span><br><span class="line"><span class="comment">#include "DemoCommon.xcconfig"</span></span><br></pre></td></tr></table></figure>
<p>ok 下面 pod install后 警告就没了.</p>
<h4 id="xcconfig继承-需要注意的点">xcconfig继承 需要注意的点</h4>
<p>这里我加了一个通用的 DemoCommon.xcconfig 配置,为了向外输出公共的宏变量.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/xcconfig7.png"></p>
<p><code>GCC_PREPROCESSOR_DEFINITIONS</code> . 表示继承通用环境变量 要加入预处理，即加上这句，代码中才可以调到相关的宏定义</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GCC_PREPROCESSOR_DEFINITIONS = $(inherited) SUNYAZHOU_COM=<span class="string">'$(SUNYAZHOU_COM)'</span> SYZ_TEST=<span class="string">'$(SYZ_TEST)'</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意多个变量的格式:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GCC_PREPROCESSOR_DEFINITIONS = $(inherited)空格(不能加换行)+SUNYAZHOU_COM=<span class="string">'$(SUNYAZHOU_COM)'</span>+空格(不能加换行)SYZ_TEST=<span class="string">'$(SYZ_TEST)'</span></span><br></pre></td></tr></table></figure>
<p>我这里遇到的坑是加了20多个变量, 写了一堆.最后发现不像上边的格式那样就编译不过找不到变量.</p>
<h4 id="解决完警告-编译打印问题">解决完警告 编译打印问题</h4>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/xcconfig8.png"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Unexpected <span class="string">'@'</span> <span class="keyword">in</span> program</span><br></pre></td></tr></table></figure>
<p>出现这个问题是因为宏变量没有转义</p>
<p>必须将下面的变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//转换前</span><br><span class="line">SUNYAZHOU_COM = @<span class="string">"https://www.sunyazhou.com/"</span></span><br><span class="line">SYZ_TEST = @<span class="string">"https://xxxxx.com/"</span></span><br><span class="line"></span><br><span class="line">//转换后</span><br><span class="line">SUNYAZHOU_COM = @<span class="string">"https:\/\/www.sunyazhou.com/"</span></span><br><span class="line">SYZ_TEST = @<span class="string">"https:\/\/xxxxx.com/"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/xcconfig9.png"></p>
<p>转换完能编译过了 但是还是有警告,应该是没转义对 不过 能正常输出了. 哪位高手如果知道可以留言给我 多谢！</p>
<h1 id="总结">总结</h1>
<p>有些知识不经常使用容易忘记, xcconfig就是这样.工程 demo我已经附在了下方 感兴趣的同学可以下载.</p>
<p><a href="https://github.com/sunyazhou13/XcodeConfigDemo" target="_blank" rel="noopener">本文demo</a></p>
<p><a href="https://nshipster.com/xcconfig/" target="_blank" rel="noopener">参考Mattt 大佬的 Xcode Build Configuration Files</a><br>
<a href="https://www.appcoda.com/xcconfig-guide/" target="_blank" rel="noopener">Using Xcode Configuration (.xcconfig) to Manage Different Build Settings</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20201004XcodeBuildXcconfigFile/XcodeBuildConfigrationFile1.
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>阿里、字节：一套高效的iOS面试题之性能优化</title>
    <link href="https://www.sunyazhou.com/2020/09/22/20200922iOSinterviewPerformanceOptimization/"/>
    <id>https://www.sunyazhou.com/2020/09/22/20200922iOSinterviewPerformanceOptimization/</id>
    <published>2020-09-22T01:42:48.000Z</published>
    <updated>2020-09-22T01:51:26.889Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<p>本篇我们来讲一下 <a href="https://mp.weixin.qq.com/s/bDnsaD__ZpdHIk3_So382w" target="_blank" rel="noopener">阿里、字节：一套高效的iOS面试题</a> 中的性能优化相关的问题.</p>
<h2 id="性能优化">性能优化</h2>
<p>主要的优化如下:</p>
<ol type="1">
<li>如何做启动优化，如何监控</li>
<li>如何做卡顿优化，如何监控</li>
<li>如何做耗电优化，如何监控</li>
<li>如何做网络优化，如何监控</li>
</ol>
<p>首先优化要从多维度进行才有较大的收益</p>
<p>这里推荐大家认真分析一下自己的工程并研读一下戴铭老师的<a href="https://ming1016.github.io/2019/12/07/how-to-analyze-startup-time-cost-in-ios/" target="_blank" rel="noopener">如何对 iOS 启动阶段耗时进行分析</a> 文章</p>
<p>必须要从多维度分析并入手.</p>
<p>运行时初始化过程 分为：</p>
<ul>
<li>加载类扩展</li>
<li>加载 C++静态对象</li>
<li>调用+load 函数</li>
<li>执行 main 函数</li>
<li>Application 初始化，到 applicationDidFinishLaunchingWithOptions 执行完 初始化帧渲染，到 viewDidAppear 执行完，用户可见可操作。</li>
</ul>
<h1 id="总结">总结</h1>
<p>性能优化部分 并没有标准的答案,所以分享给大家一篇重要的文章作为抓手和参考,只要达到预期的优化目的并保证程序稳定即可.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS面试题" scheme="https://www.sunyazhou.com/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>阿里、字节：一套高效的iOS面试题之视图&amp;图形</title>
    <link href="https://www.sunyazhou.com/2020/09/20/20200920UIViewGraphic/"/>
    <id>https://www.sunyazhou.com/2020/09/20/20200920UIViewGraphic/</id>
    <published>2020-09-20T03:40:47.000Z</published>
    <updated>2020-09-20T07:27:17.819Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<p>本篇我们来讲一下 <a href="https://mp.weixin.qq.com/s/bDnsaD__ZpdHIk3_So382w" target="_blank" rel="noopener">阿里、字节：一套高效的iOS面试题</a> 中的视图&amp;图形相关的问题.</p>
<h2 id="视图图像相关">视图&amp;图像相关</h2>
<p>主要问题列表如下:</p>
<ol type="1">
<li>AutoLayout的原理，性能如何</li>
<li>UIView &amp; CALayer的区别</li>
<li>事件响应链</li>
<li>drawrect &amp; layoutsubviews调用时机</li>
<li>UI的刷新原理</li>
<li>隐式动画 &amp; 显示动画区别</li>
<li>什么是离屏渲染</li>
<li>imageName&amp;imageWithContentsOfFile区别</li>
<li>多个相同的图片，会重复加载吗</li>
<li>图片是什么时候解码的，如何优化</li>
<li>图片渲染怎么优化</li>
<li>如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决</li>
</ol>
<h3 id="autolayout的原理性能如何">1.AutoLayout的原理，性能如何?</h3>
<h4 id="autolayout的原理">AutoLayout的原理</h4>
<blockquote>
<p>来历 一般大家都会认为Auto Layout这个东西是苹果自己搞出来的，其实不然，早在1997年Alan Borning, Kim Marriott, Peter Stuckey等人就发布了《Solving Linear Arithmetic Constraints for User Interface Applications》论文（<a href="http://constraints.cs.washington.edu/solvers/uist97.html" target="_blank" rel="noopener">论文地址:http://constraints.cs.washington.edu/solvers/uist97.html</a>）提出了在解决布局问题的Cassowary constraint-solving算法实现，并且将代码发布在他们搭建的<a href="http://constraints.cs.washington.edu/cassowary/" target="_blank" rel="noopener">Cassowary网站上http://constraints.cs.washington.edu/cassowary/</a>。后来更多开发者用各种语言来写Cassowary，比如说pybee用python写的https://github.com/pybee/cassowary。自从它发布以来JavaScript，.NET，JAVA，Smalltall和C++都有相应的库。2011年苹果将这个算法运用到了自家的布局引擎中，美其名曰Auto Layout。</p>
</blockquote>
<p>论文下载链接比较慢,我下载了一份<a href="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200920UIViewGraphic/Cassowary.pdf" target="_blank" rel="noopener">Cassowary原文放到了我的博客 大家可以自由下载</a>.</p>
<p><strong>AutoLayout的原理就是用Cassowary算法来将布局问题抽象成线性不等式，并分解成多个位置间的约束</strong><br>
因为多了计算视图大小frame的过程,所以性能肯定没有指定Frame坐标要快.</p>
<p>详细的原理以及高阶原理请参考戴铭老师的文章 <a href="http://www.starming.com/2015/11/03/deeply-analyse-autolayout/" target="_blank" rel="noopener">戴铭老师写的 深入剖析Auto Layout，分析iOS各版本新增特性</a></p>
<h4 id="性能如何">性能如何?</h4>
<p>下面是<a href="https://developer.apple.com/videos/play/wwdc2018/220/" target="_blank" rel="noopener">WWDC2018 High Performance Auto Layout</a>中对比的iOS12和iOS11下分别使用自动布局的性能对比现场.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200920UIViewGraphic/HighPerformanceAutoLayoutiOS11iOS12Compare.gif"></p>
<p>经过实验得出如下图标结论:</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200920UIViewGraphic/HighPerformanceAutoLayoutResult.png"></p>
<p>iOS12之前，视图嵌套的数量对性能的影响是呈指数级增长的，而iOS12优化之后对性能的影响是线性增长，对性能消耗不大。</p>
<p>无论如何优化也肯定不如CGRectFrame那样的设置更加直接,性能更好.</p>
<h3 id="uiview-calayer的区别">2.UIView &amp; CALayer的区别</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">区别</th>
<th style="text-align: center;">UIView</th>
<th style="text-align: center;">CALayer</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">继承父类</td>
<td style="text-align: center;">UIView:UIResponder:NSObject</td>
<td style="text-align: center;">CALayer:NSObject</td>
</tr>
<tr class="even">
<td style="text-align: left;">用途</td>
<td style="text-align: center;">可以处理触摸事件</td>
<td style="text-align: center;">不处理用户的交互,不参与响应事件传递</td>
</tr>
<tr class="odd">
<td style="text-align: left;">两者关系</td>
<td style="text-align: center;">有一个CALayer成员变量 eg: view.layer</td>
<td style="text-align: center;">是UIView的成员变量</td>
</tr>
<tr class="even">
<td style="text-align: left;">分工</td>
<td style="text-align: center;">处理交互层事件并包装各种图形的简单设置</td>
<td style="text-align: center;">底层渲染图形,支持动画</td>
</tr>
</tbody>
</table>
<h3 id="事件响应链">3.事件响应链</h3>
<p>下面这篇文章我已经在前几篇将runloop的时候提了不止一次,前列建议阅读,快手的同事大部分都以这个理解为标准</p>
<p><a href="https://mp.weixin.qq.com/s/9rvSRt4kfpy7e87EJoaJOQ" target="_blank" rel="noopener">iOS触摸事件全家桶</a></p>
<h3 id="drawrect-layoutsubviews调用时机">4. drawrect &amp; layoutsubviews调用时机</h3>
<p><code>layoutSubviews:</code>(相当于layoutSubviews()函数)在以下情况下会被调用：</p>
<ol type="1">
<li>init初始化不会触发layoutSubviews。</li>
<li>addSubview会触发layoutSubviews。</li>
<li>设置view的Frame会触发layoutSubviews (frame发生变化触发)。</li>
<li>滚动一个UIScrollView会触发layoutSubviews。</li>
<li>旋转Screen会触发父UIView上的layoutSubviews事件。</li>
<li>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。</li>
<li>直接调用setLayoutSubviews。</li>
</ol>
<p><code>drawrect:</code>(drawrect()函数)在以下情况下会被调用：</p>
<ol type="1">
<li><code>drawrect:</code>是在UIViewController的<code>loadView:</code>和<code>ViewDidLoad:</code>方法之后调用.</li>
<li>当我们调用<code>[UIFont的 sizeToFit]</code>后,会触发系统自动调用<code>drawRect:</code></li>
<li>当设置UIView的contentMode或者Frame后会立即触发触发系统调用<code>drawRect:</code></li>
<li>直接调用<code>setNeedsDisplay</code>设置标记 或<code>setNeedsDisplayInRect:</code>的时候会触发<code>drawRect:</code></li>
</ol>
<blockquote>
<p>知识点扩充: 当我们操作drawRect方法的时候实际是在操作内存中存放视图的backingStore区域,用于后续图形的渲染操作,如果不理解可以看下<a href="https://www.sunyazhou.com/2017/10/16/20171016UIViewRendering/">UIView的渲染过程</a>.</p>
</blockquote>
<h3 id="ui的刷新原理">5.UI的刷新原理</h3>
<p>这个问题我不知道问的是不是iOS离屏渲染过程,我来简单的回到一下这个吧</p>
<p>iOS 的<code>MainRunloop</code> 是一个60fps 的回调,也就是说16.7ms(毫秒)会绘制一次屏幕在这过程中要完成以下的工作:</p>
<ul>
<li>view的缓冲区创建</li>
<li>view内容的绘制(如果重写了 drawRect)</li>
<li>接收和处理系统的触摸事件</li>
</ul>
<p>我们看到的UI图形实际上是CPU和GPU不断配合工作的结果.经过<a href="https://www.sunyazhou.com/2017/10/16/20171016UIViewRendering/">UIView的渲染过程</a> 后我们的UI会不间断的接收系统图给我们的事件.</p>
<p>由于主线程的runloop 一直在回调,我们的UI就得到了刷新的窗口,是渲染还是处理事件都是因为runloop不断工作的结果.前几篇我们学过 main线程的runloop默认是启动的.因为我们响应交互.</p>
<p>不知道我这样回答是否满足这个问题的答案.如果回答的不对烦请下方评论区留言 告知我将持续改进.</p>
<h3 id="隐式动画-显示动画区别">6.隐式动画 &amp; 显示动画区别</h3>
<p>隐式动画一直存在 如需关闭需设置<br>
显式动画是不存在，如需显式 要开启</p>
<p>只需要观察动画执行完成的结果 比如: 一个简单UIView的frame移动 如果从A点移动到B点 移动完成 回到原始位置就是隐式动画</p>
<p>Core Animation 是显式动画.因为它既可以直接对其layer属性做动画，也可以覆盖默认的图层行为.</p>
<h3 id="imagenameimagewithcontentsoffile区别">7.imageName&amp;imageWithContentsOfFile区别</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">区别</th>
<th style="text-align: center;">UIView</th>
<th style="text-align: center;">imageWithContentsOfFile</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">不同点</td>
<td style="text-align: center;">会图片缓存到内存中</td>
<td style="text-align: center;">无缓存</td>
</tr>
</tbody>
</table>
<h3 id="什么是离屏渲染">8.什么是离屏渲染</h3>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200920UIViewGraphic/CoreAnimationPipeline.jpg"></p>
<p><a href="https://zhuanlan.zhihu.com/p/72653360" target="_blank" rel="noopener">iOS离屏渲染的深入研究</a></p>
<h3 id="多个相同的图片会重复加载吗">9.多个相同的图片，会重复加载吗</h3>
<p>不会,GPU有 像素点缓存的mask.</p>
<h3 id="图片是什么时候解码的如何优化">10.图片是什么时候解码的，如何优化</h3>
<p>是加载到内存中,从UIImge-&gt;CGImage-&gt;CGImageSourceCreateWithData(data) 创建ImageSource变成bitmap位图,这些工作都是CoreAnimation在图片被加载到内存中存在在backingStore里,送给GPU流水线处理之前被解码.</p>
<h4 id="如何优化">如何优化</h4>
<p>自己手动操作图片的编码API</p>
<p>CGImageSource开头的哪些,根据合理利用时机和操作系统资源调整出一套缓存小加载快的库.</p>
<p>参考<a href="https://github.com/pinterest/PINRemoteImage" target="_blank" rel="noopener">PINRemoteImage</a>或者<a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="noopener">YYWebImage</a>开源</p>
<h3 id="图片渲染怎么优化">11.图片渲染怎么优化</h3>
<p>可以从阴影,圆角入手.帧率,电量,图片的锯齿等等.</p>
<p><a href="https://www.jianshu.com/p/748f9abafff8" target="_blank" rel="noopener">iOS开发-视图渲染与性能优化</a></p>
<h3 id="如果gpu的刷新率超过了ios屏幕60hz刷新率是什么现象怎么解决">12.如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决</h3>
<p>现象是 图形清晰,场景逼真,但是一般arm芯片的GPU 刷新超过60Hz一定会超级费电,手机发热导致降频.FPS降低,因为低能耗电量不足,无法支持GPU高刷新率</p>
<p>解决办法只能用xcode自带工具检测,看渲染过程哪里可以优化.</p>
<h1 id="总结">总结</h1>
<p>简单回答了一些图形相关的问题,大部分都是iOS离屏渲染,这个地方大家要认真学习.很多资料看起来比较耗时.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS面试题" scheme="https://www.sunyazhou.com/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>阿里、字节：一套高效的iOS面试题之多线程</title>
    <link href="https://www.sunyazhou.com/2020/09/19/20200919GCD/"/>
    <id>https://www.sunyazhou.com/2020/09/19/20200919GCD/</id>
    <published>2020-09-19T03:09:28.000Z</published>
    <updated>2020-09-19T08:06:40.703Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<p>本篇我们来讲一下 <a href="https://mp.weixin.qq.com/s/bDnsaD__ZpdHIk3_So382w" target="_blank" rel="noopener">阿里、字节：一套高效的iOS面试题</a> 中的多线程相关的问题.</p>
<h2 id="多线程">多线程</h2>
<p>这一篇我们来解答下多线程问题,主要以GCD为主:</p>
<ul>
<li>iOS开发中有多少类型的线程？分别对比</li>
<li>GCD有哪些队列，默认提供哪些队列</li>
<li>GCD有哪些方法api</li>
<li>GCD主线程 &amp; 主队列的关系</li>
<li>如何实现同步，有多少方式就说多少</li>
<li><code>dispatch_once</code>实现原理</li>
<li>什么情况下会死锁</li>
<li>有哪些类型的线程锁，分别介绍下作用和使用场景</li>
<li>NSOperationQueue中的<code>maxConcurrentOperationCount</code>默认值</li>
<li>NSTimer、CADisplayLink、<code>dispatch_source_t</code> 的优劣</li>
</ul>
<h3 id="ios开发中有多少类型的线程分别对比">1.iOS开发中有多少类型的线程?分别对比</h3>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">线程类型</th>
<th style="text-align: center;">对比</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>pthread_t</code></td>
<td style="text-align: center;">跨平台C语言标准库中的多线程框架</td>
<td style="text-align: center;">过于底层使用很麻烦,需要封装使用.</td>
</tr>
<tr class="even">
<td style="text-align: left;">GCD(Grand Central Dispatch)</td>
<td style="text-align: center;">iOS5后苹果推出的双核CPU优化的多线程框架,对A5以后的CPU有很多底层优化,C函数的形式调用 有点面向过程,不能直接设置并发数,需要写一些代码曲线方式实现并发</td>
<td style="text-align: center;">推荐使用</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NSOperation &amp; NSOperationQueue</td>
<td style="text-align: center;">更加面向对象 可以设置并发数量</td>
<td style="text-align: center;">GCD 的封装</td>
</tr>
</tbody>
</table>
<blockquote>
<p>苹果底层库经过自己多年实践没有问题才会推荐给上层使用, eg:siri. 所以NSOperation实际上是苹果的ver1.0的多线程SDK,对GCD封装和<code>pthread_t</code>的封装.</p>
</blockquote>
<h3 id="gcd有哪些队列默认提供哪些队列">2.GCD有哪些队列，默认提供哪些队列</h3>
<ul>
<li>1.主线程串行队列</li>
<li>2.全局并行队列</li>
<li>3.自定义队列(可自行设置<code>串/并</code>的参数<code>DISPATCH_QUEUE_SERIAL</code>和<code>DISPATCH_QUEUE_CONCURRENT</code>)</li>
</ul>
<p>下面我整理了一个表格:</p>
<table>
<colgroup>
<col style="width: 22%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">队列类型</th>
<th style="text-align: center;">对应函数</th>
<th style="text-align: center;">系统默认提供/自定义</th>
<th style="text-align: center;">优先级</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">主线程串行队列(mian)</td>
<td style="text-align: center;"><code>dispatch_get_main_queue()</code></td>
<td style="text-align: center;">系统</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">全局并行队列(global)</td>
<td style="text-align: center;"><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code></td>
<td style="text-align: center;">系统</td>
<td style="text-align: center;">系统提供参数设置</td>
</tr>
<tr class="odd">
<td style="text-align: left;">自定义并行队列(Concurrent)</td>
<td style="text-align: center;"><code>dispatch_queue_create("com.sunyazhou.self.queue.concurrent", DISPATCH_QUEUE_CONCURRENT)</code></td>
<td style="text-align: center;">自定义</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">自定义串行队列(Serial)</td>
<td style="text-align: center;"><code>dispatch_queue_create("com.sunyazhou.self.queue.serial", DISPATCH_QUEUE_SERIAL)</code></td>
<td style="text-align: center;">自定义</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code> 其中的第一个参数就是队列的优先级,具体对于优先级QOS如下:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">GCD全局队列优先级宏定义</th>
<th style="text-align: center;">对应枚举数值</th>
<th style="text-align: left;">对应Qos</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>DISPATCH_QUEUE_PRIORITY_HIGH</code></td>
<td style="text-align: center;">2</td>
<td style="text-align: left;"><code>QOS_CLASS_USER_INITIATED</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code></td>
<td style="text-align: center;">0</td>
<td style="text-align: left;"><code>QOS_CLASS_DEFAULT</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>DISPATCH_QUEUE_PRIORITY_LOW</code></td>
<td style="text-align: center;">-2</td>
<td style="text-align: left;"><code>QOS_CLASS_UTILITY</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code></td>
<td style="text-align: center;"><code>INT16_MIN</code></td>
<td style="text-align: left;"><code>QOS_CLASS_BACKGROUND</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>其中<code>dispatch_get_global_queue</code>的第二个参数flag只是一个苹果予保留字段，通常我们传0（你可以试试传1应该队列创建失败）</p>
</blockquote>
<h3 id="gcd有哪些方法api">3.GCD有哪些方法api</h3>
<ul>
<li><p>队列相关API</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_get_main_queue(<span class="keyword">void</span>) <span class="comment">//获取主线程队列</span></span><br><span class="line">dispatch_get_global_queue(intptr_t identifier, uintptr_t flags) <span class="comment">//获取全局队列</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *_Nullable label,dispatch_queue_attr_t _Nullable attr) <span class="comment">//创建自定义队列 (一般大家都用域名倒置来区分队列的唯一标识,苹果对标识符是否一致在iOS10后有优化请注意.)</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>执行API</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block) <span class="comment">//在某队列开启异步线程 block&#123;&#125;花括号内的代码将在某队列异步运行</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue, DISPATCH_NOESCAPE dispatch_block_t block) <span class="comment">//在某队列开启同步线程 block&#123;&#125;花括号内的代码将在某队列同步运行</span></span><br><span class="line">dispatch_after(dispatch_time_t when, <span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block) <span class="comment">//GCD定时器 多久后执行 block</span></span><br><span class="line"><span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *predicate, DISPATCH_NOESCAPE dispatch_block_t block) <span class="comment">//单次操作 (单位时间内只允许一个线程进入操作系统的临界区,一般创建单利时使用)这个变量可以区分冷热启动.</span></span><br><span class="line">dispatch_apply(size_t iterations, <span class="built_in">dispatch_queue_t</span> DISPATCH_APPLY_QUEUE_ARG_NULLABILITY queue, DISPATCH_NOESCAPE <span class="keyword">void</span> (^block)(size_t)) <span class="comment">//向队列中追加任务操作并等待处理执行结束.</span></span><br><span class="line">dispatch_barrier_async()  <span class="comment">//将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入到队列，然后等待自己的任务结束后才执行后面任务</span></span><br><span class="line">dispatch_barrier_sync()  <span class="comment">//将自己的任务插入到队列的时候，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>调度组API</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_group_create(<span class="keyword">void</span>) <span class="comment">//创建GCD 调度组</span></span><br><span class="line">dispatch_group_async(dispatch_group_t group, <span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block) <span class="comment">//调度组开启异步线程</span></span><br><span class="line">dispatch_group_enter() <span class="comment">//调度组信号量 需要和leave成对出现.</span></span><br><span class="line">dispatch_group_leave() <span class="comment">//调度组信号量 需要和enter成对出现.</span></span><br><span class="line">dispatch_group_notify() <span class="comment">//调度组任务完成通知调用方 操作(一般都回到主线程)</span></span><br><span class="line">dispatch_group_wait() <span class="comment">//整个调度组 阻塞操作.只等待不做结束处理</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>信号量API</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_semaphore_create(intptr_t value) <span class="comment">//创建信号量 (可以理解为是线程锁)</span></span><br><span class="line">dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) <span class="comment">//信号-1</span></span><br><span class="line">dispatch_semaphore_signal(dispatch_semaphore_t dsema) <span class="comment">//信号+1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>调度资源API</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_source_create() </span><br><span class="line">dispatch_source_set_timer()</span><br><span class="line">dispatch_source_set_event_handler()</span><br><span class="line">dispatch_activate()</span><br><span class="line">dispatch_resume()</span><br><span class="line">dispatch_suspend()</span><br><span class="line">dispatch_source_cancel()</span><br><span class="line">dispatch_source_testcancel()</span><br><span class="line">dispatch_source_set_cancel_handler()</span><br><span class="line">dispatch_notify()</span><br><span class="line">dispatch_get_context()</span><br><span class="line">dispatch_set_contex()</span><br><span class="line">dispatch_queue_set_specific() 给队列设置标识</span><br><span class="line">dispatch_queue_get_specific() 取出队列标识</span><br><span class="line">dispatch_get_specific() 查询线程标识</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="gcd主线程-主队列的关系">4.GCD主线程 &amp; 主队列的关系</h3>
<p>提交到主队列的任务在主线程执行.</p>
<h3 id="如何实现同步有多少方式就说多少">5.如何实现同步，有多少方式就说多少</h3>
<ul>
<li><code>dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block)</code> 在某队列开启同步线程</li>
<li>dispatch_barrier_sync() 障碍锁的方式同步</li>
<li>dispatch_group_create() + dispatch_group_wait()</li>
<li>dispatch_apply() 插队追加 操作同步</li>
<li>dispatch_semaphore_create() + dispatch_semaphore_wait() 信号量锁</li>
<li>串行NSOperationQueue队列并发数为1的时候 [NSOpertaion start] 启动任务即使同步操作 (NSOperationQueue.maxConcurrentOperationCount = 1)</li>
<li><code>pthread_mutex</code>底层锁函数</li>
<li>上层应用层封装的NSLock</li>
<li>NSRecursiveLock 递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中</li>
<li>NSConditionLock &amp; NSCondition 条件锁</li>
<li><span class="citation" data-cites="synchronized">@synchronized</span> 同步操作 单位时间内只允许一个线程进入临界区</li>
<li>dispatch_once() 单位时间内只允许一个线程进入临界区 ...</li>
</ul>
<h3 id="dispatch_once实现原理">6.<code>dispatch_once</code>实现原理</h3>
<p>这个问题问的很傻吊也很高超.因为要解释清楚所有步骤需要记住里面所有代码</p>
<p>我认为这个问题应该从操作系统层面回答, 这个问题的核心是操作系统返回状态决定的,<strong>单位时间内操作系统只允许一个线程进入临界区,进入临界区的线程会被标记</strong></p>
<p>回归到代码就是</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dispatch_once(dispatch_once_t *val, dispatch_block_t block)  </span><br><span class="line">	|_____dispatch_once_f(val, block, _dispatch_Block_invoke(block))  </span><br><span class="line">		|_______&amp;l-&gt;dgo_once  // &amp;l-&gt;dgo_once 地址中存储的值。显然若该值为DLOCK_ONCE_DONE，即为once已经执行过</span><br></pre></td></tr></table></figure>
<p><code>dgo_once</code>是<code>dispatch_once_gate_s</code>的成员变量</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dispatch_once_gate_s &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		dispatch_gate_s dgo_gate;</span><br><span class="line">		uintptr_t dgo_once;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; dispatch_once_gate_s, *dispatch_once_gate_t;</span><br></pre></td></tr></table></figure>
<p>有个内联函数<code>static inline bool _dispatch_once_gate_tryenter(dispatch_once_gate_t l)</code></p>
<p>这个内联函数返回一个 原子性操作的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return os_atomic_cmpxchg(&amp;l-&gt;dgo_once, DLOCK_ONCE_UNLOCKED,(uintptr_t)_dispatch_lock_value_for_self(), relaxed)</span><br></pre></td></tr></table></figure>
<p>比较+交换 的原子操作。比较 <code>&amp;l-&gt;dgo_once</code> 的值是否等于 <code>DLOCK_ONCE_UNLOCKED</code></p>
<p>这样就实现了我们的执行1次的GCD API.</p>
<p><a href="https://juejin.im/post/6844904143753052174" target="_blank" rel="noopener">dispatch_once的底层实现</a></p>
<h3 id="什么情况下会死锁">7.什么情况下会死锁</h3>
<p>造成死锁的主要是 线程信息不对称,出现A等B的同时 B也在等A的情况.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 在主线程中执行这句代码</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"这里死锁了"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>主线程一直不会执行完,追加到主线程同步执行的任务显然惨死.卡住主线程无法自拔.</p>
<p>其它的情况 都是资源产生竞争或者调用lock的函数没有调用unlock导致,异步线程 先后调用等产生的较多.</p>
<h3 id="有哪些类型的线程锁分别介绍下作用和使用场景">8.有哪些类型的线程锁，分别介绍下作用和使用场景</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">锁类型</th>
<th style="text-align: center;">使用场景</th>
<th style="text-align: left;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>pthread_mutex</code></td>
<td style="text-align: center;">互斥锁</td>
<td style="text-align: left;"><code>PTHREAD_MUTEX_NORMAL</code>,<code>#import &lt;pthread.h&gt;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">OSSpinLock</td>
<td style="text-align: center;">自旋锁</td>
<td style="text-align: left;">不安全，iOS 10 已启用</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>os_unfair_lock</code></td>
<td style="text-align: center;">互斥锁</td>
<td style="text-align: left;">替代 OSSpinLock</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>pthread_mutex</code>(recursive)</td>
<td style="text-align: center;">递归锁</td>
<td style="text-align: left;"><code>PTHREAD_MUTEX_RECURSIVE</code>,<code>#import &lt;pthread.h&gt;</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>pthread_cond_t</code></td>
<td style="text-align: center;">条件锁</td>
<td style="text-align: left;"><code>#import &lt;pthread.h&gt;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>pthread_rwlock</code></td>
<td style="text-align: center;">读写锁</td>
<td style="text-align: left;">读操作重入，写操作互斥</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="citation" data-cites="synchronized">@synchronized</span></td>
<td style="text-align: center;">互斥锁</td>
<td style="text-align: left;">性能差，且无法锁住内存地址更改的对象</td>
</tr>
<tr class="even">
<td style="text-align: left;">NSLock</td>
<td style="text-align: center;">互斥锁</td>
<td style="text-align: left;">封装 <code>pthread_mutex</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">NSRecursiveLock</td>
<td style="text-align: center;">递归锁</td>
<td style="text-align: left;">封装<code>pthread_mutex</code>(recursive)</td>
</tr>
<tr class="even">
<td style="text-align: left;">NSCondition</td>
<td style="text-align: center;">条件锁</td>
<td style="text-align: left;">封装 <code>pthread_cond_t</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">NSConditionLock</td>
<td style="text-align: center;">条件锁</td>
<td style="text-align: left;">可以指定具体条件值 封装 <code>pthread_cond_t</code></td>
</tr>
</tbody>
</table>
<h3 id="nsoperationqueue中的maxconcurrentoperationcount默认值">9.NSOperationQueue中的maxConcurrentOperationCount默认值</h3>
<p>默认值 -1. 这个值操作系统会根据资源使用的综合开销情况设置.</p>
<h3 id="nstimercadisplaylinkdispatch_source_t-的优劣">10.<code>NSTimer、CADisplayLink、</code>dispatch_source_t` 的优劣</h3>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 36%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">定时器类型</th>
<th style="text-align: center;">优势</th>
<th style="text-align: left;">劣势</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">NSTimer</td>
<td style="text-align: center;">使用简单</td>
<td style="text-align: left;">依赖 Runloop，具体表现在 无 Runloop 无法使用、NSRunLoopCommonModes、不精确</td>
</tr>
<tr class="even">
<td style="text-align: left;">CADisplayLink</td>
<td style="text-align: center;">依赖屏幕刷新频率出发事件,最精.最合适做UI刷新</td>
<td style="text-align: left;">若屏幕刷新被影响，事件也被影响、事件触发的时间间隔只能是屏幕刷新 duration 的倍数、若事件所需时间大于触发事件，跳过数次、不能被继承</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>dispatch_source_t</code></td>
<td style="text-align: center;">不依赖 Runloop</td>
<td style="text-align: left;">依赖线程队列,使用麻烦 使用不当容易Crash</td>
</tr>
</tbody>
</table>
<h1 id="总结">总结</h1>
<p>今天这篇多线程 也算是一个objc开发者的知识总结,这里面问到的知识大部分和队列线程关系比较多. 高阶一些的搞法并没有. 比如:如何停掉<code>dispatch_source_t</code>的定时器.再比如 为什么要存在<code>dispatch_source</code>. 下一篇我们讲解一下 视图&amp;图像相关文章.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS面试题" scheme="https://www.sunyazhou.com/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>阿里、字节：一套高效的iOS面试题之Block</title>
    <link href="https://www.sunyazhou.com/2020/09/17/20200917Block/"/>
    <id>https://www.sunyazhou.com/2020/09/17/20200917Block/</id>
    <published>2020-09-17T06:34:10.000Z</published>
    <updated>2020-09-18T11:57:25.150Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="block">block</h2>
<p>这一篇我们来研究一下objc的block并回答一下面试中的下列问题:</p>
<p>1.block的内部实现，结构体是什么样的<br>
2.block是类吗，有哪些类型<br>
3.一个int变量被 <code>__block</code> 修饰与否的区别？block的变量截获<br>
4.block在修改NSMutableArray，需不需要添加<code>__block</code><br>
5.怎么进行内存管理的<br>
6.block可以用strong修饰吗<br>
7.解决循环引用时为什么要用<code>__strong</code>、<code>__weak</code>修饰<br>
8.<code>block</code>发生<code>copy</code>时机<br>
9.<code>Block</code>访问对象类型的<code>auto</code>变量时，在<code>ARC</code>和<code>MRC</code>下有什么区别</p>
<p>在回答所有问题之前我们需要了解一些block背景相关的知识. 如下:</p>
<p>- 如何查看Block的内部实现,也就是说转换成背后真正的c/c++代码的block是什么样的？以及转换格式或者原理等.<br>
-关于变量的作用域</p>
<h4 id="objective-c-转-c的方法">Objective-C 转 C++的方法</h4>
<p>下面我写了个示例<code>TestClass.m</code>类其中block代码如下</p>
<p>OC代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestClass</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)testMethods &#123;</span><br><span class="line">    <span class="keyword">void</span> (^blockA)(<span class="keyword">int</span> a) = ^(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (blockA) &#123;</span><br><span class="line">        blockA(<span class="number">1990</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>经过上述转换操作我们在TestClass.cpp中最下面发现如下代码</p>
<p>C++代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @interface TestClass ()</span></span><br><span class="line"><span class="comment">/* @end */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @implementation TestClass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __TestClass__testMethods_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0* Desc;</span><br><span class="line">  __TestClass__testMethods_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestClass__testMethods_block_func_0(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0 *__cself, <span class="keyword">int</span> a) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_wx_b8tcry0j24dbhr7zlzjq3v340000gn_T_TestClass_ee18d3_mi_0,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __TestClass__testMethods_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestClass_testMethods(TestClass * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">void</span> (*blockA)(<span class="keyword">int</span> a) = ((<span class="keyword">void</span> (*)(<span class="keyword">int</span>))&amp;__TestClass__testMethods_block_impl_0((<span class="keyword">void</span> *)__TestClass__testMethods_block_func_0, &amp;__TestClass__testMethods_block_desc_0_DATA));</span><br><span class="line">    <span class="keyword">if</span> (blockA) &#123;</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *, <span class="keyword">int</span>))((__block_impl *)blockA)-&gt;FuncPtr)((__block_impl *)blockA, <span class="number">1990</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码生成是通过如下操作:</p>
<p>打开终端，cd到TestClass.m所在文件夹,使用如下命令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc TestClass.m</span><br></pre></td></tr></table></figure>
<p>就会在当前文件夹内自动生成对应的TestClass.cpp文件</p>
<blockquote>
<p>注意: 如果提示clang没有的话 需要安装, 输入如下</p>
</blockquote>
<p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install clang-format</span><br><span class="line">或者</span><br><span class="line">brew link clang-forma</span><br><span class="line">然后输入 下面命令测试是否好使</span><br><span class="line">clang-format --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></p>
<p>通过上述代码我们发现Block的其实是一个结构体类型</p>
<p>底层实现 会根据 <code>__</code><strong>类名</strong><code>__</code><strong>方法名</strong><code>_</code>block<code>_</code>impl<code>_</code><strong>下标</strong> (0代表这个方法或者这个类中第0个block 下面如果还有将会 第1个block 第2个...)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __类名__方法名_block_impl_下标</span><br></pre></td></tr></table></figure>
<h4 id="关于变量的作用域">关于变量的作用域</h4>
<p>c语言的函数中可能使用的参数变量种类</p>
<ul>
<li>参数类型</li>
<li>自动变量(局部变量)</li>
<li>静态变量(静态局部变量)</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>由于存储区域特殊,这其中有三种变量是可以在任何时候以任何状态调用的.</p>
<ul>
<li>静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>而其他两种,则是有各自相应的作用域,超过作用域后,会被销毁.</p>
<hr>
<h3 id="block的内部实现结构体是什么样的">1.block的内部实现，结构体是什么样的</h3>
<p>看了上面的背景知识我们来回到一下这个问题</p>
<p>block的内部实现如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __TestClass__testMethods_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl; <span class="comment">//成员变量</span></span><br><span class="line">  <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0* Desc; <span class="comment">//desc 结构体声明</span></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="comment">// fp 函数指针</span></span><br><span class="line">  <span class="comment">// desc 静态全局变量初始化的 __main_block_desc_ 结构体实例指针</span></span><br><span class="line">  <span class="comment">// flags block 的负载信息(引用计数和类型信息),按位存储.</span></span><br><span class="line">  __TestClass__testMethods_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将来被调用的block内部的代码：block值被转换为C的函数代码</span></span><br><span class="line"><span class="comment">//这里，*__cself 是指向Block的值的指针，也就相当于是Block的值它自己(相当于C++里的this，</span></span><br><span class="line">OC里的<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">//__cself 是指向__TestClass__testMethods_block_impl_0结构体实现的指针</span></span><br><span class="line"><span class="comment">//Block结构体就是__TestClass__testMethods_block_impl_0结构体.Block的值就是通过__TestClass__testMethods_block_impl_0构造出来的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestClass__testMethods_block_func_0(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0 *__cself, <span class="keyword">int</span> a) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_wx_b8tcry0j24dbhr7zlzjq3v340000gn_T_TestClass_9f58f7_mi_0,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __TestClass__testMethods_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestClass_testMethods(TestClass * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">void</span> (*blockA)(<span class="keyword">int</span> a) = ((<span class="keyword">void</span> (*)(<span class="keyword">int</span>))&amp;__TestClass__testMethods_block_impl_0((<span class="keyword">void</span> *)__TestClass__testMethods_block_func_0, &amp;__TestClass__testMethods_block_desc_0_DATA));</span><br><span class="line">    <span class="keyword">if</span> (blockA) &#123;</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *, <span class="keyword">int</span>))((__block_impl *)blockA)-&gt;FuncPtr)((__block_impl *)blockA, <span class="number">1990</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看得出来<code>__TestClass__testMethods_block_impl_0</code>有3个部分组成</p>
<ul>
<li><p>impl 函数指针指向<code>__TestClass__testMethods_block_impl_0</code></p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;  <span class="comment">//今后版本升级所需的区域</span></span><br><span class="line">  <span class="keyword">void</span> *FuncPtr; <span class="comment">//函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Desc 指向<code>__TestClass__testMethods_block_impl_0</code>的Desc指针,用于描述当前这个block的附加信息的，包括结构体的大小等等信息.</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 &#123;</span><br><span class="line">  size_t reserved; <span class="comment">//今后升级版本所需区域</span></span><br><span class="line">  size_t Block_size; <span class="comment">//block的大小</span></span><br><span class="line">&#125; __TestClass__testMethods_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>__TestClass__testMethods_block_impl_0()</code>构造函数,也就是该block的具体实现</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__TestClass__testMethods_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __TestClass__testMethods_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">   impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">   impl.Flags = flags;</span><br><span class="line">   impl.FuncPtr = fp;</span><br><span class="line">   Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此结构体中</p>
<ul>
<li>isa指针保持这所属类的结构体的实例的指针.</li>
<li><code>struct __TestClass__testMethods_block_impl_0</code>相当于Objective-C类对象的结构体</li>
<li><code>_NSConcreteStackBlock</code>相当于Block的结构体实例,也就是说<strong>block其实就是Objective-C对于闭包的对象实现</strong></li>
</ul></li>
</ul>
<p>讲到这里block的内部实现你看懂了吗?结构体是什么样的你记住了吗? 其实看着繁琐 细心观察代码会发现还是比较简单的.</p>
<h3 id="block是类吗有哪些类型">2.block是类吗，有哪些类型?</h3>
<p>block也算是个类,因为它有isa指针,block.isa的类型包括</p>
<ul>
<li>_NSConcreteGlobalBlock 跟全局变量一样,设置在程序的数据区域(.data)中</li>
<li>_NSConcreteStackBlock栈上(前面讲的都是栈上的 block)</li>
<li>_NSConcreteMallocBlock 堆上</li>
</ul>
<blockquote>
<p>这个isa可以按位运算</p>
</blockquote>
<h3 id="一个int变量被-__block-修饰与否的区别block的变量截获">3.一个int变量被 <code>__block</code> 修饰与否的区别？block的变量截获</h3>
<h4 id="被__block-修饰与否的区别">被<code>__block</code> 修饰与否的区别</h4>
<p>用一段示例代码来解答这个问题吧:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">PrintTwoIntBlock block = ^()&#123;</span><br><span class="line">    a -= <span class="number">10</span>;</span><br><span class="line">    printf(<span class="string">"%d, %d\n"</span>,a,b);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">block();<span class="comment">//0 20</span></span><br><span class="line">    </span><br><span class="line">a += <span class="number">20</span>;</span><br><span class="line">b += <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">printf(<span class="string">"%d, %d\n"</span>,a,b);<span class="comment">//20 50</span></span><br><span class="line">    </span><br><span class="line">block();/<span class="number">10</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>通过<code>__block</code>修饰<code>int</code> <code>a</code>,block体中对这个变量的引用是指针拷贝,它会作为block结构体构造参数传入到结构体中且复制这个变量的指针引用，从而达到可以修改变量的作用.</p>
<p><code>int</code> <code>b</code>没有被<code>__block</code>修饰,block内部对<code>b</code>是值copy.所以在block内部修改<code>b</code>不影响外部b的变化.</p>
<h4 id="block的变量截获">block的变量截获</h4>
<p>通过如下代码我们来观察要一下变量的捕获</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    blk = [^(<span class="keyword">id</span> object)&#123;</span><br><span class="line">        [array addObject:object];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>,[array count]);</span><br><span class="line">    &#125; <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);</span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);</span><br><span class="line">blk([<span class="built_in">NSObject</span> new]);</span><br></pre></td></tr></table></figure>
<p>输出打印</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">block_demo[28963:1629127] array count = 1</span><br><span class="line">block_demo[28963:1629127] array count = 2</span><br><span class="line">block_demo[28963:1629127] array count = 3</span><br></pre></td></tr></table></figure>
<p>我们把上面的代码翻译成C++看下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  id <span class="built_in">array</span>;<span class="comment">//截获的对象</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Objc中，C结构体里不能含有被<code>__strong</code>修饰的变量，因为编译器不知道应该何时初始化和废弃C结构体。但是Objc的运行时库能够准确把握<code>Block</code>从栈复制到堆，以及堆上的block被废弃的时机，在实现上是通过<code>__TestClass__testMethods_block_copy_0</code>函数和<code>__TestClass__testMethods_block_dispose_0</code>函数进行的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestClass__testMethods_block_copy_0(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0*dst, <span class="keyword">struct</span> __TestClass__testMethods_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;array, (<span class="keyword">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestClass__testMethods_block_dispose_0(<span class="keyword">struct</span> __TestClass__testMethods_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_Block_object_assign</code>相当于retain操作,将对象赋值在对象类型的结构体成员变量中.<br>
</li>
<li><code>_Block_object_dispose</code>相当于release操作.</li>
</ul>
<p>这两个函数调用的时机是在什么时候呢？</p>
<table>
<thead>
<tr class="header">
<th>函数</th>
<th>被调用时机</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>__TestClass__testMethods_block_copy_0</code></td>
<td>从栈复制到堆时</td>
</tr>
<tr class="even">
<td><code>__TestClass__testMethods_block_dispose_0</code></td>
<td>堆上的Block被废弃时</td>
</tr>
</tbody>
</table>
<h5 id="什么时候栈上的block会被复制到堆呢">什么时候栈上的Block会被复制到堆呢？</h5>
<ul>
<li>调用block的copy函数时。<br>
</li>
<li>Block作为函数返回值返回时。<br>
</li>
<li>将Block赋值给附有<code>__strong</code>修饰符id类型的类或者Block类型成员变量时。<br>
</li>
<li>方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。</li>
</ul>
<h5 id="什么时候block被废弃呢">什么时候Block被废弃呢？</h5>
<ul>
<li>堆上的Block被释放后,谁都不再持有Block时调用dispose函数。</li>
</ul>
<p>以上就是变量被block捕获的内容</p>
<hr>
<h3 id="block在修改nsmutablearray需不需要添加__block">4.<code>block</code>在修改<code>NSMutableArray</code>，需不需要添加<code>__block</code></h3>
<ul>
<li>如修改<code>NSMutableArray</code>的存储内容的话,是不需要添加<code>__block</code>修饰的。</li>
<li>如修改<code>NSMutableArray</code>对象的本身,那必须添加<code>__block</code>修饰。</li>
</ul>
<h3 id="怎么进行内存管理的">5.怎么进行内存管理的?</h3>
<p>在上面Block的构造函数<code>__TestClass__testMethods_block_impl_0</code>中的isa指针指向的是&amp;_NSConcreteStackBlock，它表示当前的Block位于栈区中.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">block内存操作</th>
<th style="text-align: center;">存储域/存储位置</th>
<th style="text-align: center;">copy操作的影响</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">_NSConcreteGlobalBlock</td>
<td style="text-align: center;">程序的数据区域</td>
<td style="text-align: center;">什么也不做</td>
</tr>
<tr class="even">
<td style="text-align: center;">_NSConcreteStackBlock</td>
<td style="text-align: center;">栈</td>
<td style="text-align: center;">从栈拷贝到堆</td>
</tr>
<tr class="odd">
<td style="text-align: center;">_NSConcreteMallocBlock</td>
<td style="text-align: center;">堆</td>
<td style="text-align: center;">引用计数增加</td>
</tr>
</tbody>
</table>
<ul>
<li>全局Block:<code>_NSConcreteGlobalBlock</code>的结构体实例设置在程序的数据存储区，所以可以在程序的任意位置通过指针来访问，它的产生条件:
<ul>
<li>记述全局变量的地方有block语法时.</li>
<li>block不截获的自动变量.</li>
</ul>
<blockquote>
<p>以上两个条件只要满足一个就可以产生全局Block. <a href="https://juejin.im/post/6844903474312773646#heading-13" target="_blank" rel="noopener">参考</a></p>
</blockquote></li>
<li>栈Block:<code>_NSConcreteStackBlock</code>在生成Block以后，如果这个Block不是全局Block,那它就是栈Block,生命周期在其所属的变量作用域内.(也就是说如果销毁取决于所属的变量作用域).如果Block变量和<code>__block</code>变量复制到了堆上以后，则不再会受到变量作用域结束的影响了，因为它变成了堆Block.<br>
</li>
<li>堆Block:<code>_NSConcreteMallocBlock</code>将栈block复制到堆以后，block结构体的isa成员变量变成了<code>_NSConcreteMallocBlock</code>。</li>
</ul>
<h3 id="block可以用strong修饰吗">6.block可以用strong修饰吗?</h3>
<p>在ARC中可以，因为在ARC环境中的block只能在堆内存或全局内存中，因此不涉及到从栈拷贝到堆中的操作.</p>
<p>在MRC中不行,因为要有拷贝过程.如果执行copy用strong的话会crash, <code>strong</code>是ARC中引入的关键字.如果使用retain相当于忽视了block的copy过程.</p>
<h3 id="解决循环引用时为什么要用__strong__weak修饰">7.解决循环引用时为什么要用<code>__strong</code>、<code>__weak</code>修饰?</h3>
<p>首先因为block捕获变量的时候 结构体构造时传入了self,造成了默认的引用关系,所以一般在block外部对操作对象会加上<code>__weak</code>,在Block内部使用<code>__strong</code>修饰符的对象类型的自动变量，那么当Block从栈复制到堆的时候，该对象就会被Block所持有,但是持有的是我们上面加了<code>__weak</code>所以行程了比消此长的链条,刚好能解决block延迟销毁的时候对外部对象生命周期造成的影响.如果不这样做很容易造成循环引用.</p>
<h3 id="block发生copy时机">8.block发生copy时机?</h3>
<p>在ARC中,编译器将创建在栈中的block会自动拷贝到堆内存中,而block作为方法或函数的参数传递时,编译器不会做copy操作.</p>
<ul>
<li>调用block的copy函数时。<br>
</li>
<li>Block作为函数返回值返回时。<br>
</li>
<li>将Block赋值给附有<code>__strong</code>修饰符id类型的类或者Block类型成员变量时。<br>
</li>
<li>方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。</li>
</ul>
<h3 id="block访问对象类型的auto变量时在arc和mrc下有什么区别">9.Block访问对象类型的auto变量时，在ARC和MRC下有什么区别?</h3>
<p>ARC下会对这个对象强引用，MRC下不会</p>
<p><a href="https://juejin.im/post/6844903474312773646" target="_blank" rel="noopener">详细请参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS面试题" scheme="https://www.sunyazhou.com/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>阿里、字节：一套高效的iOS面试题之Runloop&amp;KVO</title>
    <link href="https://www.sunyazhou.com/2020/09/02/20200902iOSinterviewAnswers/"/>
    <id>https://www.sunyazhou.com/2020/09/02/20200902iOSinterviewAnswers/</id>
    <published>2020-09-02T03:23:24.000Z</published>
    <updated>2020-09-15T00:45:13.796Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<p><a href="https://www.sunyazhou.com/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/">前几篇</a>我们一路讲了内存,关联对象、ARC、AutoreleasePool、weak对象, NSNotifacionCenter等, 今天这一篇我们来讲一下 Runloop和KVO</p>
<p>本章的主要回答的问题如下:</p>
<h4 id="runloop">Runloop</h4>
<ul>
<li>app如何接收到触摸事件的</li>
<li>为什么只有主线程的runloop是开启的</li>
<li>为什么只在主线程刷新UI</li>
<li>PerformSelector和runloop的关系</li>
<li>如何使线程保活</li>
</ul>
<h4 id="kvo">KVO</h4>
<ul>
<li>实现原理</li>
<li>如何手动关闭kvo</li>
<li>通过KVC修改属性会触发KVO么</li>
<li>哪些情况下使用kvo会崩溃，怎么防护崩溃</li>
<li>kvo的优缺点</li>
</ul>
<h2 id="runloop-1">Runloop</h2>
<p>作为一个合格的iOS开发者必须对runloop有一个更深入的了解,下面我们来回答一下 相关问题</p>
<h3 id="app如何接收到触摸事件的">1.app如何接收到触摸事件的</h3>
<p>回答这个问题前请认真阅读一下 <a href="https://mp.weixin.qq.com/s/9rvSRt4kfpy7e87EJoaJOQ" target="_blank" rel="noopener">iOS触摸事件全家桶</a></p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200902iOSinterviewAnswers/runloop_event_receive.jpg"></p>
<p>通过上图可以看出整个流程就是 我们app启动默认会通过machPort监听端口的方式 来接受IOHIDEvent 来接收和处理触摸事件.</p>
<h3 id="为什么只有主线程的runloop是开启的">2.为什么只有主线程的runloop是开启的</h3>
<p>mian()函数中调用UIApplicationMain，这里会创建一个主线程，用于UI处理，为了让程序可以一直运行并接收事件，所以在主线程中开启一个runloop，让主线程常驻.</p>
<h3 id="为什么只在主线程刷新ui">3.为什么只在主线程刷新UI</h3>
<p>我们所有用到的UI都是来自于UIKit这个基础库.因为objc不是一门线程安全的语言所以存在多线程读写不同步的问题,如果使用加锁的方式操作系统开销很大,会耗费大量的系统资源(内存、时间片轮转、cpu处理速度...)，加上上面讲到的系统事件的接收处理都在主线程,如果UI异步线程的话 还会存在 同步处理事件的问题,所以多点触摸手势等一些事件要保持和UI在同一个线程相对是最优解.</p>
<p>另一方面是 屏幕的渲染是 60帧(60Hz/秒), 也就是1秒钟回调60次的频率,(iPad Pro 是120Hz/秒),我们的runloop 理想状态下也会按照时钟周期 回调60次(iPad Pro 120次), 这么高频率的调用是为了 屏幕图像显示能够垂直同步 不卡顿.在异步线程的话是很难保证这个处理过程的同步更新. 即便能保证的话 相对主线程而言 系统资源开销 线程调度等等将会占据大部分资源和在同一个线程只专门干一件事有点得不偿失.</p>
<h3 id="performselector和runloop的关系">4.PerformSelector和runloop的关系</h3>
<p>当调用NSObect的 performSelector:相关的时候,内部会创建一个timer定时器添加到当前线程的runloop中,如果当前线程没有启动runloop,则该方法不会被调用.</p>
<p>开发中遇到最多的问题就是这个performSelector: 导致对象的延迟释放,这里开发过程中注意一下,可以用单次的NSTimer替代.</p>
<p>详细可以参考<a href="https://juejin.im/post/6844903781755256840" target="_blank" rel="noopener">Runloop与performSelector</a></p>
<h3 id="如何使线程保活">5.如何使线程保活？</h3>
<p>想要线程保活的话就开启该线程的runloop即可,注意:在NSThread执行的方法中添加while(true){}，这样是模拟runloop的运行原理，结合GCD的信号量，在{}代码块中处理任务.</p>
<p>但是注意 开启runloop的方法要正确</p>
<p>如下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试开启线程</span></span><br><span class="line">- (<span class="keyword">void</span>)memoryTest &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line">        [thread start];</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stopThread) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程停止</span></span><br><span class="line">- (<span class="keyword">void</span>)stopThread &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    [thread cancel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行线程的runloop 注意 意添加的那个空port,否则会出现内存泄露</span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.emptyPort) &#123;</span><br><span class="line">            <span class="keyword">self</span>.emptyPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line">        &#125;</span><br><span class="line">        [runLoop addPort:<span class="keyword">self</span>.emptyPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop runMode:<span class="built_in">NSRunLoopCommonModes</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下列代码用于模拟线程内部做的一些耗时任务</span></span><br><span class="line">- (<span class="keyword">void</span>)printSomething &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(printSomething) withObject:<span class="literal">nil</span> afterDelay:<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟手动点击按钮 让 runloop停掉</span></span><br><span class="line">- (<span class="keyword">void</span>)stopButtonDidClicked:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stopRunloop) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopRunloop &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细请参考:<a href="https://allluckly.cn/%E6%8A%95%E7%A8%BF/tuogao55" target="_blank" rel="noopener">iOS开发深入研究Runloop与线程保活</a></p>
<h2 id="kvo-1">KVO</h2>
<p>在开发过程中我们经常使用KVO,下面解答一下KVO相关的问题.</p>
<h3 id="kvo的实现原理">KVO的实现原理</h3>
<p>通过<code>runtime</code>派生子类的方式 复写相关需要KVO监听的属性,在该属性setter之前和之后调用NSObject的监听方法,这样KVO就实现了属性变换前后的回调.</p>
<p>KVO派生的子类具体格式应该是:<code>NSKVONotifying_+类名</code>的类 eg: NSKVONotifying_Person</p>
<p>下面示例代码为Person类的name添加KVO的模拟实验</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    _NSSetObjectValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _NSSetObjectValueAndNotify &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">    [<span class="keyword">super</span> setName:name];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    [observe observeValueForKeyPath:key ofObject:<span class="keyword">self</span> change:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题来了如何动态创建类呢?</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态创建XXCustomClass</span></span><br><span class="line">Class customClass = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">"XXCustomClass"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 添加实例变量</span></span><br><span class="line">class_addIvar(customClass, <span class="string">"age"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>, <span class="string">"i"</span>);</span><br><span class="line"><span class="comment">// 动态添加方法</span></span><br><span class="line">class_addMethod(customClass, <span class="keyword">@selector</span>(hahahha), (IMP)hahahha, <span class="string">"V@:"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要实现的方法</span></span><br><span class="line"><span class="keyword">void</span> hahahha(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hahahha===="</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hahahha&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后注册到运行时环境</span></span><br><span class="line">objc_registerClassPair(customClass);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">V@:表示方法的参数和返回值</a></p>
</blockquote>
<p>具体原理以及自定义实现KVO可以参考<a href="https://cloud.tencent.com/developer/article/1136759" target="_blank" rel="noopener">KVO详解及底层实现</a></p>
<h3 id="如何手动关闭kvo">如何手动关闭KVO?</h3>
<p>被观察的对象复写如下方法 返回<code>NO</code>即可关闭KVO <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果关闭后还想触发 KVO的话 修改需要手动调用在变量setter的前后 主动调用 <code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p>
<h3 id="通过kvc修改属性会触发kvo么">通过KVC修改属性会触发KVO么?</h3>
<p>会的</p>
<h3 id="哪些情况下使用kvo会崩溃怎么防护崩溃">哪些情况下使用kvo会崩溃，怎么防护崩溃？</h3>
<p>使用不当 会crash,比如:</p>
<p>- 添加和移出不是成对出现且存在多线程添加KVO的情况,经常遇到的crash是移出 - 内存dealloc的时候 或者对象销毁前没有正确移出Observer</p>
<p>如何防护？</p>
<p>1.注意移出对象 匹配<br>
2.内存野指针问题,一定要在对象销毁前移出观察者 3.可以使用第三方库BlockKit添加KVO,blockkit内部会自动移除Observer避免crash.</p>
<h3 id="kvo的优缺点">KVO的优缺点</h3>
<p>优点:</p>
<p>- 方便两个对象间同步状态(keypath)更加方便,一般都是在A类要观察B类的属性的变化.<br>
- 非侵入式的得到某内部对象的状态改变并作出响应.(就是在不改变原来对象类的代码情况下即可做出对该对象的状态变化进行监听)<br>
- 可以嵌入更改前后的两个时机的状态. - 可以通过Keypaths对嵌套对象的监听.</p>
<p>缺点:</p>
<p>- 需要手动移除观察者,不移除容易造成crash.<br>
- 注册和移出成对匹配出现.<br>
- keypath参数的类型String, 如果对象的成员变量被重构而变化字符串不会被编译器识别而报错.<br>
- 实现观察的方式是复写NSObjec的相关KVO的方法,应该更加面向protocol的方式会更好.</p>
<h2 id="总结">总结</h2>
<p>这一篇我们讲了 runloop和KVO相关的内容,这里面最负责的当属runloop如何处理触摸手势事件.建议认真研读相关链接文章.这样才有一个对runloop更深刻的理解, 下一篇我们讲一下Block,敬请期待.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS面试题" scheme="https://www.sunyazhou.com/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>阿里、字节：一套高效的iOS面试题之NSNotification相关</title>
    <link href="https://www.sunyazhou.com/2020/09/01/20200901iOSinterviewAnswers/"/>
    <id>https://www.sunyazhou.com/2020/09/01/20200901iOSinterviewAnswers/</id>
    <published>2020-09-01T02:15:27.000Z</published>
    <updated>2020-09-15T00:45:17.723Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<p>前3篇中已经讲完了内存管理,今天我们继续完成<a href="https://juejin.im/post/6844904064937902094" target="_blank" rel="noopener">阿里、字节：一套高效的iOS面试题</a>的通知部分. 主要内容包含如下:</p>
<ul>
<li>实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等）</li>
<li>通知的发送时同步的，还是异步的</li>
<li>NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息</li>
<li>NSNotificationQueue是异步还是同步发送？在哪个线程响应</li>
<li>NSNotificationQueue和runloop的关系</li>
<li>如何保证通知接收的线程在主线程</li>
<li>页面销毁时不移除通知会崩溃吗</li>
<li>多次添加同一个通知会是什么结果？多次移除通知呢</li>
<li>下面的方式能接收到通知吗？为什么<br>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送通知</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:<span class="string">@"TestNotification"</span> object:@<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 接收通知</span></span><br><span class="line">[<span class="built_in">NSNotificationCenter</span>.defaultCenter postNotificationName:<span class="string">@"TestNotification"</span> object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在解释这些内容之前 强烈建议认真研读一下这篇 <a href="https://juejin.im/post/6844904082516213768" target="_blank" rel="noopener">一文全解iOS通知机制(经典收藏)</a>文章 了解一下大概 所有的问题就迎刃而解了.</p>
<h2 id="实现原理结构设计通知如何存储的nameobserversel之间的关系等">实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等</h2>
<p>首先通知中心结构大概分为如下几个类</p>
<ul>
<li><code>NSNotification</code> 通知的模型 name、object、userinfo.</li>
<li><code>NSNotificationCenter</code>通知中心 负责发送<code>NSNotification</code></li>
<li><code>NSNotificationQueue</code>通知队列 负责在某些时机触发 调用<code>NSNotificationCenter</code>通知中心 <code>post</code>通知</li>
</ul>
<p>通知是结构体通过双向链表进行数据存储</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根容器，NSNotificationCenter持有</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> NCTbl &#123;</span><br><span class="line">  Observation		*wildcard;	<span class="comment">/* 链表结构，保存既没有name也没有object的通知 */</span></span><br><span class="line">  GSIMapTable		nameless;	<span class="comment">/* 存储没有name但是有object的通知	*/</span></span><br><span class="line">  GSIMapTable		named;		<span class="comment">/* 存储带有name的通知，不管有没有object	*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observation 存储观察者和响应结构体，基本的存储单元</span></span><br><span class="line"><span class="keyword">typedef</span>	<span class="keyword">struct</span>	Obs &#123;</span><br><span class="line">  <span class="keyword">id</span>		observer;	<span class="comment">/* 观察者，接收通知的对象	*/</span></span><br><span class="line">  SEL		selector;	<span class="comment">/* 响应方法		*/</span></span><br><span class="line">  <span class="keyword">struct</span> Obs	*next;		<span class="comment">/* Next item in linked list.	*/</span></span><br><span class="line">  ...</span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure>
<p>主要是以<code>key</code> <code>value</code>的形式存储,这里需要重点强调一下 通知以 <code>name</code>和<code>object</code>两个纬度来存储相关通知内容,也就是我们添加通知的时候传入的两个不同的方法.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200901iOSinterviewAnswers/NCTable.jpg"><br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200901iOSinterviewAnswers/NCTable2.jpg"></p>
<p>简单理解<code>name</code>&amp;<code>observer</code>&amp;<code>SEL</code>之间的关系就是<code>name</code>作为<code>key</code>, <code>observer</code>作为观察者对象,当合适时机触发就会调用<code>observer</code>的<code>SEL</code>.这基本很简单,如果觉得我说的不准确可以看下文章开头的文章.</p>
<h2 id="通知的发送时同步的还是异步的">通知的发送时同步的，还是异步的</h2>
<p>同步发送.因为要调用消息转发.所谓异步，指的是<strong>非实时发送</strong>而是<strong>在合适的时机发送</strong>，并没有开启异步线程.</p>
<h2 id="nsnotificationcenter接受消息和发送消息是在一个线程里吗如何异步发送消息">NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息</h2>
<p>是的, 异步线程发送通知则响应函数也是在异步线程.</p>
<p>异步发送通知可以开启异步线程发送即可.</p>
<h2 id="nsnotificationqueue是异步还是同步发送在哪个线程响应">NSNotificationQueue是异步还是同步发送？在哪个线程响应</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示通知的发送时机</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSPostingStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">NSPostWhenIdle</span> = <span class="number">1</span>, <span class="comment">// runloop空闲时发送通知</span></span><br><span class="line">    <span class="built_in">NSPostASAP</span> = <span class="number">2</span>, <span class="comment">// 尽快发送，这种时机是穿插在每次事件完成期间来做的</span></span><br><span class="line">    <span class="built_in">NSPostNow</span> = <span class="number">3</span> <span class="comment">// 立刻发送或者合并通知完成之后发送</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th></th>
<th>NSPostWhenIdle</th>
<th>NSPostASAP</th>
<th>NSPostNow</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NSPostingStyle</td>
<td>异步发送</td>
<td>异步发送</td>
<td>同步发送</td>
</tr>
</tbody>
</table>
<p><code>NSNotificationCenter</code>都是同步发送的，而这里介绍关于<code>NSNotificationQueue</code>的异步发送，从线程的角度看并不是真正的异步发送，或可称为<strong>延时发送</strong>，它是利用了<code>runloop</code>的时机来触发的.</p>
<p>异步线程发送通知则响应函数也是在异步线程,主线程发送则在主线程.</p>
<h2 id="nsnotificationqueue和runloop的关系">NSNotificationQueue和runloop的关系</h2>
<p><code>NSNotificationQueue</code>依赖<code>runloop</code>. 因为通知队列要在runloop回调的某个时机调用通知中心发送通知.从下面的枚举值就能看出来</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示通知的发送时机</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSPostingStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">NSPostWhenIdle</span> = <span class="number">1</span>, <span class="comment">// runloop空闲时发送通知</span></span><br><span class="line">    <span class="built_in">NSPostASAP</span> = <span class="number">2</span>, <span class="comment">// 尽快发送，这种时机是穿插在每次事件完成期间来做的</span></span><br><span class="line">    <span class="built_in">NSPostNow</span> = <span class="number">3</span> <span class="comment">// 立刻发送或者合并通知完成之后发送</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="如何保证通知接收的线程在主线程">如何保证通知接收的线程在主线程</h2>
<p>如果想在主线程响应异步通知的话可以用如下两种方式</p>
<p>1.系统接受通知的API指定队列</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">NSObject</span>&gt;)addObserverForName:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)obj queue:(<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)queue usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSNotification</span> *note))block</span><br></pre></td></tr></table></figure>
<p>2.<code>NSMachPort</code>的方式 通过在主线程的runloop中添加machPort，设置这个port的delegate，通过这个Port其他线程可以跟主线程通信，在这个port的代理回调中执行的代码肯定在主线程中运行，所以，在这里调用NSNotificationCenter发送通知即可</p>
<h2 id="页面销毁时不移除通知会崩溃吗">页面销毁时不移除通知会崩溃吗?</h2>
<p>iOS9.0之前，会crash，原因：通知中心对观察者的引用是unsafe_unretained，导致当观察者释放的时候，观察者的指针值并不为nil，出现野指针.</p>
<p>iOS9.0之后，不会crash，原因：通知中心对观察者的引用是weak。</p>
<h2 id="多次添加同一个通知会是什么结果多次移除通知呢">多次添加同一个通知会是什么结果？多次移除通知呢</h2>
<p>多次添加同一个通知，会导致发送一次这个通知的时候，响应多次通知回调。 多次移除通知不会产生crash。</p>
<h2 id="下面的方式能接收到通知吗为什么">下面的方式能接收到通知吗？为什么</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送通知</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleNotification:) name:<span class="string">@"TestNotification"</span> object:@<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 接收通知</span></span><br><span class="line">[<span class="built_in">NSNotificationCenter</span>.defaultCenter postNotificationName:<span class="string">@"TestNotification"</span> object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>不能</p>
<p>首先我们看下通知中心存储通知观察者的结构</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根容器，NSNotificationCenter持有</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> NCTbl &#123;</span><br><span class="line">  Observation  *wildcard;    <span class="comment">/* 链表结构，保存既没有name也没有object的通知 */</span></span><br><span class="line">  GSIMapTable nameless;    <span class="comment">/* 存储没有name但是有object的通知    */</span></span><br><span class="line">  GSIMapTable named;        <span class="comment">/* 存储带有name的通知，不管有没有object    */</span></span><br><span class="line">    ...</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observation 存储观察者和响应结构体，基本的存储单元</span></span><br><span class="line"><span class="keyword">typedef</span>	<span class="keyword">struct</span> Obs &#123;</span><br><span class="line">  <span class="keyword">id</span> observer;    <span class="comment">/* 观察者，接收通知的对象    */</span></span><br><span class="line">  SEL selector;    <span class="comment">/* 响应方法        */</span></span><br><span class="line">  <span class="keyword">struct</span> Obs *next;        <span class="comment">/* Next item in linked list.    */</span></span><br><span class="line">  ...</span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure>
<p><code>nameless</code>与<code>named</code>的具体数据结构如下:</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200901iOSinterviewAnswers/NCTable.jpg"><br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200901iOSinterviewAnswers/NCTable2.jpg"></p>
<p>当添加通知监听的时候，我们传入了<code>name</code>和<code>object</code>，所以，观察者的存储链表是这样的：</p>
<p><code>named</code>表：<code>key(name)</code> : <code>value</code>-&gt;<code>key(object)</code> : <code>value(Observation)</code></p>
<p>因此在发送通知的时候，如果只传入<code>name</code>而并没有传入<code>object</code>，是找不到<code>Observation</code>的，也就不能执行观察者回调.</p>
<h1 id="总结">总结</h1>
<p>经过今天的 复习又重新认识了iOS中的通知中心,希望大家经常温故而知新. 下一篇我们开始讲解 <code>Runloop</code>&amp; <code>KVO</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS面试题" scheme="https://www.sunyazhou.com/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>阿里、字节：一套高效的iOS面试题之runtime相关问题3</title>
    <link href="https://www.sunyazhou.com/2020/08/31/20200831iOSinterviewAnswers/"/>
    <id>https://www.sunyazhou.com/2020/08/31/20200831iOSinterviewAnswers/</id>
    <published>2020-08-31T08:52:25.000Z</published>
    <updated>2020-09-18T11:57:34.824Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h1 id="runtime相关问题之内存部分的关联属性或者hook相关的method-swizzle">runtime相关问题之内存部分的关联属性或者hook相关的Method Swizzle</h1>
<p>经过前两期内容 我们这期来讲一下 内存部分的剩余问题 主要包含如下:</p>
<ol type="1">
<li><code>Method Swizzle</code>注意事项</li>
<li>属性修饰符atomic的内部实现是怎么样的?能保证线程安全吗</li>
<li>iOS 中内省的几个方法有哪些？内部实现原理是什么</li>
<li><code>class</code>、<code>objc_getClass</code>、<code>object_getclass</code> 方法有什么区别?</li>
</ol>
<h2 id="method-swizzle注意事项"><code>Method Swizzle</code>注意事项</h2>
<ol type="1">
<li><p><strong>需要注意的是交换方法实现后的副作用</strong>, <code>method_exchangeImplementations()</code>.交换方法函数最终会以<code>objc_msgSend()</code>方式调用,副作用主要集中在第一个参数 如下示例</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">objc_msgSend(payment, <span class="keyword">@selector</span>(quantity))</span><br></pre></td></tr></table></figure></p>
<p>方法交换后再去调用quantity方法将有可能会crash.解决这种副作用的方式是使用<code>method_setImplementation()</code>来替换原来的交换方式,这样才最为合理, 具体原理请参照 <a href="https://www.ctolib.com/topics-103098.html" target="_blank" rel="noopener">Objc 黑科技 - Method Swizzle 的一些注意事项</a></p></li>
<li><p><strong>避免交换父类方法</strong></p>
<p>如果当前类没有实现被交换的方法且父类实现了,此时父类的实现会被交换,若此父类的多个继承者都在交换时会引起多次交换导致混乱,同时调用父类方法有可能因为找不到方法签名而crash.<br>
所以交换前都应该check能否为当前类添加被交换的函数的新的实现IMP,这个过程大概分为3步骤</p>
<ul>
<li><p><code>class_addMethod</code> check能否添加方法 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>给类cls的SEL添加一个实现IMP, 返回YES则表明类cls并未实现此方法，返回NO则表明类已实现了此方法。注意：添加成功与否，完全由该类本身来决定，与父类有无该方法无关。</p>
</blockquote></li>
<li><p><code>class_replaceMethod</code> 替换类cls的SEL的函数实现为imp <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, </span><br><span class="line">                 <span class="keyword">const</span> <span class="keyword">char</span> * _Nullable types)</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>method_exchangeImplementations</code> 最终方法交换 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>交换方法应在+load方法</p>
<p>这个前面讲消息转发的时候讲过,+load不是消息转发的方式实现的且在运行时初始化过程中类被加载的时候调用,而且父类,当前类,category,子类等 都会调用一次.所以这里最适合写方法交换的hook(Method Swizzle).</p></li>
<li><p>交换的分类方法应该添加自定义前缀,避免冲突</p>
<p>这个毫无疑问,方法名称一样的时候会出现,分类的方法会覆盖类中同名的方法.</p></li>
</ol>
<p><a href="https://blog.csdn.net/weixin_34168700/article/details/88762738" target="_blank" rel="noopener">method swizzling你应该注意的点</a></p>
<h2 id="属性修饰符atomic的内部实现是怎么样的能保证线程安全吗">属性修饰符atomic的内部实现是怎么样的?能保证线程安全吗?</h2>
<h3 id="atomic内部实现">atomic内部实现</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ptrdiff_t offset, <span class="built_in">BOOL</span> atomic) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;  </span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    <span class="keyword">id</span> value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>property</code> 的 <code>atomic</code> 是采用 <code>spinlock_t</code>自旋锁实现的.</p>
<h3 id="能保证线程安全吗">能保证线程安全吗?</h3>
<p><code>atomic</code>通过这种方法.在运行时仅仅是保证了<code>set</code>,<code>get</code>方法的原子性.所以使用atomic并不能保证线程安全。</p>
<h2 id="ios-中内省的几个方法有哪些内部实现原理是什么">iOS 中内省的几个方法有哪些？内部实现原理是什么?</h2>
<p>首先要明白一个名词 <code>introspection</code> 反省,内省的意思,在iOS开发中我们会称它为反射.</p>
<p>内省方法 例如常用的<code>NSObject</code>中的<code>isKindOfClass:</code> 通过实例对象判断<code>class</code>这就是一种内省方法或者叫反射方法,但我认为<code>NSClassFromString()</code>这个应该也算一种反射方法.</p>
<h3 id="ios-中内省的几个方法">iOS 中内省的几个方法</h3>
<p>我们从NSObject.h中看下吧</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)aClass; <span class="comment">//判断是否是这个类或者这个类的子类的实例</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)aClass; <span class="comment">//判断是否是这个类的实例</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)aProtocol;  <span class="comment">//判断是否遵守某个协议</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)protocol; <span class="comment">//判断某个类是否遵守某个协议</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector;  <span class="comment">//判读实例是否有这样方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)instancesRespondToSelector:(SEL)aSelector; <span class="comment">//判断类是否有这个方法</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="内部实现原理">内部实现原理</h3>
<p>1.<code>isKindOfClass:</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类方法是通过ISA()函数拿到指向元类的存储isa指针数据的地址bit位按位与上相关掩码的方式判断当前是否是某个类的子类.<br>
实例方法是通过<code>objc_object::getIsa()</code>函数通过存储的<code>tag_ext</code>表形式拿到isa对于的class来取出class平check来实现的.</p>
<p>2.<code>isMemberOfClass:</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;ISA() == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这俩方法非常简单直接 拿到isa指针对比</p>
<p>3.<code>conformsToProtocol:</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</span><br><span class="line">    <span class="keyword">if</span> (!protocol) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="keyword">self</span>; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (class_conformsToProtocol(tcls, protocol)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</span><br><span class="line">    <span class="keyword">if</span> (!protocol) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (class_conformsToProtocol(tcls, protocol)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法最终还是去isa-&gt;data()-&gt;protocols 拿到相关协议然后判断是否存在相关协议 如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> class_conformsToProtocol(Class cls, Protocol *proto_gen)</span><br><span class="line">&#123;</span><br><span class="line">    protocol_t *proto = newprotocol(proto_gen);  </span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (!proto_gen) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    mutex_locker_t lock(runtimeLock);</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    ASSERT(cls-&gt;isRealized())</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> auto&amp; proto_ref : cls-&gt;data()-&gt;protocols) &#123;</span><br><span class="line">        protocol_t *p = remapProtocol(proto_ref);</span><br><span class="line">        <span class="keyword">if</span> (p == proto || protocol_conformsToProtocol_nolock(p, proto)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以清晰的看到for循环 取出相关protocol指针 然后通过指针和传入的参数生成的<code>proto</code>对比</p>
</blockquote>
<p>4.<code>respondsToSelector:</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> class_respondsToSelector_inst(<span class="keyword">self</span>, sel, <span class="keyword">self</span>-&gt;ISA());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> class_respondsToSelector_inst(<span class="keyword">self</span>, sel, [<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个源码比较麻烦 我简单叙述一下吧 实际上调用栈比较深就是一直寻找到当前实例能响应哪些方法,当前类没有就去父类,父类没有则直到元类.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">respondsToSelector:</span><br><span class="line">	|__ class_respondsToSelector_inst()</span><br><span class="line">		|__ lookUpImpOrNil()</span><br><span class="line">			|__ lookUpImpOrForward()</span><br><span class="line">				返回IMP结果</span><br></pre></td></tr></table></figure>
<p>这就是整个消息转发的过程 就不在这里赘述了.感兴趣回看一下<a href="https://www.sunyazhou.com/2020/08/08/20200808iOSinterviewAnswers/">第二章</a> 消息转发部分</p>
<p>我上述列举了一些常用的内省方法,其它的都方法基本没什么特别之处都是拿到isa各种操作内部的获取相关属性的函数返回结.</p>
<h2 id="classobjc_getclassobject_getclass-方法有什么区别"><code>class</code>、<code>objc_getClass</code>、<code>object_getclass</code> 方法有什么区别?</h2>
<p>我用xcode随便建了一个demo 打印一下viewcontrooller的内容</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Class cls1 = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    Class cls2 = object_getClass(cls1);</span><br><span class="line">    Class cls3 = objc_getClass(object_getClassName([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,cls1);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,cls2);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,cls3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">2020-08-31 16:15:48.150285+0800 ClassDemo[5582:55836] 0x10205b3b0</span><br><span class="line">2020-08-31 16:15:48.150456+0800 ClassDemo[5582:55836] 0x10205b3d8</span><br><span class="line">2020-08-31 16:15:48.150575+0800 ClassDemo[5582:55836] 0x10205b3b0</span><br></pre></td></tr></table></figure>
<p>我简单列举了一张表格</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><code>class</code></th>
<th style="text-align: center;"><code>object_getclass()</code></th>
<th style="text-align: center;"><code>objc_getClass()</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">传入参数</td>
<td style="text-align: center;">N/a</td>
<td style="text-align: center;">id类型</td>
<td style="text-align: center;">类名的字符串</td>
</tr>
<tr class="even">
<td style="text-align: center;">操作对象</td>
<td style="text-align: center;">obj</td>
<td style="text-align: center;">这个id的isa指针所指向的Class</td>
<td style="text-align: center;">这个类的类对象</td>
</tr>
<tr class="odd">
<td style="text-align: center;">实例对象时</td>
<td style="text-align: center;">和<code>object_getclass()</code>一致</td>
<td style="text-align: center;">和<code>class</code>一致</td>
<td style="text-align: center;">N/a</td>
</tr>
<tr class="even">
<td style="text-align: center;">类对象/元类对象时</td>
<td style="text-align: center;">返回的消息对象本身</td>
<td style="text-align: center;">返回的是下一个对象</td>
<td style="text-align: center;">N/a</td>
</tr>
</tbody>
</table>
<blockquote>
<p>原因：因为class返回的是self，而object_getClass返回的是isa指向的对象</p>
</blockquote>
<h1 id="总结">总结</h1>
<p>以上就是"一套高效的iOS面试题之我整理的答案之runtime相关问题3"中的内存剩余部分,问题答案虽然简短 但是每道题都问的非常到位,下一期我们讲一下 通知部分 争取用最快时间内把所有问题都整理出来答案.</p>
<p><a href="https://www.codenong.com/cs106358283/" target="_blank" rel="noopener">参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS面试题" scheme="https://www.sunyazhou.com/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>阿里、字节：一套高效的iOS面试题之runtime相关问题2</title>
    <link href="https://www.sunyazhou.com/2020/08/08/20200808iOSinterviewAnswers/"/>
    <id>https://www.sunyazhou.com/2020/08/08/20200808iOSinterviewAnswers/</id>
    <published>2020-08-08T06:54:07.000Z</published>
    <updated>2020-09-18T11:57:41.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<blockquote>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
</blockquote>
<p>本篇我们来讲一下 <a href="https://mp.weixin.qq.com/s/bDnsaD__ZpdHIk3_So382w" target="_blank" rel="noopener">阿里、字节：一套高效的iOS面试题</a> 中的runtime相关问题部分的内存管理相关的内容.</p>
<h1 id="runtime相关问题之-内存管理">runtime相关问题之 内存管理</h1>
<p>基本内容包括:</p>
<ul>
<li>weak的实现原理？SideTable的结构是什么样的</li>
<li>关联对象的应用？系统如何实现关联对象的</li>
<li>关联对象的如何进行内存管理的？关联对象如何实现weak属性</li>
<li>Autoreleasepool的原理？所使用的的数据结构是什么</li>
<li>ARC的实现原理？ARC下对retain, release做了哪些优化</li>
<li>ARC下哪些情况会造成内存泄漏</li>
</ul>
<h2 id="weak的实现原理sidetable的结构是什么样的">weak的实现原理？SideTable的结构是什么样的</h2>
<p>先说结论:</p>
<ul>
<li><code>weak表</code>其实是一个hash(哈西)表.<code>Key</code>是所指对象的地址，<code>Value</code>是<code>weak</code>指针的地址数组.实现原理是通过新旧表的更新指针方式,对weak对象单独存储于<code>SideTable</code>中的<code>weak_table_t</code>(类型) <code>weak_table</code>表中,通过函数<code>objc_initWeak()</code>-&gt;<code>storeWeak()</code>函数中的新旧<code>SideTable</code>(结构体)表来实现</li>
<li><code>SideTable</code>是一个结构体，内部主要有引用计数表和弱引用表两个成员，内存存储的其实都是对象的地址和引用计数和weak变量的地址，而不是对象本身的数据,它的结构如下</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        memset(&amp;weak_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line">    ~SideTable() &#123;</span><br><span class="line">        _objc_fatal(<span class="string">"Do not delete SideTable."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> lock() &#123; slock.lock(); &#125;</span><br><span class="line">    <span class="keyword">void</span> unlock() &#123; slock.unlock(); &#125;</span><br><span class="line">    <span class="keyword">void</span> forceReset() &#123; slock.forceReset(); &#125;</span><br><span class="line">    <span class="comment">// Address-ordered lock discipline for a pair of side tables.</span></span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> lockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> unlockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="weak实现原理">weak实现原理</h3>
<p>实现原理概括分为3个时机</p>
<ul>
<li>1.初始化</li>
<li>2.添加引用</li>
<li>3.释放</li>
</ul>
<h4 id="初始化时候">1.初始化时候</h4>
<p><code>runtime</code>会调用<code>objc_initWeak</code>函数，初始化一个新的<code>weak</code>指针指向对象的地址.</p>
<p>我们引入一段测试代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</span><br></pre></td></tr></table></figure>
<p>当我们初始化一个weak变量时，<code>runtime</code>会调用<code>NSObject.mm</code>中的<code>objc_initWeak()</code>函数。这个函数在Clang中的声明如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123; <span class="comment">// 查看对象实例是否有效 无效对象直接导致指针释放</span></span><br><span class="line">        *location = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里传递了三个 bool 数值 old, new, crash.使用 template 进行常量参数传递是为了优化性能</span></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这个函数仅仅是一个深层函数的调用入口，而一般的入口函数中，都会做一些简单的判断（例如 <code>objc_msgSend</code> 中的缓存判断），这里判断了其指针指向的类对象是否有效，无效直接释放，不再往深层调用函数。否则，object将被注册为一个指向value的<code>__weak</code>对象。而这事应该是<code>objc_storeWeak</code>函数干的.</p>
<blockquote>
<p>注意： <code>objc_initWeak</code>函数有一个前提条件：就是object必须是一个没有被注册为<code>__weak</code>对象的有效指针。而value则可以是null，或者指向一个有效的对象.</p>
</blockquote>
<h4 id="添加引用时">2.添加引用时</h4>
<p><code>objc_initWeak</code>函数会调用 <code>objc_storeWeak()</code>函数,<code>objc_storeWeak()</code>则会调用<code>storeWeak()</code>函数， <code>storeWeak()</code>的作用是更新指针指向，创建对应的弱引用表</p>
<p>模板</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HaveOld:  true - 变量有值 ,false - 需要被及时清理，当前值可能为 nil</span></span><br><span class="line"><span class="comment">// HaveNew:  true - 需要被分配的新值，当前值可能为nil, false - 不需要分配新值</span></span><br><span class="line"><span class="comment">// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停,false - 用 nil 替代存储</span></span><br><span class="line"><span class="keyword">template</span> &lt;HaveOld haveOld, HaveNew haveNew,CrashIfDeallocating crashIfDeallocating&gt;</span><br></pre></td></tr></table></figure>
<p>weak实现函数 <strong>该过程用来更新弱引用指针的指向</strong>.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> </span><br><span class="line">storeWeak(<span class="keyword">id</span> *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) ASSERT(newObj == <span class="literal">nil</span>);  </span><br><span class="line">    <span class="comment">// 初始化 previouslyInitializedClass 指针.</span></span><br><span class="line">    Class previouslyInitializedClass = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">id</span> oldObj;</span><br><span class="line">    <span class="comment">// 声明两个 SideTable,① 新旧散列创建</span></span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line">    <span class="comment">//获得新值和旧值的锁存位置(用地址作为唯一标示),通过地址来建立索引标志,防止桶重复,下面指向的操作会改变旧值.</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;<span class="comment">// 更改指针，获得以 oldObj 为索引所存储的值地址</span></span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];<span class="comment">// 更改新值指针，获得以 newObj 为索引所存储的值地址</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁操作，防止多线程中竞争冲突</span></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">	<span class="comment">// 避免线程冲突重处理,location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止弱引用间死锁,并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();<span class="comment">// 获得新对象的 isa 指针</span></span><br><span class="line">        <span class="comment">// 判断 isa 非空且已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123; </span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);/ 解锁</span><br><span class="line">            class_initialize(cls, (<span class="keyword">id</span>)newObj); <span class="comment">//如果该类已经完成执行 +initialize 方法是最理想情况,如果该类 +initialize 在线程中,例如 +initialize 正在调用 storeWeak 方法,需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line">            <span class="keyword">goto</span> retry; <span class="comment">//重试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ② 清除旧值</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="comment">// ③ 分配新值</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (<span class="keyword">id</span>)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">//如果弱引用被释放 weak_register_no_lock 方法返回 nil,在引用计数表中设置若引用标记位</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">	        <span class="comment">//弱引用位初始化操作,引用计数那张散列表的weak引用对象的引用计数中标识为weak引用</span></span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//之前不要设置 location 对象，这里需要更改指针指向</span></span><br><span class="line">        *location = (<span class="keyword">id</span>)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有新值，则无需更改</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sidetable">SideTable</h5>
<p>SideTable就是一个结构体，内部主要有引用计数表和弱引用表两个成员，内存存储的其实都是对象的地址和引用计数和weak变量的地址，而不是对象本身的数据. &gt; 主要用于管理对象的引用计数和 weak 表.</p>
<p>我们来看图</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200808iOSinterviewAnswers/SideTableStructure.png"></p>
<blockquote>
<p>操作系统维护64个SideTable，通过对象的地址位置hash之后模64(就是%64求余数)找到指定的SideTable 每个SideTable维护了一个RefcountMap的引用计数表，key就是对象地址，value就是此对象的引用计数</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> SideTable &#123;</span><br><span class="line">    spinlock_t slock; <span class="comment">//保证原子操作的自旋锁</span></span><br><span class="line">    RefcountMap refcnts; <span class="comment">//引用计数的 hash 表</span></span><br><span class="line">    weak_table_t weak_table; <span class="comment">//weak 引用全局 hash 表</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>slock 防止竞争的自旋锁</li>
<li>refcnts 协助对象的 isa 指针的<code>extra_rc</code>共同引用计数的变量</li>
</ul>
<h5 id="weak表">weak表</h5>
<p>弱引用hash表,<code>weak_table_t</code>类型的结构体,存储某个实例对象相关的所有弱引用信息. 定义如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries; <span class="comment">// 保存了所有指向指定对象的 weak 指针</span></span><br><span class="line">    size_t    num_entries;		 <span class="comment">// 存储空间</span></span><br><span class="line">    uintptr_t mask;     			<span class="comment">// 参与判断引用计数辅助量</span></span><br><span class="line">    uintptr_t max_hash_displacement;     <span class="comment">// hash key 最大偏移值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个全局弱引用hash表。使用不定类型对象的地址作为<code>key</code>，用<code>weak_entry_t</code>类型结构体对象作为<code>value</code>,其中的<code>weak_entries</code> 成员,即为弱引用表入口.</p>
<p>其中<code>weak_entry_t</code>是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> DisguisedPtr&lt;objc_object *&gt; weak_referrer_t;</span><br><span class="line"><span class="keyword">struct</span> weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>DisguisedPtr</code>类型的<code>referent</code>变量是<strong>对泛型对象的指针的封装</strong>,通过这个<code>泛型类</code>来解决内存泄露的问题.</p>
<p>注释中有个很重要的<code>out_of_line</code>成员,它代表最低的有效位,当它为0的时候,<code>weak_referrer_t</code>成员将扩展为多行静态的<code>hask table</code>.</p>
<p>其中<code>weak_referrer_t</code> 是一个二维<code>objc_object</code>的别名(typedef),通过一个二维指针地址偏移,用下标作hash的<code>key</code>,做成了一个弱引用的散列。</p>
<p>那么<code>weak_entry_t</code>中的各成员<code>out_of_line</code>、<code>num_refs</code>、<code>mask</code> 、<code>max_hash_displacement</code> 在有效位未生效的时候有什么作用？</p>
<ul>
<li><code>out_of_line</code>:最低有效位，也是标志位。当标志位 0 时，增加引用表指针纬度。</li>
<li><code>num_refs</code>: 引用数值。这里记录弱引用表中引用有效数字，因为弱引用表使用的是静态 hash 结构，所以需要使用变量来记录数目。</li>
<li><code>mask</code>:计数辅助量。</li>
<li><code>max_hash_displacement</code>:<code>hash</code>元素上限阀值。</li>
</ul>
<blockquote>
<p>其实 <code>out_of_line</code> 的值通常情况下是等于零的，所以弱引用表总是一个<code>objc_objective</code>指针二维数组。一维 <code>objc_objective</code>指针可构成一张弱引用散列表，通过第三纬度实现了多张散列表，并且表数量为 <code>WEAK_INLINE_COUNT</code>.</p>
</blockquote>
<p>以上是weak表的实现原理.</p>
<h4 id="释放">3.释放</h4>
<p>释放时，调用<code>clearDeallocating</code>函数。<code>clearDeallocating</code>函数首先根据对象地址获取所有<code>weak</code>指针地址的数组，然后遍历这个数组把其中的数据设为<code>nil</code>，最后把这个<code>entry</code>从<code>weak</code>表中删除，最后清理对象的记录.</p>
<h5 id="当weak引用指向的对象被释放时又是如何去处理weak指针的呢当释放对象时其基本流程如下">当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下:</h5>
<ul>
<li>1.调用<code>objc_release</code></li>
<li>2.因为对象的引用计数为0，所以执行<code>dealloc</code></li>
<li>3.在dealloc中，调用了<code>_objc_rootDealloc</code>函数</li>
<li>4.在<code>_objc_rootDealloc</code>中，调用了<code>object_dispose</code>函数</li>
<li>5.调用<code>objc_destructInstance</code></li>
<li>6.最后调用<code>objc_clear_deallocating</code></li>
</ul>
<p>重点看对象被释放时调用的<code>objc_clear_deallocating</code>函数。该函数实现如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_clear_deallocating(<span class="keyword">id</span> obj)  </span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    obj-&gt;clearDeallocating();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>clearDeallocating()</code>,点击源码进去追踪发现,它最终是使用了迭代器来取<code>weak</code>表的<code>value</code>,然后调用<code>weak_clear_no_lock()</code>查找对应<code>value</code>,将该<code>weak</code>指针置空.</p>
<p><code>weak_clear_no_lock()</code>函数的实现如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> weak_clear_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_clear_deallocating()</code>该函数的动作如下：</p>
<ul>
<li>1.从weak表中获取废弃对象的地址为键值的记录</li>
<li>2.将包含在记录中的所有附有 weak修饰符变量的地址，赋值为nil</li>
<li>3.将weak表中该记录删除</li>
<li>4.从引用计数表中删除废弃对象的地址为键值的记录</li>
</ul>
<p><a href="https://www.jianshu.com/p/13c4fb1cedea" target="_blank" rel="noopener">参考</a></p>
<h2 id="关联对象的应用系统如何实现关联对象的">关联对象的应用？系统如何实现关联对象的</h2>
<h3 id="关联对象的应用">关联对象的应用？</h3>
<p>一般应用在<code>category</code>(分类)中为 当前类 添加关联属性,因为不能直接添加成员变量，但是可以通过runtime的方式间接实现添加成员变量的效果。</p>
<p>当我们在<code>category</code>中声明如下代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span> (<span class="title">Category</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *property;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>实际上<code>@property</code>这个objc标准库的内建关键字帮我们实现了 setter和 getter,但是在category中并不能帮我们声明成员变量 <code>property</code> 我们需要通过runtime提供的两个C函数的api间接实现 动态添加 成员变量<code>property</code>.</p>
<ul>
<li><code>objc_setAssociatedObject()</code></li>
<li><code>objc_getAssociatedObject()</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ClassA+Category.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *) property &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setProperty:(<span class="built_in">NSString</span> *)categoryProperty &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(property), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>看到上面的关联方法,我们来仔细研究一下下面经常使用的关联属性相关的API</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span>;</span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span>;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>objc_setAssociatedObject()</code>以键值对形式添加关联对象</li>
<li><code>objc_getAssociatedObject()</code>根据 key 获取关联对象</li>
<li><code>objc_removeAssociatedObjects()</code>移除所有关联对象</li>
</ol>
<p><code>objc_setAssociatedObject()</code>的调用栈</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</span><br><span class="line">└── SetAssocHook.get()(object, key, value, policy)</span><br><span class="line">    └── <span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy)</span><br></pre></td></tr></table></figure>
<p>上述调用栈中的<code>_object_set_associative_reference()</code>函数实际完成了设置关联对象的任务：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_object_set_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span>, object, object_getClassName(object));</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">    ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line">    association.acquireValue();</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.get());</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="keyword">auto</span> refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;);</span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) &#123;</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> &amp;refs = refs_result.first-&gt;second;</span><br><span class="line">            <span class="keyword">auto</span> result = refs.try_emplace(key, <span class="built_in">std</span>::move(association));</span><br><span class="line">            <span class="keyword">if</span> (!result.second) &#123;</span><br><span class="line">                association.swap(result.first-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    association.releaseHeldValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略的很多代码,上述代码中就是应用场景,上面调用的类<code>AssociationsManager</code>就是我们下面要讲的系统如何实现关联对象的原理.</p>
<h3 id="系统如何实现关联对象的关联对象实现原理">系统如何实现关联对象的(关联对象实现原理)</h3>
<p>实现关联对象技术的核心对象 有如下这么几个:</p>
<ol type="1">
<li>AssociationsManager</li>
<li>AssociationsHashMap<br>
</li>
<li>ObjectAssociationMap</li>
<li>ObjcAssociation</li>
</ol>
<blockquote>
<p>其中Map同我们平时使用的字典类似。通过<code>key</code>-<code>value</code>的形式对应存值.</p>
</blockquote>
<p>下面我们通过源码来一探究竟</p>
<h4 id="objc_setassociatedobject函数"><code>objc_setAssociatedObject()</code>函数</h4>
<p>runtime源码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br><span class="line">&#123;</span><br><span class="line">    _object_set_associative_reference(object, key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码调用过程有hook函数,有点长,这里我简化一下,直接调用核心的函数</p>
</blockquote>
<p>下面看下<code>_object_set_associative_reference()</code>函数的代码实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span>, object, object_getClassName(object));</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">    ObjcAssociation association&#123;policy, value&#125;; <span class="comment">//4. 我们用到的ObjcAssociation</span></span><br><span class="line">    association.acquireValue();</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager; <span class="comment">//1. 我们用到的AssociationsManager</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.get()); <span class="comment">//2.我们上面列举的AssociationsHashMap</span></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            auto refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;); <span class="comment">//3.我们用到的ObjectAssociationMap</span></span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) &#123;</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">            auto &amp;refs = refs_result.first-&gt;second;</span><br><span class="line">            auto result = refs.try_emplace(key, std::move(association));</span><br><span class="line">            <span class="keyword">if</span> (!result.second) &#123;</span><br><span class="line">                association.swap(result.first-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            auto refs_it = associations.find(disguised);</span><br><span class="line">            <span class="keyword">if</span> (refs_it != associations.end()) &#123;</span><br><span class="line">                auto &amp;refs = refs_it-&gt;second;</span><br><span class="line">                auto it = refs.find(key);</span><br><span class="line">                <span class="keyword">if</span> (it != refs.end()) &#123;</span><br><span class="line">                    association.swap(it-&gt;second);</span><br><span class="line">                    refs.erase(it);</span><br><span class="line">                    <span class="keyword">if</span> (refs.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        associations.erase(refs_it);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    association.releaseHeldValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码可以找到我们实现关联对象技术的核心对象. 下面我们分别介绍一下几个核心对象的内部实现.</p>
<h5 id="associationsmanager">AssociationsManager</h5>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, ObjcAssociation&gt; ObjectAssociationMap;</span><br><span class="line"><span class="keyword">typedef</span> DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt; AssociationsHashMap;</span><br><span class="line"><span class="keyword">class</span> AssociationsManager &#123;</span><br><span class="line">    using Storage = ExplicitInitDenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt;;</span><br><span class="line">    <span class="keyword">static</span> Storage _mapStorage;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</span><br><span class="line"></span><br><span class="line">    AssociationsHashMap &amp;get() &#123;</span><br><span class="line">        <span class="keyword">return</span> _mapStorage.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> init() &#123;</span><br><span class="line">        _mapStorage.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>AssociationsManager</code>内部有一个<code>get()</code>函数返回一个<code>AssociationsHashMap</code>对象</p>
<h5 id="associationshashmap">AssociationsHashMap</h5>
<p><code>AssociationsHashMap</code> 是<code>DenseMap</code>的typedef(可以理解为别名) 只不过它被定义成符合某些<code>元组</code>的条件的<code>DenseMap</code>类型</p>
<p>实际上 <code>AssociationsHashMap</code> 用与保存从对象的 <code>disguised_ptr_t</code>到 <code>ObjectAssociationMap</code>的映射,这个数据结构保存了当前对象对应的所有关联对象</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, ObjcAssociation&gt; ObjectAssociationMap;</span><br><span class="line"><span class="keyword">typedef</span> DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt; AssociationsHashMap;</span><br></pre></td></tr></table></figure>
<p>这里的<code>ObjectAssociationMap</code>是另一类型的typedef,里面存着<code>ObjcAssociation</code>类型的对象指针的key,value形式.</p>
<p>下面再看下 <code>ObjcAssociation</code> ,这是一个C++的类对象,最关键的<code>ObjcAssociation</code>包含了<code>policy</code>以及<code>value</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjcAssociation</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> _policy;</span><br><span class="line">    id _value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ObjcAssociation(<span class="keyword">uintptr_t</span> policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(<span class="number">0</span>), _value(nil) &#123;&#125;</span><br><span class="line">    ObjcAssociation(<span class="keyword">const</span> ObjcAssociation &amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    ObjcAssociation &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ObjcAssociation &amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    ObjcAssociation(ObjcAssociation &amp;&amp;other) : ObjcAssociation() &#123;</span><br><span class="line">        swap(other);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ObjcAssociation &amp;other)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(_policy, other._policy);</span><br><span class="line">        <span class="built_in">std</span>::swap(_value, other._value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> uintptr_t <span class="title">policy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _policy; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> id <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="关联对象在内存中以什么形式存储的">关联对象在内存中以什么形式存储的？</h5>
<p>示例代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">        objc_setAssociatedObject(obj, <span class="keyword">@selector</span>(hello), <span class="string">@"Hello"</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个调用函数<code>objc_setAssociatedObject(OBJC_ASSOCIATION_RETAIN_NONATOMIC, @"Hello")</code>在内存中是这样的存储结构</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200808iOSinterviewAnswers/AssociationOrder.png"></p>
<h5 id="objc_setassociatedobject"><code>objc_setAssociatedObject()</code></h5>
<p>我们回头来详细分解一下<code>objc_setAssociatedObject()</code>函数中的真实实现部分,<code>_object_set_associative_reference()</code></p>
<p>这个函数需要传入<code>(id object, const void *key, id value, uintptr_t policy)</code>,这么几个参数,我们拿第3个<code>value</code>参数来分解.</p>
<p>我们分解为2步</p>
<ol type="1">
<li><code>value != nil</code> 设置或者更新关联对象的值</li>
<li><code>value == nil</code> 删除一个关联对象.</li>
</ol>
<p>下面是具体是代码解释 <strong>注意看代码注释!!!</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断本类对象是否允许关联其他对象.如果允许则进入代码块</span></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span>, object, object_getClassName(object));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将被关联的对象封装成DisguisedPtr方便在后边hash表中的管理,它的作用就像是一个指针</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">    <span class="comment">// 将需要关联的对象,封装成ObjcAssociation,方便管理</span></span><br><span class="line">    ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理policy为retain和copy的修饰情况,</span></span><br><span class="line">    association.acquireValue();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// 获取关联对象管理者对象</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="comment">// 根据管理者对象获取对应关联表(HashMap)</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        	<span class="comment">// 如果这个disguised存在于ObjectAssociationMap()中,则替换,如果不存在则初始化后在插入</span></span><br><span class="line">        	<span class="comment">// 这里说明一下,我们关联的对象关系存在于ObjectAssociationMap中,而</span></span><br><span class="line">        	<span class="comment">//	ObjectAssociationMap有多个,所以,这一步是对ObjectAssociationMap的一个管理,下边才是对我们要关联的对象的操作</span></span><br><span class="line">            auto refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;);</span><br><span class="line">            <span class="comment">// 如果这是此对象第一次被关联</span></span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) &#123;</span><br><span class="line">               <span class="comment">// 修改isa_t中的has_assoc字段,标记其被关联状态</span></span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里才是对我们要关联的对象操作</span></span><br><span class="line">            auto &amp;refs = refs_result.first-&gt;second;</span><br><span class="line">            <span class="comment">// 想map中插入key value对</span></span><br><span class="line">            auto result = refs.try_emplace(key, std::move(association));</span><br><span class="line">            <span class="comment">// 这里没有看懂,为什么没有第二个就要交换一下..</span></span><br><span class="line">            <span class="keyword">if</span> (!result.second) &#123;</span><br><span class="line">                association.swap(result.first-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// value为空, 并且在associations中有记录,则进行擦除操作 </span></span><br><span class="line">            auto refs_it = associations.find(disguised);</span><br><span class="line">            <span class="keyword">if</span> (refs_it != associations.end()) &#123;</span><br><span class="line">                auto &amp;refs = refs_it-&gt;second;</span><br><span class="line">                auto it = refs.find(key);</span><br><span class="line">                <span class="keyword">if</span> (it != refs.end()) &#123;</span><br><span class="line">                    association.swap(it-&gt;second);</span><br><span class="line">                    refs.erase(it);</span><br><span class="line">                    <span class="keyword">if</span> (refs.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        associations.erase(refs_it);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    association.releaseHeldValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="objc_setassociatedobject函数的作用是什么"><code>objc_setAssociatedObject()</code>函数的作用是什么?</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::setHasAssociatedObjects()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">isa_t</span> oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">isa_t</span> newisa = oldisa;</span><br><span class="line">    <span class="keyword">if</span> (!newisa.nonpointer  ||  newisa.has_assoc) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newisa.has_assoc = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会将<code>isa</code>结构体中的标记位<code>has_assoc</code>标记为<code>true</code>，也就是表示当前对象有关联对象，如下图<code>isa</code>中的各个标记位都是干什么的.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200808iOSinterviewAnswers/isa.jpg"></p>
<h5 id="objc_getassociatedobject"><code>objc_getAssociatedObject()</code></h5>
<p>这个函数的调用栈如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br><span class="line">└── id _object_get_associative_reference(id object, const void *key);</span><br></pre></td></tr></table></figure>
<p>通过上面我们介绍，理解这个函数相当简单了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span></span><br><span class="line">_object_get_associative_reference(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    ObjcAssociation association&#123;&#125;;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager; <span class="comment">//1</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.get()); <span class="comment">//1</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find((objc_object *)object); <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs.find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs.end()) &#123;</span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                association.retainReturnedValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> association.autoreleaseReturnedValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>通过<code>AssociationsManager</code>拿到<code>AssociationsHashMap</code>哈西表</li>
<li>通过哈西表寻找关联对象</li>
<li>剩下的就是更新对象是否初次创建等标记 然后返回对象</li>
</ol>
<h5 id="objc_removeassociatedobjects"><code>objc_removeAssociatedObjects()</code></h5>
<p>调用栈如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br><span class="line">└── void _object_remove_assocations(id object)</span><br></pre></td></tr></table></figure>
<p>代码具体实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123; </span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>check对象是否为nil 且 关联对象是否存在</p>
</blockquote>
<p>然后调用实现跟上边的get差不多</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_object_remove_assocations(<span class="keyword">id</span> object)</span><br><span class="line">&#123;</span><br><span class="line">    ObjectAssociationMap refs&#123;&#125;;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.get());</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find((objc_object *)object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            refs.swap(i-&gt;second);</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release everything (outside of the lock).</span></span><br><span class="line">    <span class="keyword">for</span> (auto &amp;i: refs) &#123;</span><br><span class="line">        i.second.releaseHeldValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>AssociationsManager</code> -&gt; <code>AssociationsHashMap</code> -&gt; object 是否存在,如果存在就<strong>擦除</strong>.- &gt; releaseHeldValue()是否对象</p>
<h4 id="小结">小结</h4>
<p>关联对象的应用和系统如何实现关联对象的大概顺序如下:<br>
<code>AssociationsManager</code>关联对象管理器-&gt;<code>AssociationsHashMap</code>哈希映射表-&gt;<code>ObjectAssociationMap</code>关联对象指针-&gt;<code>ObjcAssociation</code>关联对象</p>
<h2 id="关联对象的如何进行内存管理的关联对象如何实现weak属性">关联对象的如何进行内存管理的？关联对象如何实现weak属性?</h2>
<h3 id="关联对象的如何进行内存管理的">关联对象的如何进行内存管理的？</h3>
<p>当我调用关联对象函数<code>objc_setAssociatedObject()</code>的时候会调用如下函数：</p>
<p><code>_object_set_associative_reference(id object, const void *key, id value, uintptr_t policy)</code>,这里面有个方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line"><span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">association.acquireValue();</span><br></pre></td></tr></table></figure>
<p>这里的 <code>policy</code>就是具体绝对内存使用retain还是其它相关的内存枚举.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    OBJC_ASSOCIATION_SETTER_ASSIGN      = <span class="number">0</span>,</span><br><span class="line">    OBJC_ASSOCIATION_SETTER_RETAIN      = <span class="number">1</span>,</span><br><span class="line">    OBJC_ASSOCIATION_SETTER_COPY        = <span class="number">3</span>,            <span class="comment">// <span class="doctag">NOTE:</span>  both bits are set, so we can simply test 1 bit in releaseValue below.</span></span><br><span class="line">    OBJC_ASSOCIATION_GETTER_READ        = (<span class="number">0</span> &lt;&lt; <span class="number">8</span>),</span><br><span class="line">    OBJC_ASSOCIATION_GETTER_RETAIN      = (<span class="number">1</span> &lt;&lt; <span class="number">8</span>),</span><br><span class="line">    OBJC_ASSOCIATION_GETTER_AUTORELEASE = (<span class="number">2</span> &lt;&lt; <span class="number">8</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过 acquireValue()函数判断使用那种内存关键字.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> acquireValue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_value) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (_policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">            _value = objc_retain(_value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">            _value = ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(_value, <span class="keyword">@selector</span>(<span class="keyword">copy</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联对象如何实现weak属性">关联对象如何实现weak属性？</h3>
<p>首先说一下 这个问题问的非常有技术含量,完全考验iOS开发者对底层了解的程度.</p>
<p>在为NSObject对象绑定 associated object 时可以指定如下依赖关系：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>, <span class="comment">//弱引用</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">//强引用，非原子操作</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,  <span class="comment">//先 copy，然后强引用</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>, <span class="comment">//强引用，原子操作</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span> <span class="comment">//先 copy，然后强引用，原子操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据上述的枚举我们发现一个很奇怪的问题,这里的枚举中并没有<code>OBJC_ASSOCIATION_WEAK</code>这样的选项.</p>
<p>基于上述的代码介绍我们知道<code>Objective-C</code>在底层使用<code>AssociationsManager</code>统一管理各个对象的 <code>associated objects</code>关联对象.然后通过<code>static key</code>(一般是一个固定值)去访问对应的<code>associated object</code>关联对象.然后在<code>dealloc</code>的时候调用<code>擦除函数</code>(<code>associations.erase()</code>)来解除对这些关联对象的引用:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dealloc</span><br><span class="line">    object_dispose</span><br><span class="line">        objc_destructInstance</span><br><span class="line">            _object_remove_assocations  // 移除必要的associated objects</span><br></pre></td></tr></table></figure>
<p>也就是说,在<code>NSObject</code>对象的内存空间里，并没有为 <code>associated objects</code>(关联对象) 分配任何变量.</p>
<p>我们知道weak变量和 assign变量的区别是:weak指向的对象销毁的时候,<code>Objective-C</code>会自动帮我们设置<code>nil</code>,而<code>assign</code>却不能.</p>
<p>这个逻辑是如何实现的呢？</p>
<p><code>Runtime</code>在底层维护一个<code>weak</code>表(也就是本文开头讲的<code>SlideTable</code>中的<code>weak_table_t</code> <code>weak_tabl</code>)，每每分配一个<code>weak</code>指针并赋值有效对象的地址时，会将对象地址和<code>weak</code>指针地址注册到<code>weak</code>表中，其中对象地址作为<code>key</code>;当对象被废弃时,可根据对象地址快速寻找到指向它的所有<code>weak</code> 指针,这些<code>weak</code>指针会被赋值<code>0</code>(即<code>nil</code>）并移出`weak表。</p>
<p>所以,实现<code>weak</code>引用(而非<code>assign</code>引用)的前提是存在一个<code>__weak</code>指针指向到被引用对象的地址,只有这样,当对象被销毁时，指针才能被<code>runtime</code>找到然后被设置为<code>nil</code>；<code>NSObject</code>对象和其<code>associated object</code>关联对象的关系，并不存在指针这样的<strong>中间媒介</strong>，因此只存在<code>OBJC_ASSOCIATION_ASSIGN</code>选项，而不存在<code>OBJC_ASSOCIATION_WEAK</code>选项.</p>
<h4 id="那我们怎么解决为关联对象实现weak属性呢">那我们怎么解决为关联对象实现weak属性呢？</h4>
<p>可以通过曲线救国的方式声明一个<code>class</code>类 持有一个weak的成员变量,然后通过 实例化 我们自定义的class的实例,然后把这个实例作为关联对象即可.</p>
<p>声明封装weak对象的类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakAssociatedObjectWrapper</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> object;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakAssociatedObjectWrapper</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">ViewController</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIViewController</span> *vc;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">ViewController</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setVc:(<span class="built_in">UIViewController</span> *)vc &#123;</span><br><span class="line">    WeakAssociatedObjectWrapper *wrapper = [WeakAssociatedObjectWrapper new];</span><br><span class="line">    wrapper.object = vc;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(vc), wrapper, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">UIViewController</span> *)vc &#123;</span><br><span class="line">    WeakAssociatedObjectWrapper *wrapper = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">    <span class="keyword">return</span> wrapper.object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>看明白没有,曲线救国.代码引入自<a href="https://zhangbuhuai.com/post/weak-associated-object.html" target="_blank" rel="noopener">Weak Associated Object</a></p>
</blockquote>
<p><a href="https://draveness.me/ao/" target="_blank" rel="noopener">关联对象参考</a></p>
<h2 id="autoreleasepool的原理所使用的的数据结构是什么">Autoreleasepool的原理？所使用的的数据结构是什么？</h2>
<p>在ARC下我们使用<code>@autoreleasepool{}</code> 关键字 把需要自动管理的代码块圈起来 ,这个过程就是在使用一个<code>AutoReleasePool</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">	 &lt;<span class="meta">#statements#&gt; //代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码编译器 最终会把它改写成下面的样子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *context = objc_autoreleasePoolPush();</span><br></pre></td></tr></table></figure>
<p>既然有压栈一定就有 出栈操作<code>objc_autoreleasePoolPop(context)</code>;</p>
<ul>
<li><code>objc_autoreleasePoolPush()</code></li>
<li><code>objc_autoreleasePoolPop()</code></li>
</ul>
<p>这俩函数都是对<code>AutoreleasePoolPage</code>的封装,自动释放机制的核心就是这个类</p>
<h3 id="autoreleasepoolpage"><code>AutoreleasePoolPage</code></h3>
<p><code>AutoreleasePoolPage</code>是个C++的类</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200808iOSinterviewAnswers/autoreleasepoolpage.png"></p>
<ul>
<li><strong>AutoreleasePool</strong>并没有单独的结构,而是由若干个<code>AutoreleasePoolPage</code>以<code>双向链表</code>的形式组合成的,根据上图可以看出,这个双向链表有<code>前驱parent</code>和<code>后继child</code>.</li>
<li><strong>AutoreleasePool</strong>是按<code>线程</code>一一对应的(thread 成员变量)</li>
<li><strong>AutoreleasePoolPage</strong>就是自动释放池存储对象的数据结构每个Page占用<code>4KB</code>内存，本身的成员变量占用<code>56</code>字节，剩下的空间用来存放调用了<code>autorelease</code>方法的对象地址,同时将一个哨兵插入到Page中，这个哨兵其实就是一个空地址</li>
<li>当一个page被占满以后会新建一个新的<code>AutoreleasePoolPage</code>对象,并插入哨兵标记.  具体代码如下:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> AutoreleasePoolPage &#123;</span><br><span class="line"><span class="meta">#   define EMPTY_POOL_PLACEHOLDER ((id*)1)</span></span><br><span class="line"><span class="meta">#   define POOL_BOUNDARY nil</span></span><br><span class="line">    <span class="keyword">static</span> pthread_key_t <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> uint8_t <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> SIZE = </span><br><span class="line"><span class="meta">#if PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(<span class="keyword">id</span>);</span><br><span class="line">    magic_t <span class="keyword">const</span> magic;</span><br><span class="line">    <span class="keyword">id</span> *next;</span><br><span class="line">    pthread_t <span class="keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t <span class="keyword">const</span> depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>magic</code> 检查校验完整性的变量</li>
<li><code>next</code> 指向新加入的autorelease对象</li>
<li><code>thread</code> page当前所在的线程，AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>
<li><code>parent</code> 父节点 指向前一个page</li>
<li><code>child</code> 子节点 指向下一个page</li>
<li><code>depth</code> 链表的深度，节点个数</li>
<li><code>hiwat</code> high water mark 数据容纳的一个上限</li>
<li><code>EMPTY_POOL_PLACEHOLDER</code> 空池占位</li>
<li><code>POOL_BOUNDARY</code> 是一个边界对象 nil,之前的源代码变量名是 <code>POOL_SENTINEL</code>哨兵对象,用来区别每个page即每个 AutoreleasePoolPage 边界</li>
<li><code>PAGE_MAX_SIZE</code> = 4096, 为什么是4096呢？其实就是虚拟内存每个扇区4096个字节,4K对齐的说法。</li>
<li><code>COUNT</code> 一个page里对象数</li>
</ul>
<p>下面看下工作机制图</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200808iOSinterviewAnswers/autoreleasepoolworkflow.gif"></p>
<blockquote>
<p>这张图来自快手同事 周学运,如果大佬看到这张图的话希望能允许授权给我使用哈.</p>
</blockquote>
<p>根据上面的示意图我们大概明白, <code>AutoreleasePoolPage</code>是以栈的形式存在,并且内部对象通过进栈出栈来对应着<code>objc_autoreleasePoolPush</code>和<code>objc_autoreleasePoolPop</code></p>
<p>如果嵌套AutoreleasePool 就是通过<code>哨兵对象</code>来标识,每次更新链表的next和<code>前驱``后继</code>来完成表的创建销毁.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200808iOSinterviewAnswers/autoreleasepoolpage1.png"></p>
<p>当我们对一个对象发送一条<code>autorelease</code>消息的时候实际上就是将这个对象加入到当前<code>AutoreleasePoolPage</code>的栈顶<code>next</code>指针指向的位置</p>
<blockquote>
<p>这里只拿了一张page举例.</p>
</blockquote>
<h4 id="小结-1">小结</h4>
<ul>
<li>自动释放池是有N张<code>AutoreleasePoolPage</code>组成,每张page 4K大小, AutoreleasePoolPage是c++的类, AutoreleasePoolPage以双向链表连接起来形成一个自动释放池</li>
<li>当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中</li>
<li>pop 时是传入边界对象(哨兵对象),然后对page 中的对象发送release 的消息</li>
</ul>
<p><a href="https://www.jianshu.com/p/0afda1f23782" target="_blank" rel="noopener">自动释放池原理</a> <a href="https://juejin.im/post/6844903609428115470" target="_blank" rel="noopener">AutoreleasePool底层实现原理</a></p>
<h2 id="arc的实现原理arc下对retain-release做了哪些优化">ARC的实现原理？ARC下对retain, release做了哪些优化</h2>
<p>ARC自动引用计数,是苹果objc4引入的编译器自动在适当位置 帮助实例对象进行 自动retain后者release的一套机制.</p>
<p>它的实现原理就是在编译层面插入相关代码,帮助补全MRC时代需要开发者手动填写的和管理的对象的相关内存操作的方法.</p>
<p>为了解释清楚具体实现原理 ,我找到一篇有代码示例的文章,从代码编译成汇编过程中 编译器做了很多优化工作. 更新<code>isa指针</code>的信息.</p>
<p><a href="https://juejin.im/post/6844903847622606861#heading-4" target="_blank" rel="noopener">理解 ARC 实现原理</a></p>
<p>这里有个点需要跟大家说一下, 上文 中我们讲了SlideTable,但是还是有不懂得地方下面我们来通过isa串联起来</p>
<p>isa的组成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">         <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;<span class="comment">//-&gt;表示使用优化的isa指针</span></span><br><span class="line">         <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;<span class="comment">//-&gt;是否包含关联对象</span></span><br><span class="line">         <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;<span class="comment">//-&gt;是否设置了析构函数，如果没有，释放对象更快</span></span><br><span class="line">         <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000 -&gt;类的指针</span></span><br><span class="line">         <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;<span class="comment">//-&gt;固定值,用于判断是否完成初始化</span></span><br><span class="line">         <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;<span class="comment">//-&gt;对象是否被弱引用</span></span><br><span class="line">         <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;<span class="comment">//-&gt;对象是否正在销毁</span></span><br><span class="line">         <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;<span class="comment">//1-&gt;在extra_rc存储引用计数将要溢出的时候,借助Sidetable(散列表)存储引用计数,has_sidetable_rc设置成1</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;  <span class="comment">//-&gt;存储引用计数</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>nonpointer</code>、<code>weakly_referenced</code>、<code>has_sidetable_rc</code>和<code>extra_rc</code>都是 <code>ARC</code>有直接关系的成员变量，其他的大多也有涉及到。</p>
<h3 id="retainrelease做了哪些优化">retain,release做了哪些优化</h3>
<p>大概可以分为如下</p>
<ul>
<li>TaggedPointer 指针优化</li>
<li>!newisa.nonpointer：未优化的 isa 的情况下retain或者release</li>
<li>newisa.nonpointer：已优化的 isa ， 这其中又分 extra_rc 溢出区别 我把相关代码站在下面并且把结论输出出来.</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">内存操作</th>
<th style="text-align: center;">objc_retain</th>
<th style="text-align: center;">objc_release</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">TaggedPointer</td>
<td style="text-align: center;">值存在指针内，直接返回</td>
<td style="text-align: center;">直接返回 false。</td>
</tr>
<tr class="even">
<td style="text-align: center;">!nonpointer</td>
<td style="text-align: center;">未优化的<code>isa</code>,使用<code>sidetable_retain()</code></td>
<td style="text-align: center;">未优化的<code>isa</code>执行<code>sidetable_release</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">nonpointer</td>
<td style="text-align: center;">已优化的<code>isa</code>,这其中又分<code>extra_rc</code>溢出和未溢出的两种情况</td>
<td style="text-align: center;">已优化的<code>isa</code>,分下溢和未下溢两种情况</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>nonpointer已优化isa的extra_rc</th>
<th>objc_retain</th>
<th>objc_release</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>未溢出时</td>
<td><code>isa.extra_rc</code>+1</td>
<td>NA</td>
</tr>
<tr class="even">
<td>溢出时</td>
<td>将<code>isa.extra_rc</code>中一半值转移至<code>sidetable</code>中,然后将<code>isa.has_sidetable_rc</code>设置为<code>true</code>,表示使用了<code>sidetable</code>来计算引用次数</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>未下溢</td>
<td>NA</td>
<td>extra_rc--</td>
</tr>
<tr class="even">
<td>下溢</td>
<td>NA</td>
<td>从<code>sidetable</code>中借位给<code>extra_rc</code>达到半满,如果无法借位则说明引用计数归零需要进行释放,其中借位时可能保存失败会不断重试</td>
</tr>
</tbody>
</table>
<blockquote>
<p>NA -&gt; non available 不可获得</p>
</blockquote>
<p>下面我们看下retain源码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="keyword">id</span> objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;     <span class="comment">// 如果是 TaggedPointer 直接返回</span></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);  <span class="comment">// 获取 isa</span></span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);<span class="comment">// 未优化的 isa 部分</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (<span class="keyword">id</span>)<span class="keyword">this</span> : <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123; <span class="comment">// 正在被释放的处理</span></span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// extra_rc 未溢出时引用计数++</span></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line">        <span class="comment">// extra_rc 溢出</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);   <span class="comment">// 重新调用该函数 入参 handleOverflow 为 true</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 保留一半引用计数,准备将另一半复制到 side table.</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  更新 isa 值</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF); <span class="comment">// 将另一半复制到 side table side table.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>release</code>源码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> objc_object::rootRelease(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);<span class="comment">// 未优化 isa</span></span><br><span class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);<span class="comment">// 入参是否要执行 Dealloc 函数，如果为 true 则执行 SEL_dealloc</span></span><br><span class="line">        &#125;</span><br><span class="line">        newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// donot ClearExclusive()</span></span><br><span class="line">            <span class="keyword">goto</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 isa 值</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> underflow:</span><br><span class="line"> 	<span class="comment">// 处理下溢，从 side table 中借位或者释放</span></span><br><span class="line">    newisa = oldisa;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123; <span class="comment">// 如果使用了 sidetable_rc</span></span><br><span class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</span><br><span class="line">        	ClearExclusive(&amp;isa.bits);<span class="comment">// 调用本函数处理下溢</span></span><br><span class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF); <span class="comment">// 从 sidetable 中借位引用计数给 extra_rc</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// extra_rc 是计算额外的引用计数，0 即表示被引用一次</span></span><br><span class="line">            newisa.extra_rc = borrowed - <span class="number">1</span>;  <span class="comment">// redo the original decrement too</span></span><br><span class="line">            <span class="keyword">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);                                    </span><br><span class="line">            <span class="comment">// 保存失败，恢复现场，重试                                    </span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 = oldisa2;</span><br><span class="line">                <span class="keyword">if</span> (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits = </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</span><br><span class="line">                    <span class="keyword">if</span> (!overflow) &#123;</span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		<span class="comment">// 如果还是保存失败，则还回 side table</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Side table is empty after all. Fall-through to the dealloc path.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有使用 sidetable_rc ，或者 sidetable_rc 计数 == 0 的就直接释放</span></span><br><span class="line">    <span class="comment">// 如果已经是释放中，抛个过度释放错误</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 isa 状态</span></span><br><span class="line">    newisa.deallocating = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">	<span class="comment">// 执行 SEL_dealloc 事件</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结-2">小结</h3>
<p>到这里可以知道 引用计数分别保存在<code>isa.extra_rc</code>和<code>sidetable</code>中，当<code>isa.extra_rc</code>溢出时，将一半计数转移至<code>sidetable</code>中，而当其下溢时，又会将计数转回。当二者都为空时，会执行释放流程</p>
<h2 id="arc下哪些情况会造成内存泄漏">ARC下哪些情况会造成内存泄漏</h2>
<ul>
<li>block中的循环引用</li>
<li>NSTimer的循环引用</li>
<li>addObserver的循环引用</li>
<li>delegate的强引用</li>
<li>大次数循环内存爆涨</li>
<li>非OC对象的内存处理（需手动释放）</li>
</ul>
<h1 id="总结">总结</h1>
<p>以上就是我们讨论上述一套面试题的 runtime相关问题之 内存管理部分,下一篇讲把剩余的问题收一下尾 感谢各位支持</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS面试题" scheme="https://www.sunyazhou.com/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>阿里、字节：一套高效的iOS面试题之runtime相关问题1</title>
    <link href="https://www.sunyazhou.com/2020/07/06/20200721iOSinterviewAnswers/"/>
    <id>https://www.sunyazhou.com/2020/07/06/20200721iOSinterviewAnswers/</id>
    <published>2020-07-06T01:52:47.000Z</published>
    <updated>2020-09-18T11:57:21.021Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover.jpeg"></p>
<h1 id="前言">前言</h1>
<blockquote>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
</blockquote>
<p>记得过年时候 <a href="https://mp.weixin.qq.com/s/bDnsaD__ZpdHIk3_So382w" target="_blank" rel="noopener">有一个微信公众号</a> 的面试题引起了我的关注,但是只有问题没有答案,由于最近半年时间太忙了,博客几乎停更了一个季度,所以今天我打算把这个面试题的答案 整理一下,方便后续iOS开发者需要时可时长关注.期间如果有解答不清楚或者不对之处还请各位指正.</p>
<h1 id="面试题的结构分类和细化">面试题的结构分类和细化</h1>
<ul>
<li>runtime相关问题
<ol type="1">
<li>runtime结构模型</li>
<li>内存管理</li>
<li>关联属性或者hook相关的Method Swizzle</li>
</ol></li>
<li>NSNotification相关
<ol type="1">
<li>参考GNUStep源码</li>
<li>NSNotification实现原理 相关</li>
</ol></li>
<li>Runloop &amp; KVO
<ol type="1">
<li>runloop</li>
<li>KVO</li>
</ol></li>
<li>Block
<ol type="1">
<li>Block实现原理和注意事项相关</li>
</ol></li>
<li>多线程
<ol type="1">
<li>GCD相关和一些多线程概念</li>
</ol></li>
<li>视图&amp;图像相关
<ol type="1">
<li>视图UI布局方案</li>
<li>视图渲染相关</li>
</ol></li>
<li>性能优化</li>
<li>开发证书</li>
<li>架构设计
<ol type="1">
<li>各种设计模式</li>
<li>自己的设计</li>
</ol></li>
<li>其他问题
<ol type="1">
<li>方法调用和切面编程等</li>
</ol></li>
<li>系统基础知识</li>
<li>数据结构与算法</li>
</ul>
<h2 id="runtime相关问题">runtime相关问题</h2>
<p><a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">objc-runtime源码地址</a><br>
<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4官方源码地址</a></p>
<h3 id="结构模型">结构模型</h3>
<h4 id="介绍下runtime的内存模型isa对象类metaclass结构体的存储信息等">介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）</h4>
<h5 id="对象">对象</h5>
<p>OC中的对象指向的是一个<code>objc_object</code>指针类型，<code>typedef struct objc_object *id;</code>从它的结构体中可以看出，它包括一个isa指针，指向的是这个对象的类对象,一个对象实例就是通过这个isa找到它自己的Class，而这个Class中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>这个objc_object 的实现比较长 在这里<a href="https://github.com/RetVal/objc-runtime/blob/master/runtime/objc-private.h" target="_blank" rel="noopener">查看</a></p>
<h4 id="类">类</h4>
<p>在OC中的类是用Class来表示的，实际上它指向的是一个<code>objc_class</code>的指针类型，<code>typedef struct objc_class *Class;</code><br>
对应的结构体如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="class和-object-小结">class和 object 小结</h5>
<p>从结构体中定义的变量可知，OC的<code>Class</code>类型包括如下</p>
<p>数据（即：元数据<code>metadata</code>）：<code>super_class</code>（父类类对象）;<br>
name（类对象的名称）;<br>
version、info（版本和相关信息）;<br>
instance_size（实例内存大小）;<br>
ivars（实例变量列表）；<br>
methodLists（方法列表）；<br>
cache（缓存）；<br>
protocols（实现的协议列表）;<br>
当然也包括一个isa指针，这说明Class也是一个对象类型，所以我们称之为类对象， 这里的isa指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/class_inherit.png" alt="Objective-C的对象原型继承链"> <a href>Objective-C的对象原型继承链</a></p>
<p>从图中可知，最终的基类<code>NSObject</code>的元类对象<code>isa</code>指向的是自己本身，从而形成一个闭环。<br>
元类（<code>Meta Class</code>）：是一个类对象的类，即：Class的类，这里保存了类方法等相关信息。<br>
我们再看一下类对象中存储的方法、属性、成员变量等信息的结构体<br>
<code>objc_ivar_list</code>：存储了类的成员变量，<br>
可以通过<code>object_getIvar</code>或<code>class_copyIvarList</code>获取；<br>
另外这两个方法是用来获取类的属性列表的<code>class_getProperty</code>和<code>class_copyPropertyList</code>，属性和成员变量是有区别的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_type                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_method_list</code>：存储了类的方法列表，可以通过<code>class_copyMethodList</code>获取。</p>
<p>结构体如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable method_types                            OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable obsolete             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_protocol_list</code>：储存了类的协议列表，可以通过<code>class_copyProtocolList</code>获取。</p>
<p>结构体如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_protocol_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable next;</span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Protocol * _Nullable list[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此问题参考<a href="https://developer.aliyun.com/ask/282811" target="_blank" rel="noopener">介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）</a></p>
<h4 id="为什么要设计metaclass">为什么要设计metaclass?</h4>
<p>先说结论: 为了更好的<strong>复用传递消息</strong>.metaclass只是需要<strong>实现复用消息传递</strong>为目的工具.而Objective-C所有的类默认都是同一个MetaClass(通过isa指针最终指向metaclass). 因为Objective-C的特性基本上是照搬的Smalltalk,Smalltalk中的MetaClass的设计是Smalltalk-80加入的.所以Objective-C也就有了metaclass的设计.</p>
<blockquote>
<p>本质上因为Smalltalk的面向对象的亮点是它的<strong>消息发送机制</strong>.</p>
</blockquote>
<p>回答这个问题之前我们先回看一下上边的Objective-C的对象原型继承链<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/class_inherit2.jpg" alt="Objective-C的对象原型继承链"></p>
<p>通过上图我们明白如下 重点内容:</p>
<ul>
<li><strong>实例的实例方法函数存在类结构体中</strong></li>
<li><strong>类方法函数存在metaclass结构体中</strong></li>
</ul>
<p>而Objective-C的方法调用（消息）就会根据对象去找isa指针指向的Class对象中的方法列表找到对应的方法。 &gt; isa 指向的类就是我们创建实例的类型.</p>
<p>通过<a href="https://www.jianshu.com/p/ea7c42e16da8" target="_blank" rel="noopener">Why is MetaClass in Objective-C？</a>文章我们了解到一个十分重要的概念,python和<strong>Objective-C不太一样的是,并不是每一个类都有一个MetaClass,而是Objective-C所有的类默认都是同一个MetaClass.</strong></p>
<h5 id="smalltalk中的metaclass">Smalltalk中的metaclass</h5>
<p>Smalltalk，被公认为历史上第二个面向对象的语言，其亮点是它的<strong>消息发送机制</strong>。<br>
Smalltalk中的MetaClass的设计是Smalltalk-80加入的。而之前的Smalltalk-76，并不是每个类有一个MetaClass，而是所有类的isa指针都指向一个特殊的类，叫做Class(这种设计之后也被Java借鉴了）。<br>
而每个类都有自己MetaClass的设计，加入的原因是，因为Smalltalk里面，类是对象，而对象就可以响应消息，那么类的消息的响应的方法就应该由类的类去存储，而每个MetaClass就持有每个类的类方法。</p>
<h6 id="每个metaclass的isa指针指向什么">每个MetaClass的isa指针指向什么？</h6>
<p>如果MetaClass再有MetaClass，那么这个关系将无穷无尽。Smalltalk里的解决方案是，指向同一个叫MetaClass的类。</p>
<h6 id="metaclass的isa指针指向什么">MetaClass的isa指针指向什么？</h6>
<p>指向他的实例，也就是实例的isa指向MetaClass，同时MetaClassisa指向实例，相互指着。</p>
<p>那么Smalltalk的继承关系，其实和Objective-C的很像了（后面有class的是前者的MetaClass）。</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/class_inherit2_smaltalk.png"></p>
<h6 id="这时候产生了一个重要的问题假如去掉metaclass把类方法放到也类里面是否可行">这时候产生了一个重要的问题，假如去掉MetaClass，把类方法放到也类里面是否可行？</h6>
<p>这个问题，我思索许久，发现其实是一个对面向对象的哲学思想问题，要对这个问题下结论，不得不重新讲讲面向对象</p>
<h5 id="从smalltalk重新认识面向对象">从Smalltalk重新认识面向对象</h5>
<p>以前谈到面向对象，总会提到，面向对象三特征：封装、继承、多态。但其实，面向对象中也分流派，如C++这种来自Simula的设计思想的，更注重的是类的划分，因为方法调用是静态的。而如Objective-C这种借鉴Smalltalk的，更注重的是消息传递，是动态响应消息。</p>
<p>而面向对象三种特征，更基于的是类的划分而提出的。</p>
<p>这两种思想最大的不同，我认为是自上而下和自下而上的思考方式。</p>
<ul>
<li>类的划分，要求类的设计者是以一个很高的层次去设计这个类，提取出类的特性和本质，进行类的构建。知道类型才可以去发送消息给对象。</li>
<li>消息传递，要求的是类的设计者以消息为起点去构建类，也就是对外界的变化进行响应，而不关心自身的类型，设计接口。尝试理解消息，无法处理则进行特殊处理。 在此不讨论两种方式的优劣之分，而着重讲讲Smalltalk这种设计。</li>
</ul>
<p>消息传递对于面向对象的设计，其实在于给出一种对消息的解决方案。而面向对象优点之一的复用，在这种设计里，更多在于复用解决方案，而不是单纯的类本身。这种思想就如设计组件一般，关心接口，关心组合而非类本身。其实之所以有MetaClass这种设计，我的理解并不是先有MetaClass，而是在万物都是对象的Smalltalk里，向对象发送消息的基本解决方案是统一的，希望复用的。而实例和类之间用的这一套通过isa指针指向的Class单例中存储方法列表和查询方法的解决方案的流程，是应该在类上复用的，而MetaClass就顺理成章出现罢了。</p>
<h5 id="为什么要设计metaclass小结">为什么要设计metaclass小结</h5>
<h6 id="回到一开始那个问题为什么要设计metaclass去掉把类方法放到类里面行不行">回到一开始那个问题，为什么要设计MetaClass，去掉把类方法放到类里面行不行？</h6>
<p>我的理解是，可以，但不Smalltalk。这样的设计是C++那种自上而下的设计方式，类方法也是类的一种特征描述。而Smalltalk的精髓正在于消息传递，复用消息传递才是根本目的，而MetaClass只不过是因此需要的一个工具罢了。</p>
<p>参考<a href="https://www.jianshu.com/p/ea7c42e16da8" target="_blank" rel="noopener">Why is MetaClass in Objective-C？</a></p>
<h4 id="class_copyivarlist-class_copypropertylist区别"><strong>class_copyIvarList()</strong> &amp; <strong>class_copyPropertyList()</strong>区别</h4>
<p>先说结论:</p>
<ul>
<li><strong>class_copyIvarList()</strong> 能获取到所有的成员变量,包括 花括号内的变量(<code>.h</code>和<code>.m</code>都包括).</li>
<li><strong>class_copyPropertyList()</strong> 只能获取到 以<code>@property</code>关键字 声明的中属性(<code>.h</code>和<code>.m</code>都包括)</li>
</ul>
<p>区别:</p>
<ul>
<li><code>class_copyIvarList()</code>获取默认是带下划线的变量</li>
<li><code>class_copyPropertyList()</code>获取默认是不带下划线的变量名称.</li>
</ul>
<blockquote>
<p>但是以上两个方法都只能获取到当前类的属性和变量（也就是说获取不到父类的属性和变量）</p>
</blockquote>
<hr>
<p>举例说明:</p>
<p>我们声明一个<code>ClassA</code> 通过 调试代码实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">    <span class="keyword">int</span> _c;</span><br><span class="line">    <span class="built_in">CGFloat</span> d; <span class="comment">//不推荐这样写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>          *arrayA;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>  ) <span class="built_in">NSString</span>         *stringA;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">dispatch_queue_t</span> testQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>如果是通过<code>class_copyIvarList()</code>函数获取则打印如下结果.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--- class_copyIvarList ↓↓↓---</span><br><span class="line">_a</span><br><span class="line">_b</span><br><span class="line">_c</span><br><span class="line">d</span><br><span class="line">_arrayA</span><br><span class="line">_stringA</span><br><span class="line">_testQueue</span><br><span class="line">--------------END----------------</span><br></pre></td></tr></table></figure>
<p>如果是通过<code>class_copyPropertyList()</code>函数获取则打印如下结果.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--- class_copyPropertyList ↓↓↓---</span><br><span class="line">arrayA</span><br><span class="line">stringA</span><br><span class="line">testQueue</span><br><span class="line">--------------END----------------</span><br></pre></td></tr></table></figure>
<p>debug代码如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printIvarOrProperty &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--- class_copyPropertyList ↓↓↓---"</span>);</span><br><span class="line">    ClassA *classA = [[ClassA alloc] init];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;</span><br><span class="line">    objc_property_t *result = class_copyPropertyList(object_getClass(classA), &amp;propertyCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</span><br><span class="line">        objc_property_t objc_property_name = result[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span>, property_getName(objc_property_name)]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(result);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------------END----------------"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--- class_copyIvarList ↓↓↓---"</span>);</span><br><span class="line">    Ivar *iv = class_copyIvarList(object_getClass(classA), &amp;propertyCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</span><br><span class="line">        Ivar ivar = iv[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%s"</span>, ivar_getName(ivar)]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(iv);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------------END----------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上<a href="https://github.com/sunyazhou13/IvarAndPropertyDemo" target="_blank" rel="noopener">demo点击这里下载</a></p>
<hr>
<p>下面我们看下<a href="https://github.com/sunyazhou13/objc-runtime" target="_blank" rel="noopener">objc的源码</a></p>
<p>以下代码位于<code>objc-runtime-new.mm</code>中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_copyPropertyList. Returns a heap block containing the </span></span><br><span class="line"><span class="comment">* properties declared in the class, or nil if the class </span></span><br><span class="line"><span class="comment">* declares no properties. Caller must free the block.</span></span><br><span class="line"><span class="comment">* Does not copy any superclass's properties.</span></span><br><span class="line"><span class="comment">* Locking: read-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">objc_property_t</span> *</span><br><span class="line">class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outCount) *outCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">property_t</span> **result = nil;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = rw-&gt;properties.count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = (<span class="keyword">property_t</span> **)<span class="built_in">malloc</span>((count + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">property_t</span> *));</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; prop : rw-&gt;properties) &#123;</span><br><span class="line">            result[count++] = &amp;prop;</span><br><span class="line">        &#125;</span><br><span class="line">        result[count] = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outCount) *outCount = count;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">objc_property_t</span> *)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码我们可以看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">rw-&gt;properties; <span class="comment">//通过rw直接拿到properties</span></span><br></pre></td></tr></table></figure>
<p>通过rw直接拿到properties,然后便利拿出想要的 以<code>@property</code>关键字 声明变量名称.</p>
<p><code>properties</code>详细内容 还请异步运行时源码看下这里篇幅限制就不啰嗦了.</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_copyIvarList</span></span><br><span class="line"><span class="comment">* fixme</span></span><br><span class="line"><span class="comment">* Locking: read-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">Ivar *</span><br><span class="line">class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> *ivars;</span><br><span class="line">    Ivar *result = nil;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outCount) *outCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ivars = cls-&gt;data()-&gt;ro-&gt;ivars)  &amp;&amp;  ivars-&gt;count) &#123;</span><br><span class="line">        result = (Ivar *)<span class="built_in">malloc</span>((ivars-&gt;count+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Ivar));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ivar : *ivars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ivar.offset) <span class="keyword">continue</span>;  <span class="comment">// anonymous bitfield</span></span><br><span class="line">            result[count++] = &amp;ivar;</span><br><span class="line">        &#125;</span><br><span class="line">        result[count] = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (outCount) *outCount = count;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就一个关键点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ivars = cls-&gt;data()-&gt;ro-&gt;ivars</span><br></pre></td></tr></table></figure>
<p>拿到ivars.</p>
<p>由于这两者拿到的成员不一样所以两个API就会有区别.</p>
<h4 id="class_rw_t-和-class_ro_t-的区别"><code>class_rw_t</code> 和 <code>class_ro_t</code> 的区别</h4>
<p>先说结论:</p>
<ul>
<li>两个结构体都存放着当前类的属性、实例变量、方法、协议等.</li>
<li><code>class_ro_t</code>存放的是编译期间就确定的.</li>
<li>而<code>class_rw_t</code>是在runtime时才确定，它会先将<code>class_ro_t</code>的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说<code>class_rw_t</code>是<code>class_ro_t</code>的超集，当然实际访问类的方法、属性等也都是访问的<code>class_rw_t</code>中的内容.</li>
</ul>
<hr>
<h5 id="下面我来深入了解两者具体是什么">下面我来深入了解两者具体是什么</h5>
<p>首先我们需要了解它俩的由来,在<code>objc_class</code>我们知道有一个成员变量叫<code>isa</code>,我们这里要介绍的是<code>objc_class</code>的另一成员变量<code>bits</code>.</p>
<p><code>objc_class</code>的结构如下:</p>
<figure>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/objc_class_struct.png" alt="objc_class的结构"><figcaption>objc_class的结构</figcaption>
</figure>
<p><code>bits</code> 用来存储类的属性，方法，协议等信息。它是一个<code>class_data_bits_t</code>类型</p>
<p><code>class_data_bits_t</code> 如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    <span class="comment">// method here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体只有一个<code>64bit</code>的成员变量<code>bits</code>，先来看看这<code>64bit</code>分别存放的什么信息：</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/objc_class_bits.png"></p>
<ul>
<li><code>is_swift</code> : 第一个bit，判断类是否是Swift类</li>
<li><code>has_default_rr</code> ：第二个bit，判断当前类或者父类含有默认的<code>retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</code> 方法</li>
<li><code>require_raw_isa</code> ：第三个bit， 判断当前类的实例是否需要<code>raw_isa</code></li>
<li><code>data</code> : 第4-48位，存放一个指向class_rw_t结构体的指针，该结构体包含了该类的属性，方法，协议等信息。至于为何只用44bit来存放地址</li>
</ul>
<h5 id="class_rw_t-和class_ro_t"><code>class_rw_t</code> 和<code>class_ro_t</code></h5>
<p>先来看看两个结构体的内部成员变量</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">    uint32_t reserved;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>class_rw_t</code>结构体内有一个指向<code>class_ro_t</code>结构体的指针.</p>
<p>每个类都对应有一个<code>class_ro_t</code>结构体和一个<code>class_rw_t</code>结构体。在编译期间，<code>class_ro_t</code>结构体就已经确定，<code>objc_class</code>中的<code>bits</code>的<code>data</code>部分存放着该结构体的地址。在<code>runtime</code>运行之后，具体说来是在运行<code>runtime</code>的<code>realizeClass</code> 方法时，会生成<code>class_rw_t</code>结构体，该结构体包含了<code>class_ro_t</code>，并且更新<code>data</code>部分，换成<code>class_rw_t</code>结构体的地址。</p>
<p>用两张图来说明这个过程：</p>
<p>类的<code>realizeClass</code>运行之前：<br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/before_bits.png"></p>
<p>类的<code>realizeClass</code>运行之后：</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/after_bits.png"></p>
<p>细看两个结构体的成员变量会发现很多相同的地方，他们都存放着当前类的属性、实例变量、方法、协议等等。区别在于：<code>class_ro_t</code>存放的是编译期间就确定的；而<code>class_rw_t</code>是在<code>runtime</code>时才确定，它会先将<code>class_ro_t</code>的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说<code>class_rw_t</code>是<code>class_ro_t</code>的超集，当然实际访问类的方法、属性等也都是访问的<code>class_rw_t</code>中的内容</p>
<p>属性(property)存放在<code>class_rw_t</code>中，实例变量(ivar)存放在<code>class_ro_t</code>中。</p>
<p>详细内容请 参考资料<a href="http://vanney9.com/2017/06/05/objective-c-runtime-property-method/" target="_blank" rel="noopener">Objective-C runtime - 属性与方法</a></p>
<h4 id="category如何被加载的两个category的load方法的加载顺序两个category的同名方法的加载顺序">category如何被加载的,两个category的load方法的加载顺序，两个category的同名方法的加载顺序</h4>
<p>结论:</p>
<ol type="1">
<li>category 是 这样 <code>realizeClass</code> -&gt; <code>methodizeClass()</code> -&gt; <code>attachCategories()</code> 一步步被加载的.</li>
<li>主类与分类的加载顺序是:<strong>主类优先于分类加载,无关编译顺序</strong>.</li>
<li>分类间的加载顺序取决于编译的顺序:<strong>编译在前则先加载,编译在后则后加载</strong>.</li>
</ol>
<hr>
<h5 id="category如何被加载的">category如何被加载的</h5>
<p>我在运行时的源码 <code>objc-runtime-new.mm</code>中找到如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Attach categories  被加载</span></span><br><span class="line">	methodizeClass(cls, previously);</span><br><span class="line">	<span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>realizeClass</code> -&gt; <code>methodizeClass()</code> -&gt; <code>attachCategories()</code></p>
<p>核心是在methodizeClass()函数中实现的.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;ro;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</span><br><span class="line">    ...    </span><br><span class="line">    <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码我们发现<code>ro-&gt;baseProperties;</code> , baseProperties 在前，category 在后,</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">property_list_t *proplist = ro-&gt;baseProperties;</span><br><span class="line"><span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">  rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但决定顺序的是 rw-&gt;<code>properties.attachLists ()</code>这个方法.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// category 被附加进去</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="comment">// 将旧内容移动偏移量 addedCount 然后将 addedLists copy 到起始位置</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            struct array_t &#123;</span></span><br><span class="line"><span class="comment">                    uint32_t count;</span></span><br><span class="line"><span class="comment">                    List* lists[0];</span></span><br><span class="line"><span class="comment">                    &#125;;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">        addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以 category 的属性总是在前面的，baseClass的属性被往后偏移了。</p>
<h5 id="两个category的load方法的加载顺序">两个category的load方法的加载顺序</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A class’s +load method is called after all of its superclasses’ +load methods.</span><br><span class="line">一个类的+load方法在其父类的+load方法后调用</span><br><span class="line"></span><br><span class="line">A category +load method is called after the class’s own +load method.</span><br><span class="line">一个Category的+load方法在被其扩展的类的自有+load方法后调用</span><br></pre></td></tr></table></figure>
<p>结论: 主类与分类的加载顺序是:<strong>主类优先于分类加载,无关编译顺序</strong>.</p>
<h5 id="两个category的同名方法的加载顺序">两个category的同名方法的加载顺序</h5>
<p>应用程序 image 镜像加载到内存中时， <code>Category</code> 解析的过程，注意下面的 <code>while(i--)</code> 循环 这里倒序将 <code>category</code> 中的协议 方法 属性添加到了<code>rw = cls-&gt;data()</code>中的 <code>methods/properties/protocols</code>中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 注意下面的代码，上面采用倒叙遍历方式，所以后编译的 category 会先add到数组的前部</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以结论是:分类间的加载顺序取决于编译的顺序:编译在前则先加载,编译在后则后加载</p>
<p>这个问题网上有很多例子 就不多在这举例了.</p>
<h4 id="category-extension区别能给nsobject添加extension吗结果如何"><code>category</code> &amp; <code>extension</code>区别，能给NSObject添加Extension吗，结果如何</h4>
<h5 id="category"><code>category</code></h5>
<ul>
<li>运行时添加分类属性/协议/方法</li>
<li>分类添加的方法会“覆盖”原类方法，因为方法查找的话是从头至尾，一旦查找到了就停止了</li>
<li>同名分类方法谁生效取决于编译顺序，image 读取的信息是倒叙的，所以编译越靠后的越先读入</li>
<li>名字相同的分类会引起编译报错；</li>
</ul>
<h5 id="extension"><code>extension</code></h5>
<ul>
<li>编译时决议</li>
<li>只以声明的形式存在，多数情况下就存在于 .m 文件中；</li>
<li>不能为系统类添加扩展</li>
</ul>
<p>可以给类添加成员变量，但是是私有的 可以給类添加方法，但是是私有的 添加的属性和方法是类的一部分，在编译期就决定的。在编译器和头文件的@interface和实现文件里的<span class="citation" data-cites="implement一起形成了一个完整的类">@implement一起形成了一个完整的类</span>。 伴随着类的产生而产生，也随着类的消失而消失</p>
<blockquote>
<p><strong>必须有类的源码才可以给类添加extension</strong>!!!</p>
</blockquote>
<h5 id="category-extension区别"><code>category</code> &amp; <code>extension</code>区别</h5>
<ul>
<li>Category的小括号中有名字,而Extension没有;</li>
<li>Category只能扩充方法,不能扩充成员变量和属性;</li>
<li>如果Category声明了声明了一个属性,那么Category只会生成这个属性的set,get方法的声明,也就不是会实现.所以对于系统一些类，如nsstring，就无法添加类扩展 不能给NSObject添加Extension，因为在extension中添加的方法或属性必须在源类的文件的.m文件中实现才可以，即：你必须有一个类的源码才能添加一个类的<code>extension</code></li>
</ul>
<h5 id="能给nsobject添加extension吗结果如何">能给NSObject添加Extension吗，结果如何?</h5>
<p>不能 因为没有NSObject的.m源码文件.</p>
<blockquote>
<p>如果能的话那应该不叫Extension.或者我们自己通过运行时的api自己造一套ExtensionDIY.结果就是你用的根本不能称为<code>Extension</code>,而是api调用而已.</p>
</blockquote>
<h4 id="消息转发机制消息转发机制和其他语言的消息机制优劣对比">消息转发机制，消息转发机制和其他语言的消息机制优劣对比</h4>
<blockquote>
<p>前言: 了解消息转发之前我们有必要了解一些Objectivce-C中的消息传递机制</p>
</blockquote>
<h5 id="消息传递机制">消息传递机制</h5>
<p>在Objectivce-C中,我们通过<code>实例变量(对象)</code>或者<code>类方法名</code>调用一个方法,那么我们实际上是在发送一条消息</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = [someObject messageName:parameter];  <span class="comment">//实例调用方式</span></span><br><span class="line"><span class="keyword">id</span> returnValue = [ClassA messageName:parameter];  <span class="comment">//类调用方式</span></span><br></pre></td></tr></table></figure>
<p>上述<code>someObject</code>和<code>ClassA</code>是接受者(receiver)，<code>messageName:</code>是选择器(<code>selector</code>),选择器和参数合起来称为消息(<code>message</code>)。编译器看到此消息后，将其转换为一条标准的c语言函数调用，所调用的函数乃是消息传递机制中的核心函数：<code>objc_msgSend()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_msgSend</span><span class="params">(id self, SEL cmd, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个参数代表接受者，第二个参数代表选择子，后续参数就是消息中的那些参数 编译器会把刚才的那个例子中的消息转换为如下函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:),parameter);</span><br><span class="line"><span class="keyword">id</span> returnValue = objc_msgSend(ClassA, <span class="keyword">@selector</span>(messageName:),parameter);</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSend()</code>函数会依据接受者与选择器的类型来调用适当的方法.为来完成此操作，该方法需要在接受者所属的类中搜寻其“方法列表”(也就是上文我们说的<code>class_ro_t</code>中的method_list)。找到则跳到现实代码，否则，就沿着继承体系继续向上查找，如果还没有则执行消息转发操作。对于其他的“边界情况”，则需要交由Objective-c运行环境的另一些函数来处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">objc_msgSend_stret  <span class="comment">//待发送的消息返回结构体时</span></span><br><span class="line">objc_msgSend_fpret  <span class="comment">//消息返回的是浮点型</span></span><br><span class="line">objc_msgSendSuper   <span class="comment">//如果要给超类发送消息</span></span><br></pre></td></tr></table></figure>
<h5 id="消息转发机制">消息转发机制</h5>
<p>结合上边的消息传递机制,在Objective-C中如果给一个对象发送一条它无法处理的消息，就会进入下图描述的消息转发(Message Forwarding)流程</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/methodforward.jpg"></p>
<p>在objc中消息转发需要经历3个阶段 <code>resolveInstanceMethod</code> -&gt; <code>forwardingTargetForSelectoer</code> -&gt; <code>forwardInvocation</code> -&gt;<code>消息未能处理</code>。</p>
<ul>
<li>第一阶段:<strong>动态方法解析(Dynamic Method Resolution)</strong>也就是在所属的类中先征询接受者,看其是否能动态加方法，来处理当前这个<strong>未知选择器</strong></li>
<li>第二阶段:<strong>替换消息接收者快速转发</strong></li>
<li>第三阶段:<strong>完全消息转发机制</strong></li>
</ul>
<h5 id="第一阶段动态方法解析dynamic-method-resolution">第一阶段:<strong>动态方法解析(Dynamic Method Resolution)</strong></h5>
<p>对象在受到无法解读的消息后，首先将调用其所属类的下列类方法:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这俩方法在NSObject.h中</p>
</blockquote>
<p>返回一个<code>Boolean</code>类型，表示这个类是否能新增一个实例方法以处理选择器.</p>
<p>在 消息转发过程中,我们可以使用<code>resolveInstanceMethod:</code>动态的将一个方法添加到一个类中.</p>
<p>例下面示例代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这里我们用到一个运行时函数<code>class_addMethod()</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL </span><br><span class="line">class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> ! addMethod(cls, name, imp, types ?: <span class="string">""</span>, NO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>class_addMethod()</code>最后一个参数叫做<code>types</code>，是一个描述方法的参数类型的字符串.</li>
<li><code>v</code>代表<code>void</code></li>
<li><code>@</code>代表对象或者说<code>id类型</code></li>
<li><code>:</code>(这个冒号)代表方法选择器SEL</li>
</ul>
<p>具体代表什么不是我们瞎写的,得按照苹果的这个标准 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Objective-C Runtime Programming Guide-&gt;Type Encodings</a></p>
<p>上面的<code>dynamicMethodIMP</code>，返回值是<code>void</code>，两个入参分别是<code>id</code>和<code>SEL</code>，所以描述这个方法的参数类型的字符串就是<code>v@:</code></p>
<p>这个阶段的意义是为一个类动态提供方法实现,严格来说，还没进入消息转发流程。</p>
<p><code>resolveInstanceMethod:</code> 控制这下面两个方法是否会被调用</p>
<ul>
<li><code>respondsToSelector:</code><br>
</li>
<li><code>instancesRespondToSelector:</code></li>
</ul>
<blockquote>
<p>也就是说，如果<code>resolveInstanceMethod:</code>返回了<code>YES</code>，那么<code>respondsToSelector:</code>和<code>instancesRespondToSelector:</code>都会返回<code>YES</code>.</p>
</blockquote>
<h5 id="第二阶段替换消息接收者快速转发">第二阶段：替换消息接收者(快速转发)</h5>
<p>如果第一阶段中<code>resolveInstanceMethod:</code>返回NO,就会调用<code>forwardingTargetForSelector:</code>询问是否把消息转发给另一个对象.消息的接收者就改变了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第三阶段完全消息转发机制">第三阶段：完全消息转发机制</h5>
<p>如果第二阶段的<code>forwardingTargetForSelector:</code>返回了<code>nil</code>，这就进入了所谓完全消息转发的机制。</p>
<p>首先调用<code>methodSignatureForSelector:</code>为要转发的消息返回正确的签名：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardInvocation"</span>);</span><br><span class="line">    SomeOtherObject *someOtherObject = [SomeOtherObject new];</span><br><span class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector:[anInvocation selector]]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是将消息转发给其他对象，其实这与第二阶段中示例代码做的事情是一样的。区别就在于这个阶段会有一个<code>NSInvocation</code>对象。<a href="https://developer.apple.com/documentation/foundation/nsinvocation?language=objc" target="_blank" rel="noopener"><code>NSInvocation</code></a>是一个用来存储和转发消息的对象。它包含了一个Objective-C消息的所有元素：一个target，一个selector，参数和返回值。每个元素都可以被直接设置。</p>
<blockquote>
<p><code>NSInvocation</code>可以简单理解为一个对象把我们用到 selector方法和对象都存储了一下,然后哪个是指向我们需要调用的指针对象.</p>
</blockquote>
<p>所以不同与第二阶段，在这个阶段你可以：</p>
<ul>
<li>把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。</li>
<li>修改消息的target，selector，参数等</li>
<li>多次转发这个消息，转发给多个对象</li>
</ul>
<p>显然在这个阶段，你可以对一个OC消息做更多的事情</p>
<hr>
<h5 id="消息转发机制和其他语言的消息机制优劣对比">消息转发机制和其他语言的消息机制优劣对比</h5>
<p>这个目前没有深入其它编程语言的运行时层面,比如C的底层或者C++的底层或者Java的底层消息传递这里提供 <a href="探索%20Android%20App%20Bundle">一个android的类似消息转发的文章</a></p>
<h4 id="在方法调用的时候方法查询--动态解析--消息转发-之前做了什么">在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么</h4>
<p>Objective-C 实例对象执行方法步骤</p>
<ol type="1">
<li>获取 receiver 对应的类 Class</li>
<li>在 Class 缓存列表中(就是<code>objc_class</code>里的<code>cache_t</code>到<code>class_ro_t</code>的方法list)根据选择子<code>selector</code>查找<code>IMP</code></li>
<li>若缓存中没有找到，则在方法列表中继续查找.</li>
<li>若方法列表没有，则从父类查找，重复以上步骤.</li>
<li>若最终没有找到，则进行消息转发操作.</li>
</ol>
<ul>
<li>方法查询之前 要知道 receiver和 selector.主要是要明确我们是哪个实例调用了哪个方法.<br>
</li>
<li>动态解析解析之前要 在所属的类中先征询接受者,看其是否能动态加方法，来处理当前这个未知选择器.</li>
<li>消息转发 之前 要询问是否把消息转发给另一个对象.</li>
</ul>
<blockquote>
<p>如果更深入的而理解 那应该是 objc_msgSend() 为啥是汇编实现的,上面的那些方法 调用之前 汇编的哪些指令被执行</p>
</blockquote>
<p>这里找到两篇文章可以参考一下<br>
<a href="https://chipengliu.github.io/2019/06/02/objc-msgSend-forward/" target="_blank" rel="noopener">深入了解Objective-C消息发送与转发过程</a><br>
<a href="https://chipengliu.github.io/2019/04/07/objc-msg-armd64/" target="_blank" rel="noopener">汇编语言编写的，其中具体过程细节</a></p>
<h4 id="impselmethod的区别和使用场景"><code>IMP</code>、<code>SEL</code>、<code>Method</code>的区别和使用场景</h4>
<ul>
<li><p><code>IMP</code> : 是方法的具体实现(指针)</p></li>
<li><p><code>SEL</code> :方法名称</p></li>
<li><p><code>Method</code>:是objc_method类型指针，它是一个结构体 ,如下:</p>
<p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">	    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span><br><span class="line">	    <span class="keyword">char</span> * _Nullable method_types                            OBJC2_UNAVAILABLE;</span><br><span class="line">	    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span><br><span class="line">	&#125;</span><br><span class="line">	```  </span><br><span class="line"></span><br><span class="line">使用场景</span><br><span class="line"></span><br><span class="line">* 例如 Button添加Target和Selector的时候.或者 实现类的`swizzle`的时候会用到，通过`class_getInstanceMethod(<span class="keyword">class</span>, SEL)`来获取类的方法`Method`，其中用到了SEL作为方法名</span><br><span class="line"></span><br><span class="line">* 例如 给类动态添加方法，此时我们需要调用class_addMethod(Class, SEL, IMP, types)，该方法需要我们传递一个方法的实现函数IMP，例如:</span><br><span class="line"></span><br><span class="line">``` objc</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> funcName(<span class="keyword">id</span> receiver, SEL cmd, 方法参数...) &#123;</span><br><span class="line">   <span class="comment">// 方法具体的实现   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<blockquote>
<p>SEL相当于 方法的类型 关键字.</p>
</blockquote>
<h4 id="loadinitialize方法的区别什么在继承关系中他们有什么区别"><code>load</code>、<code>initialize</code>方法的区别什么？在继承关系中他们有什么区别</h4>
<p>在Objective-C的类被加载和初始化的时候, 类 是 可以收到 方法回调的.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)load;</span><br><span class="line">- (<span class="keyword">void</span>)initialize;</span><br></pre></td></tr></table></figure>
<h5 id="load"><code>+load</code></h5>
<p><code>+ load</code>方法是在这个文件(就是你复写的子类化的class)被程序装载时调用,只要是在Xcode <code>Compile Sources</code>中出现的文件总是会被装载，这与这个类是否被用到无关，因此+load方法总是在<code>main()</code>函数之前调用.</p>
<p>调用时机比较早，运行环境有不确定因素。具体说来，在iOS上通常就是App启动时进行加载，但当load调用的时候，并不能保证所有类都加载完成且可用，必要时还要自己负责做auto release处理。</p>
<blockquote>
<p>补充上面一点，对于有依赖关系的两个库中，被依赖的类的+load会优先调用。但在一个库之内，父、子类、类别之间调用有顺序，不同类之间调用顺序是不确定的。</p>
</blockquote>
<ul>
<li>关于继承：对于一个类而言，没有+load方法实现就不会调用，不会考虑对NSObject的继承，就是不会沿用父类的+load。</li>
<li>父类和本类的调用：父类的方法优先于子类的方法。一个类的+load方法不用写明<code>[super load]</code>，父类就会收到调用。</li>
<li>本类和Category的调用：本类的方法优先于类别(Category)中的方法。Category的+load也会收到调用，但顺序上在本类的+load调用之后。</li>
<li>不会直接触发initialize的调用。</li>
</ul>
<h4 id="initialize"><code>+initialize</code></h4>
<p><code>+initialize</code>方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用，并且只会调用一次。<code>initialize</code>方法实际上是一种惰性(lazy load)调用，也就是说如果一个类一直没被用到，那它的initialize方法也不会被调用，这一点有利于节约资源.</p>
<p>runtime 使用了发送消息 <code>objc_msgSend</code> 的方式对 <code>+initialize</code> 方法进行调用。也就是说 <code>+initialize</code> 方法的调用与普通方法的调用是一样的，走的都是<code>发送消息的流程</code>。换言之，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 <code>+initialize</code> 方法，那么就会对这个类中的实现造成覆盖(override)。</p>
<ul>
<li>initialize的自然调用是在第一次主动使用当前类的时候。</li>
<li>在initialize方法收到调用时，运行环境基本健全。</li>
<li>关于继承：和load不同，即使子类不实现initialize方法，会把父类的实现继承过来调用一遍，就是会沿用父类的+initialize。（沿用父类的方法中，self还是指子类）</li>
<li>父类和本类的调用：子类的+initialize将要调用时会激发父类调用的+initialize方法，所以也不需要在子类写明[super initialize]。(本着除主动调用外，只会调用一次的原则，如果父类的+initialize方法调用过了，则不会再调用)</li>
<li>本类和Category的调用：Category中的+initialize方法会覆盖本类的方法，只执行一个Category的+initialize方法。</li>
</ul>
<p>下面是我整理的一个表格希望对解释这俩方法有帮助:</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>+ load</th>
<th>+ initialize</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>调用方式</td>
<td>直接使用函数内存地址</td>
<td>objc_msgSend()方式</td>
</tr>
<tr class="even">
<td>调用时机</td>
<td>被程序装载时调用main()函数之前,就是被添加到runtime时</td>
<td>在本类或它的子类收到第一条消息之前被调用</td>
</tr>
<tr class="odd">
<td>是否被系统单次调用(除主动调用外)</td>
<td>是</td>
<td>是</td>
</tr>
<tr class="even">
<td>运行时环境是否稳定</td>
<td>不确定</td>
<td>稳定</td>
</tr>
<tr class="odd">
<td>线程是否安全</td>
<td>默认是安全的(已加锁)</td>
<td>安全(已加锁 )</td>
</tr>
<tr class="even">
<td>特性</td>
<td>由于非<code>objc_msgSend()</code>方式调用就使得 +load 方法拥有了一个非常有趣的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用</td>
<td>+initialize 方法的调用与普通方法的调用是一样的，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖</td>
</tr>
</tbody>
</table>
<p>参考<a href="https://cloud.tencent.com/developer/article/1355957" target="_blank" rel="noopener">类方法load和initialize的区别</a></p>
<h5 id="在继承关系中他们有什么区别">在继承关系中他们有什么区别</h5>
<p>super的方法会成功调用，但是这是多余的，因为runtime会自动对父类的+load方法进行调用，而+initialize则会随子类自动激发父类的方法（如Apple文档中所言）不需要显示调用。另一方面，如果父类中的方法用到的self（像示例中的方法），其指代的依然是类自身，而不是父类</p>
<h4 id="说说消息转发机制的优劣">说说消息转发机制的优劣</h4>
<p>优点:</p>
<ul>
<li>利用消息转发机制可以无代码侵入的实现多重代理，让不同对象可以同时代理同个回调，然后在各自负责的区域进行相应的处理，降低了代码的耦合程度。<br>
</li>
<li>使用 <span class="citation" data-cites="synthesize">@synthesize</span> 可以为 <span class="citation" data-cites="property">@property</span> 自动生成 getter 和 setter 方法（现 Xcode 版本中，会自动生成），而 <span class="citation" data-cites="dynamic">@dynamic</span> 则是告诉编译器，不用生成 getter 和 setter 方法。当使用 <span class="citation" data-cites="dynamic">@dynamic</span> 时，我们可以使用消息转发机制，来动态添加 getter 和 setter 方法。当然你也用其他的方法来实现。</li>
</ul>
<p>缺点:</p>
<ul>
<li>Objective-C本身不支持多继承，这是因为消息机制名称查找发生在运行时而非编译时，很难解决多个基类可能导致的二义性问题，但是可以通过消息转发机制在内部创建多个功能的对象，把不能实现的功能给转发到其他对象上去，这样就做出来一种多继承的假象。转发和继承相似，可用于为OC编程添加一些多继承的效果，一个对象把消息转发出去，就好像他把另一个对象中放法接过来或者“继承”一样。消息转发弥补了objc不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</li>
</ul>
<h1 id="总结">总结</h1>
<p>本篇讲述的面试题中的<strong>runtime相关问题</strong>之<strong>结构模型</strong>部分。下一章打算继续讲一下 <strong>runtime相关问题</strong>之<strong>内存管理</strong>,这样循序渐进把相关面试的文章都讲完.</p>
<p>这里不得不说 这样的面试确实很有挑战,顺便 我也喷一下阿里 头条希望厚道一点,有问题可以但是也要有答案.这件事 让我观察出 这两家公司干事 有头没尾,能善始未能善终.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200721iOSinterviewAnswers/iOSInterviewQuestionsAlbumCover
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS面试题" scheme="https://www.sunyazhou.com/tags/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods清华镜像</title>
    <link href="https://www.sunyazhou.com/2020/04/10/20200410CocoapodsProblems/"/>
    <id>https://www.sunyazhou.com/2020/04/10/20200410CocoapodsProblems/</id>
    <published>2020-04-09T23:13:59.000Z</published>
    <updated>2020-08-10T05:22:36.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="cocoapod疑难杂症">Cocoapod疑难杂症</h2>
<p>这几天开发 总遇到疑难杂症 是因为我的cocoapods升级到了1.9.1,导致各种问题 然后还被和谐,无奈找到如下解决cocoapods各种问题的解决方式</p>
<p>对于旧版的 CocoaPods 可以使用如下方法使用 tuna 的镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ pod repo remove master</span><br><span class="line">$ pod repo add master https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git</span><br><span class="line">$ pod repo update</span><br></pre></td></tr></table></figure>
<p>新版的 CocoaPods 不允许用<code>pod repo add</code>直接添加master库了，但是依然可以：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.cocoapods/repos </span><br><span class="line">$ pod repo remove master</span><br><span class="line">$ git <span class="built_in">clone</span> https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git master</span><br></pre></td></tr></table></figure>
<p>最后进入自己的工程，在自己工程的<code>PodFile</code>第一行加上：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">'https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git'</span></span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>折腾了很久不如找对地方</p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/CocoaPods/" target="_blank" rel="noopener">参考CocoaPods 镜像使用帮助</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用Masonry处理UIView的safeArea边界布局问题</title>
    <link href="https://www.sunyazhou.com/2020/04/07/20200407MasonryTricks/"/>
    <id>https://www.sunyazhou.com/2020/04/07/20200407MasonryTricks/</id>
    <published>2020-04-07T03:54:39.000Z</published>
    <updated>2020-09-15T00:55:47.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="背景">背景</h2>
<p>iOS11之后推出的safeArea 用于处理刘海屏幕的问题.如果自己处理起来可能比较 麻烦 又需要判断 版本又需要判断 API的可用性. 清明假期 在家没事写个demo 解决如何更快捷处理屏幕的边界问题,比如 视图要布局在iOS导航栏底部 和 <code>Home Indicator</code>. 先看下图:</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200407MasonryTricks/SafeArea1.gif"></p>
<p>如果使用更少的代码实现在安全区域内部 展示某个View.</p>
<h2 id="代码实现">代码实现</h2>
<p>这里我们借助Masonry最新库提供的支持API</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.subViewA mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        <span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">            make.top.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideTop);</span><br><span class="line">            make.left.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideLeft);</span><br><span class="line">            make.bottom.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideBottom);</span><br><span class="line">            make.right.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideRight);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            make.top.equalTo(<span class="keyword">self</span>.mas_topLayoutGuideBottom);</span><br><span class="line">            make.left.right.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">            make.bottom.equalTo(<span class="keyword">self</span>.mas_bottomLayoutGuideTop);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里看到safeArea仅仅支持 iOS11以上 那么 iOS11一下 我们可以借出如上述代码 <code>self.mas_topLayoutGuideBottom</code>和<code>self.mas_bottomLayoutGuideTop</code> 这个是<code>self</code>指的是<code>UIViewController</code></p>
</blockquote>
<p>下面我们不用SafeArea来使用一下 如下api</p>
<ol type="1">
<li><p>顶部区域</p>
<ul>
<li><p><code>mas_topLayoutGuide</code>和<code>mas_topLayoutGuideBottom</code>都是 顶到屏幕 刘海屏底部 也就是说和 safeAreaTop一样,如下图:<br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200407MasonryTricks/mas_topLayoutGuide&amp;mas_topLayoutGuideBottom.jpg"></p></li>
<li><p><code>mas_topLayoutGuideTop</code> 顶到屏幕顶部(忽略刘海屏,也就是说被刘海盖住),如下图示: <img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200407MasonryTricks/mas_topLayoutGuideTop.jpg"></p></li>
</ul></li>
<li><p>底部区域</p>
<ul>
<li><p><code>mas_bottomLayoutGuide</code>和<code>mas_bottomLayoutGuideTop</code> 都是在<code>Home条</code>的上面 ,如下图:<br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200407MasonryTricks/mas_bottomLayoutGuide&amp;mas_bottomLayoutGuideTop.jpg"></p></li>
<li><p><code>mas_bottomLayoutGuideBottom</code> 直接推底,撑到屏幕边缘,如下图:<br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200407MasonryTricks/mas_bottomLayoutGuideBottom.jpg"></p></li>
</ul></li>
</ol>
<h4 id="如果想实现和safearea一样的搞法-可以这样写">如果想实现和safeArea一样的搞法 可以这样写</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.subViewA mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.top.equalTo(<span class="keyword">self</span>.mas_topLayoutGuide);</span><br><span class="line">        make.left.right.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">        make.bottom.equalTo(<span class="keyword">self</span>.mas_bottomLayoutGuide);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>!!!注意 LayoutGuide 紧紧适用于<code>ios(7.0,11.0)</code>,也就是说11之后 必须使用safeArea才精准.</p>
</blockquote>
<p>附上一张搞完的效果图</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200407MasonryTricks/LayoutGuideFullsceen.jpg"></p>
<h1 id="总结">总结</h1>
<p>借入Masory 可以更加方便快捷的实现我们想要的布局效果并且不用写宏区分是否是刘海屏或者其他屏幕,因为我们操控的实际上就是 安全区内部的范围. 没事得多关注开源代码时长写个demo实验一下.</p>
<p>所以想实现上文中最佳实践的代码应该是</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.subViewA mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">        make.top.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideTop);</span><br><span class="line">        make.left.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideLeft);</span><br><span class="line">        make.bottom.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideBottom);</span><br><span class="line">        make.right.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideRight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        make.top.equalTo(<span class="keyword">self</span>.mas_topLayoutGuideBottom);</span><br><span class="line">        make.left.right.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">        make.bottom.equalTo(<span class="keyword">self</span>.mas_bottomLayoutGuideTop);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/sunyazhou13/MasonryTrickDemo" target="_blank" rel="noopener">本文Demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="Masonry" scheme="https://www.sunyazhou.com/tags/Masonry/"/>
    
  </entry>
  
  <entry>
    <title>(转)深度理解 NSURLProtocol</title>
    <link href="https://www.sunyazhou.com/2020/03/20/20200320NSURLProtocol/"/>
    <id>https://www.sunyazhou.com/2020/03/20/20200320NSURLProtocol/</id>
    <published>2020-03-20T03:34:22.000Z</published>
    <updated>2020-09-15T00:56:35.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200320NSURLProtocol/NSURLProtocol.png"></p>
<h1 id="前言">前言</h1>
<p>本文经由微信<code>知识小集</code>公众号授权并转载自<a href="https://blog.fiteen.top/2020/hijacking-webview-request-with-nsprotocol" target="_blank" rel="noopener">FiTeen博客</a>,如果版权问题请与我联系sunyazhou13@163.com.转载此文目的是为了记录iOS开发中的重要知识点,防止原文博客寻找起来麻烦.</p>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="nsurlprotocol-是什么">NSURLProtocol 是什么</h2>
<p>NSURLProtocol 是 Foundation 框架中<a href="https://developer.apple.com/documentation/foundation/url_loading_system?language=objc" target="_blank" rel="noopener">URL Loading System</a>的一部分。它可以让开发者可以在不修改应用内原始请求代码的情况下，去改变 URL 加载的全部细节。换句话说，NSURLProtocol 是一个被 Apple 默许的中间人攻击。</p>
<p>虽然 NSURLProtocol 叫<code>Protocol</code>，却不是协议，而是一个<strong>抽象类</strong>。</p>
<p>既然 NSURLProtocol 是一个抽象类，说明它无法被实例化，那么它又是如何实现网络请求拦截的？</p>
<p>答案就是通过<strong>子类化</strong>来定义新的或是已经存在的 URL 加载行为。如果当前的网络请求是可以被拦截的，那么开发者只需要将一个自定义的 NSURLProtocol 子类注册到 App 中，在这个子类中就可以拦截到所有请求并进行修改。</p>
<p>那么到底哪些网络请求可以被拦截？</p>
<h2 id="nsurlprotocol-使用场景">NSURLProtocol 使用场景</h2>
<p>前面已经说了，NSURLProtocol 是 URL Loading System 的一部分，所以它可以拦截所有基于 URL Loading System 的网络请求：</p>
<ul>
<li>NSURLSession<br>
</li>
<li>NSURLConnection<br>
</li>
<li>NSURLDownload<br>
</li>
<li>NSURLResponse
<ul>
<li>NSHTTPURLResponse<br>
</li>
</ul></li>
<li>NSURLRequest
<ul>
<li>NSMutableURLRequest</li>
</ul></li>
</ul>
<p>相应的，基于它们实现的第三方网络框架<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>和<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>的网络请求，也可以被 NSURLProtocol 拦截到。</p>
<p>但早些年基于 CFNetwork 实现的，比如<a href="https://github.com/pokeb/asi-http-request" target="_blank" rel="noopener">ASIHTTPRequest</a>，其网络请求就无法被拦截。</p>
<p>另外，<strong>UIWebView也是可以被NSURLProtocol拦截的,但WKWebView不可以</strong>。（因为 WKWebView 是基于 WebKit，并不走 C socket。）</p>
<p>因此，在实际应用中，它的功能十分强大，比如：</p>
<ul>
<li>重定向网络请求，解决 DNS 域名劫持的问题</li>
<li>进行全局或局部的网络请求设置，比如修改请求地址、header 等</li>
<li>忽略网络请求，使用 H5 离线包或是缓存数据等</li>
<li>自定义网络请求的返回结果，比如过滤敏感信息</li>
</ul>
<p>下面来看一下 NSURLProtocol 的相关方法。</p>
<h2 id="nsurlprotocol-的相关方法">NSURLProtocol 的相关方法</h2>
<h3 id="创建协议对象">创建协议对象</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 URL 协议实例来处理 request 请求</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request cachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse client:(<span class="keyword">id</span>&lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client;</span><br><span class="line"><span class="comment">// 创建一个 URL 协议实例来处理 session task 请求</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTask:(<span class="built_in">NSURLSessionTask</span> *)task cachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse client:(<span class="keyword">id</span>&lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client;</span><br></pre></td></tr></table></figure>
<h3 id="注册和注销协议类">注册和注销协议类</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试注册 NSURLProtocol 的子类，使之在 URL 加载系统中可见</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)registerClass:(Class)protocolClass;</span><br><span class="line"><span class="comment">// 注销 NSURLProtocol 的指定子类</span></span><br><span class="line">+ (<span class="keyword">void</span>)unregisterClass:(Class)protocolClass;</span><br></pre></td></tr></table></figure>
<h3 id="确定子类是否可以处理请求">确定子类是否可以处理请求</h3>
<p>子类化 NSProtocol 的首要任务就是告知它，需要控制什么类型的网络请求。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确定协议子类是否可以处理指定的 request 请求，如果返回 YES，请求会被其控制，返回 NO 则直接跳入下一个 protocol</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"><span class="comment">// 确定协议子类是否可以处理指定的 task 请求</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithTask:(<span class="built_in">NSURLSessionTask</span> *)task;</span><br></pre></td></tr></table></figure>
<h3 id="获取和设置请求属性">获取和设置请求属性</h3>
<p>NSURLProtocol 允许开发者去获取、添加、删除 request 对象的任意元数据。这几个方法常用来处理请求无限循环的问题。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定的请求中获取与指定键关联的属性</span></span><br><span class="line">+ (<span class="keyword">id</span>)propertyForKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"><span class="comment">// 设置与指定请求中的指定键关联的属性</span></span><br><span class="line">+ (<span class="keyword">void</span>)setProperty:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSMutableURLRequest</span> *)request;</span><br><span class="line"><span class="comment">// 删除与指定请求中的指定键关联的属性</span></span><br><span class="line">+ (<span class="keyword">void</span>)removePropertyForKey:(<span class="built_in">NSString</span> *)key inRequest:(<span class="built_in">NSMutableURLRequest</span> *)request;</span><br></pre></td></tr></table></figure>
<h3 id="提供请求的规范版本">提供请求的规范版本</h3>
<p>如果你想要用特定的某个方式来修改请求，可以用下面这个方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回指定请求的规范版本</span></span><br><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br></pre></td></tr></table></figure>
<h3 id="确定请求是否相同">确定请求是否相同</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断两个请求是否相同，如果相同可以使用缓存数据，通常只需要调用父类的实现</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b;</span><br></pre></td></tr></table></figure>
<h3 id="启动和停止加载">启动和停止加载</h3>
<p>这是子类中最重要的两个方法，不同的自定义子类在调用这两个方法时会传入不同的内容，但共同点都是围绕 <code>protocol</code> 客户端进行操作.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始加载</span></span><br><span class="line">- (<span class="keyword">void</span>)startLoading;  </span><br><span class="line"><span class="comment">// 停止加载  </span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading;</span><br></pre></td></tr></table></figure>
<h3 id="获取协议属性">获取协议属性</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取协议接收者的缓存</span></span><br><span class="line">- (<span class="built_in">NSCachedURLResponse</span> *)cachedResponse;</span><br><span class="line"><span class="comment">// 接受者用来与 URL 加载系统通信的对象，每个 NSProtocol 的子类实例都拥有它</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">NSURLProtocolClient</span>&gt;)client;</span><br><span class="line"><span class="comment">// 接收方的请求</span></span><br><span class="line">- (<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"><span class="comment">// 接收方的任务</span></span><br><span class="line">- (<span class="built_in">NSURLSessionTask</span> *)task;</span><br></pre></td></tr></table></figure>
<p>NSURLProtocol 在实际应用中，主要是完成两步：拦截 URL 和 URL 转发。先来看如何拦截网络请求。</p>
<h2 id="如何利用-nsprotocol-拦截网络请求">如何利用 NSProtocol 拦截网络请求</h2>
<h3 id="创建-nsurlprotocol-子类">创建 NSURLProtocol 子类</h3>
<p>这里创建一个名为<code>HTCustomURLProtocol</code>的子类。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTCustomURLProtocol</span> : <span class="title">NSURLProtocol</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="注册-nsurlprotocol-的子类">注册 NSURLProtocol 的子类</h3>
<p>在合适的位置注册这个子类。对基于 NSURLConnection 或者使用<code>[NSURLSession sharedSession]</code>初始化对象创建的网络请求，调用 <code>registerClass</code> 方法即可。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSURLProtocol</span> registerClass:[<span class="built_in">NSClassFromString</span>(<span class="string">@"HTCustomURLProtocol"</span>) <span class="keyword">class</span>]];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// [NSURLProtocol registerClass:[HTCustomURLProtocol class]];</span></span><br></pre></td></tr></table></figure>
<p>如果需要全局监听，可以设置在 <code>AppDelegate.m</code> 的 <code>didFinishLaunchingWithOptions:</code> 方法中。如果只需要在单个 UIViewController 中使用，记得在合适的时机注销监听：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSURLProtocol</span> unregisterClass:[<span class="built_in">NSClassFromString</span>(<span class="string">@"HTCustomURLProtocol"</span>) <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure>
<p>如果是基于 NSURLSession 的网络请求，且不是通过<code>[NSURLSession sharedSession]</code>方式创建的，就得配置 NSURLSessionConfiguration 对象的 <code>protocolClasses</code> 属性。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">sessionConfiguration.protocolClasses = @[[<span class="built_in">NSClassFromString</span>(<span class="string">@"HTCustomURLProtocol"</span>) <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure>
<h3 id="实现-nsurlprotocol-子类">实现 NSURLProtocol 子类</h3>
<p>实现子类分为五个步骤：</p>
<blockquote>
<p>注册 → 拦截 → 转发 → 回调 → 结束</p>
</blockquote>
<p>以拦截 UIWebView 为例，这里需要重写父类的这五个核心方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个协议 key</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> HTCustomURLProtocolHandledKey = <span class="string">@"HTCustomURLProtocolHandledKey"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拓展中定义一个 NSURLConnection 属性。通过 NSURLSession 也可以拦截，这里只是以 NSURLConnection 为例。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLConnection</span> *connection;</span><br><span class="line"><span class="comment">// 定义一个可变的请求返回值，</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableData</span> *responseData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 1：在拦截到网络请求后会调用这一方法，可以再次处理拦截的逻辑，比如设置只针对 http 和 https 的请求进行处理。</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="comment">// 只处理 http 和 https 请求</span></span><br><span class="line">    <span class="built_in">NSString</span> *scheme = [[request URL] scheme];</span><br><span class="line">    <span class="keyword">if</span> ( ([scheme caseInsensitiveCompare:<span class="string">@"http"</span>] == <span class="built_in">NSOrderedSame</span> ||</span><br><span class="line">          [scheme caseInsensitiveCompare:<span class="string">@"https"</span>] == <span class="built_in">NSOrderedSame</span>)) &#123;</span><br><span class="line">        <span class="comment">// 看看是否已经处理过了，防止无限循环</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey:HTCustomURLProtocolHandledKey inRequest:request]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还需要截取 DNS 解析请求中的链接，可以继续加判断，是否为拦截域名请求的链接，如果是返回 NO</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 2：【关键方法】可以在此对 request 进行处理，比如修改地址、提取请求信息、设置请求头等。</span></span><br><span class="line">+ (<span class="built_in">NSURLRequest</span> *) canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</span><br><span class="line">    <span class="comment">// 可以打印出所有的请求链接包括 CSS 和 Ajax 请求等</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"request.URL.absoluteString = %@"</span>,request.URL.absoluteString);</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 3：【关键方法】在这里设置网络代理，重新创建一个对象将处理过的 request 转发出去。这里对应的回调方法对应 &lt;NSURLProtocolClient&gt; 协议方法</span></span><br><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">    <span class="comment">// 可以修改 request 请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="keyword">self</span> request] mutableCopy];</span><br><span class="line">    <span class="comment">// 打 tag，防止递归调用</span></span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES forKey:HTCustomURLProtocolHandledKey inRequest:mutableRequest];</span><br><span class="line">    <span class="comment">// 也可以在这里检查缓存</span></span><br><span class="line">    <span class="comment">// 将 request 转发，对于 NSURLConnection 来说，就是创建一个 NSURLConnection 对象；对于 NSURLSession 来说，就是发起一个 NSURLSessionTask。</span></span><br><span class="line">    <span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:mutableRequest delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 4：主要判断两个 request 是否相同，如果相同的话可以使用缓存数据，通常只需要调用父类的实现。</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> requestIsCacheEquivalent:a toRequest:b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 5：处理结束后停止相应请求，清空 connection 或 session</span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.connection != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">        <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照在上面的方法中做的自定义需求，看情况对转发出来的请求在恰当的时机进行回调处理。</span></span><br><span class="line"><span class="meta">#pragma mark- NSURLConnectionDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSURLConnectionDataDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当接收到服务器的响应（连通了服务器）时会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    <span class="keyword">self</span>.responseData = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">    <span class="comment">// 可以处理不同的 statusCode 场景</span></span><br><span class="line">    <span class="comment">// NSInteger statusCode = [(NSHTTPURLResponse *)response statusCode];</span></span><br><span class="line">    <span class="comment">// 可以设置 Cookie</span></span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到服务器的数据时会调用，可能会被调用多次，每次只传递部分数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    [<span class="keyword">self</span>.responseData appendData:data];</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器的数据加载完毕后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求错误（失败）的时候调用，比如出现请求超时、断网，一般指客户端错误</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didFailWithError:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面用到的一些 NSURLProtocolClient 方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLProtocolClient</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">// 请求重定向</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol wasRedirectedToRequest:(<span class="built_in">NSURLRequest</span> *)request redirectResponse:(<span class="built_in">NSURLResponse</span> *)redirectResponse;</span><br><span class="line"><span class="comment">// 响应缓存是否合法</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol cachedResponseIsValid:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse;</span><br><span class="line"><span class="comment">// 刚接收到 response 信息</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response cacheStoragePolicy:(<span class="built_in">NSURLCacheStoragePolicy</span>)policy;</span><br><span class="line"><span class="comment">// 数据加载成功</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didLoadData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line"><span class="comment">// 数据完成加载</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocolDidFinishLoading:(<span class="built_in">NSURLProtocol</span> *)protocol;</span><br><span class="line"><span class="comment">// 数据加载失败</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didFailWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="comment">// 为指定的请求启动验证</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge;</span><br><span class="line"><span class="comment">// 为指定的请求取消验证</span></span><br><span class="line">- (<span class="keyword">void</span>)URLProtocol:(<span class="built_in">NSURLProtocol</span> *)protocol didCancelAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="补充内容">补充内容</h2>
<h3 id="使用-nsurlsession-时的注意事项">使用 NSURLSession 时的注意事项</h3>
<p>如果在 NSURLProtocol 中使用 NSURLSession，需要注意：</p>
<ul>
<li><p>拦截到的 request 请求的 HTTPBody 为 nil，但可以借助 HTTPBodyStream 来获取 body；</p></li>
<li><p>如果要用 <code>registerClass</code> 注册，只能通过 <code>[NSURLSession sharedSession]</code> 的方式创建网络请求。</p></li>
</ul>
<h3 id="注册多个-nsurlprotocol-子类">注册多个 NSURLProtocol 子类</h3>
<p>当有多个自定义 NSURLProtocol 子类注册到系统中的话，会按照他们注册的反向顺序依次调用 URL 加载流程，也就是最后注册的 NSURLProtocol 会被优先判断。</p>
<p>对于通过配置 NSURLSessionConfiguration 对象的 <code>protocolClasses</code> 属性来注册的情况，<code>protocolClasses</code> 数组中只有第一个 NSURLProtocol 会起作用，后续的 NSURLProtocol 就无法拦截到了。</p>
<p>所以 <a href="https://github.com/AliSoftware/OHHTTPStubs" target="_blank" rel="noopener">OHHTTPStubs</a> 在注册 NSURLProtocol 子类的时候是这样处理的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)setEnabled:(<span class="built_in">BOOL</span>)enable forSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span>*)sessionConfig</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Runtime check to make sure the API is available on this version</span></span><br><span class="line">    <span class="keyword">if</span> ([sessionConfig respondsToSelector:<span class="keyword">@selector</span>(protocolClasses)]</span><br><span class="line">        &amp;&amp; [sessionConfig respondsToSelector:<span class="keyword">@selector</span>(setProtocolClasses:)])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> * urlProtocolClasses = [<span class="built_in">NSMutableArray</span> arrayWithArray:sessionConfig.protocolClasses];</span><br><span class="line">        Class protoCls = HTTPStubsProtocol.class;</span><br><span class="line">        <span class="keyword">if</span> (enable &amp;&amp; ![urlProtocolClasses containsObject:protoCls])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将自己的 NSURLProtocol 插入到 protocolClasses 的第一个，进行拦截</span></span><br><span class="line">            [urlProtocolClasses insertObject:protoCls atIndex:<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!enable &amp;&amp; [urlProtocolClasses containsObject:protoCls])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 拦截完成后移除</span></span><br><span class="line">            [urlProtocolClasses removeObject:protoCls];</span><br><span class="line">        &#125;</span><br><span class="line">        sessionConfig.protocolClasses = urlProtocolClasses;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"[OHHTTPStubs] %@ is only available when running on iOS7+/OSX9+. "</span></span><br><span class="line">              <span class="string">@"Use conditions like 'if ([NSURLSessionConfiguration class])' to only call "</span></span><br><span class="line">              <span class="string">@"this method if the user is running iOS7+/OSX9+."</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何拦截-wkwebview">如何拦截 WKWebView</h2>
<p>虽然 NSURLProtocol 无法直接拦截 WKWebView，但其实还是有解决方案的。就是使用 <code>WKBrowsingContextController</code> 和 <code>registerSchemeForCustomProtocol</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册 scheme</span></span><br><span class="line">Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"WKBrowsingContextController"</span>);</span><br><span class="line">SEL sel = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"registerSchemeForCustomProtocol:"</span>);</span><br><span class="line"><span class="keyword">if</span> ([cls respondsToSelector:sel]) &#123;</span><br><span class="line">    <span class="comment">// 通过 http 和 https 的请求，同理可通过其他的 Scheme 但是要满足 URL Loading System</span></span><br><span class="line">    [cls performSelector:sel withObject:<span class="string">@"http"</span>];</span><br><span class="line">    [cls performSelector:sel withObject:<span class="string">@"https"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但由于这涉及到了私有方法，直接引用无法过苹果的机审，所以使用的时候需要对字符串做下处理，比如对方法名进行算法加密处理等，实测也是可以通过审核的。</p>
<p>总之，NSURLProtocol 非常强大，无论是优化 App 的性能，还是拓展功能，都具有很强的可塑空间，但在使用的同时，又要多关注它带来的问题。尽管它在很多框架或者知名项目中都已经得以应用，其奥义依然值得开发者们去深入研究。</p>
<h1 id="总结">总结</h1>
<p>我认真看了作者的文章 强烈推荐iOS开发小伙伴学习一下.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20200320NSURLProtocol/NSURLProtocol.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;前
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="知识小集" scheme="https://www.sunyazhou.com/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>《孙亚洲理论》的诞生</title>
    <link href="https://www.sunyazhou.com/2020/02/07/20200207SunyazhouTheory/"/>
    <id>https://www.sunyazhou.com/2020/02/07/20200207SunyazhouTheory/</id>
    <published>2020-02-06T20:59:11.000Z</published>
    <updated>2020-08-10T05:22:36.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>由于基础知识薄弱，我所做到的内容仅限于学习和观察到的一些事实，未能上升为理论学说.</p>
<h2 id="非著名的the-sunyazhou-theory">非著名的《The Sunyazhou Theory》</h2>
<p>国家要想发展必须从提高生产力上入手，技术是目前为止人类发现唯一解决生产力问题的有力工具。 所以我把生产力分为三个阶段:</p>
<ol type="1">
<li>解放生产力<br>
</li>
<li>提高生产力<br>
</li>
<li>突破生产力</li>
</ol>
<p>我把它称为<strong><code>《孙亚洲理论》</code></strong>英文<strong><code>《The Sunyazhou Theory》</code></strong>，目前没有任何权威杂志发表。</p>
<h2 id="验证理论">验证理论</h2>
<p>这种理论证明的客观事实是，发展中国家，发展阶段一定是:</p>
<ol type="1">
<li>小规模制造可用商品<br>
</li>
<li>优化并提升工艺水平流水线作业<br>
</li>
<li>再到被新的产品取缔淘汰的过程</li>
</ol>
<p>所以活在当下，无论上学还是工作，<strong>技术人员远比普通人员有优势，因为它验证了我的理论学说，从事提高生产力的职业。</strong></p>
<p>我希望多年后大家提起这个道理的时候能想到，啊这就是非著名的《孙亚洲理论》.</p>
<h1 id="总结">总结</h1>
<p>过年回家总有人问在北京工作工资高如何如何,我就简单发表一下我的看法并扯淡的形成了自己的理论学说.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;由于基础知识薄弱，我所做到的内容仅限于学习和观察到的一些事实，未能上升为理论学说.&lt;/p&gt;
&lt;h2 id=&quot;非著名的the-sunyazhou-theory&quot;&gt;非著名的《The Sunyazhou Theory》&lt;/h2&gt;
&lt;p&gt;国家
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2019年终总结</title>
    <link href="https://www.sunyazhou.com/2019/12/31/20191231FinalSummary/"/>
    <id>https://www.sunyazhou.com/2019/12/31/20191231FinalSummary/</id>
    <published>2019-12-31T15:30:00.000Z</published>
    <updated>2020-09-15T01:50:25.076Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/AlanTuring.jpg"></p>
<p>2019年 <a href="https://baike.baidu.com/item/%E8%89%BE%E4%BC%A6%C2%B7%E9%BA%A6%E5%B8%AD%E6%A3%AE%C2%B7%E5%9B%BE%E7%81%B5/3940576?fromtitle=%E9%98%BF%E5%85%B0%C2%B7%E5%9B%BE%E7%81%B5&amp;fromid=10961384" target="_blank" rel="noopener">阿兰图灵</a>(计算机的先驱缔造者)将出现在未来的50英镑纸币的封面,这将是计算机发展史上的里程碑,是他破解了德国的著名密码系统Enigma，帮助盟军取得了二战的胜利.没有他就没有今天的计算机.</p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<blockquote>
<p>望极天涯博渐卑,而立三十我是谁.<br>
压年抑岁匆匆过,回头碌碌变无为.<br>
人言北漂薪资高,力图迈进皆煎熬.<br>
星辰大海尽在此,诗与远方路迢迢.</p>
</blockquote>
<p>年终了,墨守成规交出2019的年终总结</p>
<h2 id="回顾">2019回顾</h2>
<p>今年事件如下:</p>
<ul>
<li>工作</li>
<li>装修</li>
<li>日本之旅</li>
<li>生活</li>
<li>读书</li>
<li>买摩托车</li>
<li>买汽车</li>
<li>健康</li>
<li>五年计划</li>
<li>总结</li>
</ul>
<h3 id="工作">工作</h3>
<p>今年工作很稳定,一直在快手干活,只是从6月份开始被调整去做一个新的app<code>快手极速版</code>,目前来看还不错,由于去年我所在的直播团队获得了<code>业务突破奖</code>.公司发了<code>500w</code>的奖金,显然这没我们什么事,只是出去团建的档次或许能提高一下.</p>
<p>今年有一件愉快的事情是我分享的一下AVAudioSesion相关文章,给个奖励,激励我不断学习专研技术.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/share1.jpg"> <img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/share2.jpg"></p>
<blockquote>
<p>感谢我手官方,如此关怀备至.</p>
</blockquote>
<p>公司在逐渐壮大,不知不觉中好像我也成了一名老员工,毕竟我来的时候工号1807号,现在目测得到10000+了.为了支撑公司业务,我不得不听从公司安排到其它业务线去做事情.心中有一种落差是从一个500w的团队去一个不是很好的团队,当时还充满了各种X数.即便各种委屈也只能作为一块砖哪里用哪里搬,当时就觉得也许干两个月就得凉凉,没想到不但没凉搞的还不错. 刚去开搞的时候那种连续几天工程编译不过的痛苦还浮现在脑海中,那种痛苦就是这个东西要是搞不定明天就得离职.</p>
<p>深处这个高风险高收益高失业率的行业上,连续2年以上不换工作已经太难了.这个行业几乎每天晚上12点睡觉早晨9点到公司. 这的确是拿生命来换钱,每次去理发店我都要求理发小哥先帮我剪一下白头发.如果你没做好心里准备的时候我不建议你选择IT行业,开发不是一件小事情,干到中年你就知道啥叫失业.</p>
<p>从百度,金山再到快手,这几年的变化让我不断产生新的想法. <strong>快手是我在北京的最后一家公司,没有哪家能像它一样接地气.</strong></p>
<p>就在我写这篇文章的时候,我参与开发的<code>快手极速版</code>已经登上了App Store top1.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/nebula.png"></p>
<p>我2019年的年终OKR就是要把快手极速版送上App Store top1的宝座,今天实现了.</p>
<h3 id="装修">装修</h3>
<p>2019年初 开发商交房之后办理了入户手续,然后就开始准备着手装修.入户的时候心情很激动毕竟花了100w+ 的房子开发商没跑路,也没烂尾. 入户的时候需要缴纳各种费用 2w+多点吧.开发商被我们业主维权维的还算良心,免除供热费和其它零碎的费用小几千块钱. 但是 入户依赖各种问题 我就不说了 买房如果你有钱 就买别墅,没钱就买二手房,买新房除非你财富自由和时间经历都多,否则你会慢慢体会到什么叫<code>磨练灵魂</code>.</p>
<p>装修是我女朋友父母帮忙全权搞的,全部都是自己家人做的,不能说多好,毕竟不专业,但是能用就行了 我就这标准. 全都下来 17w多吧</p>
<p>下图是装完最后上理石包口的场景.<br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/decoration1.gif"><br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/decoration2.gif"></p>
<p>下面是装修完最后的一张图<br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/decoration3.gif"></p>
<p>具体的装修套路我大概了解一二供后续装修的各位参考:</p>
<ol type="1">
<li>规划设计</li>
<li>改水改电</li>
<li>刷墙固地固(这是一种胶防止墙面腐蚀防潮防碱的东西)</li>
<li>包好下水管道,静音棉捆扎</li>
<li>地面铺砖包口厨房洗手间 瓷砖上墙</li>
<li>集成吊顶</li>
<li>刷大白墙面</li>
<li>买家电 厨房 集成灶还是吸油烟机灶台.</li>
<li>厨房橱柜,卧室木柜等等 木工的活 10.木门定制 11.理石包口、包括厨房灶台板、过门石、地脚线等</li>
<li>收工准备开始买各种家电沙发洗衣机 冰箱电视等等.</li>
</ol>
<p>基本就是上述套路 不完善哈.</p>
<h5 id="装修需要注意的地方">装修需要注意的地方</h5>
<blockquote>
<p>最重要的是理石包口,我家用的比较贵,家里亲戚干的 得10000+左右整体,因为我地脚线都用的天然石,这玩意太贵了 260+/m,不过确实好看,我建议大家把窗口用这种高档的理石包裹上,踢脚线用一些便宜的几十块钱的港石就行了,这样看起来高档还不贵.</p>
</blockquote>
<h4 id="领我感动的一件事">领我感动的一件事</h4>
<p>我在快手上关注一个叫<code>华图聊装修</code>的大龙哥,这个用户我们经常聊天,聊快手,作为一个iOS研发我能做的就是把app做好,保证主播和观众能顺畅的使用快手开播或者看直播业务,这是我的工作,这个主播跟我说 如果没有快手 我的装修公司有可能今年就干黄了,感谢快手官方每个月能认识几个老铁来找他装修. 我突然感觉我在的这家公司是有温度的,他拯救了至少我看到 这样一家小的企业.</p>
<p>这里不是打广告 是我觉得他干装修比我上面说的要专业,大家找不找他无所谓,我觉得只要大家想装修的时候不被坑多学习学习这些方面的知识很重要, 他的快手号大家打开快手搜索即可.</p>
<h3 id="日本之旅">日本之旅</h3>
<p>今年五一以后,直播团队迎来了第一次团建,经过大家投票决定去日本,但是每个人需要自己补贴费用至少5000+以上,由于以前也经历过这样的事情,没有买房,所以当时也没敢报名,现在打算出去看看,长长见识.看看资本主义.</p>
<p>北京首都国际机场直飞日本东京羽田机场</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel1.jpg"></p>
<blockquote>
<p>出乎我意料的是这飞机是沿着朝鲜和韩国的38线飞过去的.</p>
</blockquote>
<p>到达东京坐大巴,日本的车牌让我震惊了</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel2.png"></p>
<p>简单几个数字就能代表一个车牌.</p>
<p>上车后 我发现一下非常实用的设计 大巴的杯架</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel4.gif"></p>
<p>不说咱崇洋媚外,就说这玩意为啥国内公交车没有吧!这玩意又没技术含量,这么人性化设计简直太难得了.</p>
<p>东京湾的港口以及工厂基本说明了,日本之所以发达的原因</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel5.gif"></p>
<p>日本属于英联邦国家,道路左侧通行,一辆辆卡车擦的锃亮.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel6.png"></p>
<p>右舵的司机位置, 我只听过 日本司机戴白手套,这回见到了. 我还见到了 这司机把相同颜色的行李箱分组摆放,这点真是不一样,方便色盲的游客快速找到自己的行李箱.</p>
<p>去的第一个景点是<code>平和公园</code>,没有拍照可惜了,空气湿度很好. 从随处可见的蝴蝶就能看出来,环境不错.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel7.gif"></p>
<p>到达<code>山梨县</code>温泉酒店</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel9.jpg"></p>
<p>这个小县里的药妆店</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel10.jpg"></p>
<p>让我感到资本主义落后社会主义兴盛的唯一客观特征是<code>电线杆子</code>在日本随处可见.</p>
<p>日本山梨县交警队</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel8.jpg"></p>
<p>日本的送餐摩托车</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel11.jpg"></p>
<p>看这整齐的车队,比起国内的送餐车除了不环保以外,其实还是很板正的. 啥时候国内能这样整齐的配备送餐工具车那我的祖国基本已经进入了发达国家的行列.这种车在日本被成为<code>大脚摩托</code>.前面还是分体式独立悬挂设计.备箱至少能送超过20人的餐食吧,一箱油200公里. 简直就是发达国家的标配.</p>
<p>日式温泉酒店</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel12.png"></p>
<p>被子叠起来就桌子一放就能吃饭 ，省空间 省地方,是挺方便.</p>
<p>第二天去富士山,富士山掠影</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel13.jpg"></p>
<p>回来的路上,看到每家房前屋后都有几罐燃气.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel14.jpg"></p>
<p>日本的居民用车<code>K-CAR</code> 它不能超过660cc排量.小到非常实用.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel15.jpg"></p>
<p>忍野八海 清澈的池塘,让我不禁想起 毛爷爷的那句<strong>鹰击长空鱼翔浅底</strong></p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel20.jpg"></p>
<p>下午我们抵达东京 去 天皇皇居外面参观</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel16.jpg"></p>
<blockquote>
<p>他叫<a href="https://baike.baidu.com/item/%E6%A5%A0%E6%9C%A8%E6%AD%A3%E6%88%90" target="_blank" rel="noopener">楠木正成</a>,相当于日本的诸葛亮. 日本也有类似我们的三国时期被称为<a href="https://baike.baidu.com/item/%E6%A5%A0%E6%9C%A8%E6%AD%A3%E6%88%90" target="_blank" rel="noopener">战国时代</a>1467—1585年或1615年,也就是 丰臣秀吉、织田信长、德川家康 ,最后以德川幕府取得最终的胜利建立今天的日本天皇时代.</p>
</blockquote>
<p>行程的第三天我们自由行 来到的 日本东京繁华的接头<code>新宿</code></p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel19.jpg"></p>
<p>日本的街头 人行横道原来是 横向 竖向 对角都可以.</p>
<p>第三天我们自由行 晚上去了<code>六本目之丘</code>,俯瞰东京塔和繁华的东京夜景</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel18.jpg"></p>
<p>最后一天 去东京港 看一看 曾经日本在美国军舰密苏里号上签字宣布无条件投降的东京湾.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/japen_travel17.jpg"></p>
<p>由于篇幅较长 这里简短的介绍到这里.</p>
<h4 id="总结日本之旅-建设好我的祖国">总结日本之旅-建设好我的祖国</h4>
<p>去了一趟顿感深深的被资本主义教育了, 日本的街头鳞次栉比的房舍,整齐的送餐摩托,干净直饮的街头水龙头,污水沟的水清澈见底,房前屋后的清洁燃气,排量不超过 660cc的家用车,垃圾分类桶,东京湾水陆两栖的公交车,新宿街头横向对角的人行横道. 无论哪里都透漏出日本人环保和以实用为原则的生活原则. 非吾崇洋媚外,确实得师夷长技,尝想此处皆受灵魂之考问,我国尚处社会主义初级阶段,日本的移动网络建设不怎么好,互联网发展不如我们,移动支付不如我们,电动汽车不如我们,这些都是今天的日本需要像我们学习的.日本大多数人都认为中国的邓小平的改革开放没有错,这是一个『金钱至上』的社会,日本也一样.我相信在未来10~20年中国的一定能超过日本</p>
<p>经过了这次日本之旅深深地教育了我,一定要建设好我的祖国,要从自己擅长的专业抓手做起,做到极致这就是对国家和人民的贡献.我的旅行不是走马观花,我的照片就是记录历史.</p>
<h3 id="生活">生活</h3>
<p>今年北漂已经过了第6个年头了,在北京的生活 虽然工资高很多,但是我过的很压抑,这种压抑感前所未有,我可以这样说,我每天除了工作连放假都不知道去哪里,没有一点乐趣,这种状态每天都在持续.业余爱好不提也罢,年终的时候工作几乎忙到回家走路都能睡着.睡不着觉的时候都在考虑这是不是我在 北京的最后一周.北漂不值得,没做好充分的准备不要来,除非你被生活逼的走投无路.</p>
<p>从现在30岁看6年前的自己那肯定是强多了,但要是看5年前、4年前、3年前的自己,没有最差只有更差.我不想成为房奴,希望2020能彻底拜托房奴的身份,贷款目前还剩10w就全部还完了.还得撸起袖子加油干.</p>
<p>今年把户口迁到了哈尔滨.从此脱离农村户口,还是前几年我的年终总结里说的,户口对于我们这样的年轻人简直太重要了,你没农村户口你永远理解不了啥叫小农经济的思想的思想根深蒂固,并且形成一定的思维定势以后你就不想把户口迁移到城市里.城市户口对年轻人买房贷款、子女入学、社会服务体系等太重要了.__小时候在农村生活，总听到什么劳动人民很光荣，农民很光荣，可是我没见哪个城里人回来当农民，农民不是光荣吗？他们怎么不回来做一些光荣的事情呢？长大后明白了他们不可能不光荣，因为他们生活在社会底层，你说他们不光荣那是阶级歧视，可是大家干的事都是城里人的事，谁愿意回去种地.__</p>
<p>迁移户口的流程大概是这样的</p>
<ol type="1">
<li>提供身份证 原件+复印件</li>
<li>提供户口 户主页和本人页+户主页复印件+本人页复印件</li>
<li>提供学历证书 原件+复印件 并且提供学历查询二维码也就是去学信网查询的确认单</li>
<li>购房合同原件+复印件</li>
<li>购房发票原件</li>
<li>我的小区是爱达88要去南岗区王岗派出所</li>
<li>找户籍民警 整理材料出具迁移意见</li>
<li>找派出所所长签字</li>
<li>到柜台办理</li>
<li>我顺道把身份证也一起换了地址 &gt; 如果是本省基本不需要准迁证 直接迁移不用回原籍,如果是外省则需要在原籍派出所办理申请迁出手续,然后到想迁入地的派出所办理接收手续.操作很费事还得两地折腾.</li>
</ol>
<p>整套户口办理完需要2个小时左右,身份证大概需要半个月以上</p>
<p>身份证办理完到我回到北京,把所有用到的各种证件银行卡、支付宝微信、工作居住证、居住证等等全部办理了更新身份信息的操作.</p>
<p>全套办理一圈发现换个户口换个身份证太麻烦了.</p>
<h3 id="读书">读书</h3>
<p>今天几乎没有太多时间读书了,看的最多的是迈腾维修说明书</p>
<p>买了谭浩强最新出的C程序设计</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/cprogram.jpg"></p>
<p>买了鸟哥最新出的linux</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/LinuxNew.png"></p>
<p>这两本书基本陪我走过了一半的职业生涯,家里装修完了,这些书都要放到书架上珍藏起来. 据说最新版本的linux使用的已经不是centos6了,是centos7操作系统了.有时间把树莓派装上,感觉很棒.</p>
<h3 id="买摩托车">买摩托车</h3>
<p>2019年北京出了限制性政策,说不符合标准的电动车2年后禁止上路,于是我把我的小牛N1s卖了,换了一辆摩托车代步,为了摩托又现去海淀驾校增驾的摩托车.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/motocycle1.jpg"> <img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/motocycle2.jpg"></p>
<p>买个踏板就够用了, 这摩托叫 django 150(姜戈) ,是济南轻骑制造.目前安全骑行3000公里,没有任何问题,价格2w+.买车的时候正好赶上国家执行150cc以下排量的摩托车免税.这辆车希望能骑回哈尔滨.用以纪念北京工作的这几年.</p>
<p>如果你对摩托车不了解可以下载个叫<code>哈罗摩托</code>的app看下 就了解了.</p>
<p>为了增驾摩托车,又从科目一考到科目四,从报考到练车再到拿本用时11天.非常到位,不过夏天练摩托车是真热</p>
<p>摩托车(2轮)科目二 练习<br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/drivin_license_exam1.gif"></p>
<p>摩托车(3轮)科目二 练习<br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/drivin_license_exam2.gif"></p>
<h5 id="摩托车考试流程">摩托车考试流程</h5>
<ul>
<li>科目一理论
<ol type="1">
<li>100道题</li>
</ol></li>
<li>科目二
<ol type="1">
<li>起步</li>
<li>定点停车坡道起步</li>
<li>单边桥</li>
<li>绕桩</li>
</ol></li>
<li>科目三上路实测
<ol type="1">
<li>人行横道减速</li>
<li>调头</li>
<li>换档加速</li>
<li>打开右转向灯减速停车</li>
</ol></li>
<li>科目四理论
<ol type="1">
<li>100道题</li>
</ol></li>
</ul>
<p>如果是报考三轮摩托的驾驶本后边是D,两轮摩托车是E, D向下兼容,也就是说你考完D本直接就能开2轮摩托.</p>
<p>如果你是C本 比如:C1 当你考完2轮摩托车你的驾驶本会变成 C1E或者C2E, (C1代表手动挡,C2代表自动挡),原来的驾驶本回收重新印发新的驾驶本并且区分E或者D是实习期到多久.基本问题都不大,实习期不能上高速.</p>
<p>其它的A本或者B本不知道,没测试过大家可以网上查查.</p>
<p>关于扣分,当你拥有 C1E的时候 你要倍加小心, 因为你一共拥有12分不区分 C还是E还是D，只要你开车扣分是一样的,拥有一辆车和一辆摩托车和你有两辆汽车是一样的就是12分多一分没有,如果你骑摩托车扣了12分那你汽车就别想开了,赶紧准备考试科目一科目四.</p>
<p>摩托车科目二也不那么容易过,中途比如绕桩、单边桥只要脚点地就算不合格考试失败, 坡道起步最多停留30秒并且脚只允许点一次地面.</p>
<h3 id="买汽车">买汽车</h3>
<p>对于一个拿驾照2年多的我还从未尝试正经开过车,没有车练习怕以后用到的时候手足无措,今年没想到经过同学介绍碰到了一个合适的二手车,车况不错.于是坐飞机回去就买了.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/magotan1.jpg"> <img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/magotan2.jpg"> <img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/magotan3.jpg"> <img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/magotan4.jpg"></p>
<p>他叫<code>迈腾</code>B7L,2013年12月左右出厂的第7代迈腾(目前最新出的是迈腾B8.5后边带字母)我接手前 这车实表跑了8w左右.全车4s店保养,没出过大毛病.迈腾2013豪华版2.0TSI,我以10.5w买下. 办理牌照和保险以及保养全部搞完11w左右.</p>
<p>买到手第一件事加装倒车翻标摄像头,也就是大众车标翻盖伸出来一个摄像头用于倒车影像.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/magotan5.jpg"></p>
<p>开到北京周末闲暇的时候洗洗车打打蜡跟新的一样.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/magotan6.jpg"></p>
<p>说说买车的过程吧, 原车主一开始以为我不会买他的车也就没当回事,后来发现我连车都不看直接交易这个过程就有点认真了回去直接把全部证件都拿来了,下午4点办理完各种保险 第二天把车一顿保养,上100w的商保,开车回北京,期间感谢同学姚志强,一路办牌照压牌等等手续都板正的帮我整利索了,我这初中同学是在哈尔滨平房一个叫诚杰一汽大众4s店工作,所以在有人办事真快真方便.他在4s店我买车没理由不选择大众.原来的车主小伙送了我一套雪地胎很棒.</p>
<p>这车买回来的一些小毛病</p>
<ol type="1">
<li>前风挡玻璃被石子打过 我自己在天猫上买了玻璃修复工具,自己动手解决了</li>
<li>后排座椅塑料插口坏了,我在网上话几十块钱买个新的装上了非常好使.</li>
<li>汽车轮胎, 由于原车主送了一套雪地胎,原车的4条邓禄普还能对付5000公里没问题,最近把雪地胎换上了然后把原车的邓禄普卖了200块钱.</li>
<li>换了新的火花塞,机油、空滤以及刹车油、玻璃水. &gt; 其它啥毛病没有,这车的变速箱DSG湿式双离合还在质保期内(10年或者16w公里)</li>
</ol>
<p>2020年过年回家把发发动机机油尺处渗油的问题解决一下,然后刹车片刹车盘都换换.过完年回来看看买一套新的马牌轮胎换上.</p>
<p>买了这个车虽然在北京不怎么开,但是它带给我很多乐趣,有时间的时候我去擦擦车,买一些汽车养护用品,自己能修理的地方就自己 DIY搞定很有成就感.</p>
<h3 id="健康">健康</h3>
<p>2019年对30年的牙齿进行了一次大保养,连续跑了20多趟北京口腔医院,终于把牙齿修理的非常板正. 每年体检,有问题及时就医治疗,2019年医疗保险至少为我节省了5000多,今年的医疗花费开支2w+.</p>
<h3 id="五年计划">五年计划</h3>
<p>2019年相当于第一个"五年计划"的收尾，由于2018年的五年计划完成70%左右，所以这一年还是沉淀沉淀，静下心来争取100%完成再开始新计划。</p>
<p>2020开始制订新的"五年计划"，争取2025年底完成如下:</p>
<ol type="1">
<li>在哈尔滨或者其它城市买一套小户型的房产一室一厅一卫，带车位 全款结清</li>
<li>投资岳父岳母开个洗车店，争取不让他们出去打工</li>
<li>（如果可能)创建一所大学，设立30+个专业并设立实验室，专攻卡中国脖子的35项关键技术！即便不能解决卡脖子技术也要为这些尖端科技培养人才做出努力，一定要建设好我的祖国</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/ms2TbtZyEHYqoQGHQrJY5A" target="_blank" rel="noopener">这篇文章</a>介绍了目前卡中国脖子的34项尖端科技.</p>
<h5 id="光刻机">光刻机</h5>
<p>制造芯片的光刻机，其精度决定了芯片性能的上限。在“十二五”科技成就展览上，中国生产的最好的光刻机，加工精度是90纳米。这相当于2004年上市的奔腾四CPU的水准。而国外已经做到了十几纳米。</p>
<p>光刻机里有两个同步运动的工件台，一个载底片，一个载胶片。两者需始终同步，误差在2纳米以下。两个工作台由静到动，加速度跟导弹发射差不多。在工作时，相当于两架大飞机从起飞到降落，始终齐头并进一架飞机上伸出一把刀，在另一架飞机的米粒上刻字，不能刻坏了。</p>
<blockquote>
<p>来源：《这些“细节”让中国难望顶级光刻机项背》 （科技日报4月19日）</p>
</blockquote>
<h5 id="芯片">芯片</h5>
<p>低速的光芯片和电芯片已实现国产，但高速的仍全部依赖进口。国外最先进芯片量产精度为10纳米，我国只有28纳米，差距两代。据报道，在计算机系统、通用电子系统、通信设备、内存设备和显示及视频系统中的多个领域中，我国国产芯片占有率为0。</p>
<blockquote>
<p>来源：《中兴的“芯”病，中国的心病》</p>
</blockquote>
<h5 id="操作系统">操作系统</h5>
<p>普通人看到中国IT业繁荣，认为技术差距不大，实则不然。3家美国公司垄断手机和个人电脑的操作系统。数据显示，2017年安卓系统市场占有率达85.9%，苹果IOS为14%。其他系统仅有0.1%。这0.1%，基本也是美国的微软的Windows和黑莓。没有谷歌铺路，智能手机不会如此普及，而中国手机厂商免费利用安卓的代价，就是随时可能被“断粮”。</p>
<blockquote>
<p>来源：《丧失先机，没有自研操作系统的大国之痛》</p>
</blockquote>
<h4 id="航空发动机短舱">航空发动机短舱</h4>
<p>飞机上安放发动机的舱室，俗称“房子”，是航空推进系统最重要的核心部件之一，其成本约占全部发动机的1/4左右。短舱需要将发动机包覆，减少飞行阻力；其进气道还要具有防、除冰的能力；飞行中，要保护发动机不受干扰正常工作；在地面，需要做到方便发动机的维护和维修，一旦短舱有损，飞行中可能会引起发动机严重事故。短舱越大技术难度越高。我国在这一重要领域尚属空白。查阅所有公开资料，我国尚无自主研制短舱的专门机构，相关院校似乎也没有设置相关的学科。</p>
<blockquote>
<p>来源：《居者无其屋，国产航空发动机的短舱之困》</p>
</blockquote>
<h5 id="触觉传感器">触觉传感器</h5>
<p>触觉传感器是工业机器人核心部件。精确、稳定的严苛要求，拦住了我国大部分企业向触觉传感器迈进的步伐，目前国内传感器企业大多从事气体、温度等类型传感器的生产。在一个有着100多家企业的行业中，几乎没有传感器制造商进行触觉传感器的生产。日本阵列式传感器能在10厘米×10厘米大小的基质中分布100个敏感元件，售价10万元，而国内产品多为一点式，一般100元一个。</p>
<blockquote>
<p>来源：《传感器疏察，被愚钝的机器人“国产触觉”》</p>
</blockquote>
<h5 id="真空蒸镀机">真空蒸镀机</h5>
<p>OLED面板制程的“心脏”。日本Canon Tokki独占高端市场，掌握着该产业的咽喉。业界对它的年产量预测通常在几台到十几台之间。有钱也买不到，说的就是它。Canon Tokki能把有机发光材料蒸镀到基板上的误差控制在5微米内（1微米相当于头发直径的1％），没有其他公司的蒸镀机能达到这个精准度。目前我国还没有生产蒸镀机的企业，在这个领域我们没什么发言权。</p>
<blockquote>
<p>来源：《真空蒸镀机匮缺：高端显示屏上的阴影》</p>
</blockquote>
<h5 id="手机射频器件">手机射频器件</h5>
<p>一块手机的主板上，1/3的空间是射频电路。手机发展趋势是更轻薄，功耗更小，频段更多，带宽更大，这就向射频芯片提出了挑战。射频芯片将数字信号转化成电磁波，4G手机要支持十几个频段，信息带宽几十兆。2018年，射频芯片市场150亿美元；高端市场基本被Skyworks、Qorvo和 博通3家垄断，高通也占一席之地。射频器件的另一个关键元件——滤波器，国内外差距更大。手机使用的高端滤波器，几十亿美元的市场，完全归属Qorvo等国外射频器件巨头。中国是世界最大的手机生产国，但造不了高端的手机射频器件。这需要材料、工艺和设计经验的踏实积累。</p>
<blockquote>
<p>来源：《射频器件：仰给于人的手机尴尬》</p>
</blockquote>
<h5 id="iclip技术">iCLIP技术</h5>
<p>iCLIP是一种新兴的实验技术，是研发创新药的最关键的技术之一。它的发明，让人们抛弃精密的观测仪器，也能确定RNA（核糖核酸）和蛋白质在哪个位置“交汇”，甚至可以读出位点“密码”。iCLIP技术难，犹如万千人海中找一个人，要从几十亿个碱基对找到一个或几个确定的结合点，精确度可想而知。国外研究团队已在此领域展开“技术竞赛”，研究论文以几个月为周期轮番上演。国内实验室却极少有成熟经验。</p>
<blockquote>
<p>来源：《“靶点”难寻，国产创新药很迷惘》</p>
</blockquote>
<h5 id="重型燃气轮机">重型燃气轮机</h5>
<p>燃气轮机广泛应用于舰船、火车和大型电站。我国具备轻型燃机自主化能力；但重燃仍基本依赖引进。国际上大的重燃厂家，主要是美国GE、日本三菱、德国西门子、意大利安萨尔多4家。与中国合作都附带苛刻条件：设计技术不转让，核心的热端部件制造技术也不转让，仅以许可证方式许可本土制造非核心部件。没有自主化能力，意味着我国能源安全的重要一环，仍然受制于人，存在被“卡脖子”的风险。</p>
<blockquote>
<p>来源：《“命门火衰”，重型燃气轮机的叶片之殇》</p>
</blockquote>
<h5 id="激光雷达">激光雷达</h5>
<p>激光雷达是个传感器，自带光源，主动发出激光，感知周围环境，像蝙蝠通过超声波定位一样。它是自动驾驶汽车的必备组件，决定着自动驾驶行业的进化水平。但在该领域，国货几乎没有话语权。目前能上路的自动驾驶汽车中，凡涉及激光雷达者，使用的几乎都是美国Velodyne的产品，其激光雷达产品是行业标配，占八成以上市场份额。</p>
<blockquote>
<p>来源：《激光雷达昏聩，让自动驾驶很纠结》</p>
</blockquote>
<h4 id="适航标准">适航标准</h4>
<p>一款航空发动机要想获取一张放飞证，必须经过一套非常严格的“适航”标准体系验证，涵盖设计、制造、验证和管理。但目前在国际上，以FAA和欧洲航空安全局（EASA）的适航审定影响力最大，认可度最高。尽管在规章要求层面，中国与FAA基本一致，但由于国产航空发动机型号匮乏，缺乏实际工程实践经验，使我国适航规章缺少相应的技术支撑。实际型号的适航验证工作，成为被卡在别国空域之外的关隘。</p>
<blockquote>
<p>来源：《适航标准：国产航发又一道难迈的坎儿》</p>
</blockquote>
<h5 id="高端电容电阻">高端电容电阻</h5>
<p>电容和电阻是电子工业的黄金配角。中国是最大的基础电子元件市场，一年消耗的电阻和电容，数以万亿计。但最好的消费级电容和电阻，来自日本。电容市场一年200多亿美元，电阻也有百亿美元量级。所谓高端的电容电阻，最重要的是同一个批次应该尽量一致。日本这方面做得最好，国内企业差距大。国内企业的产品多属于中低端，在工艺、材料、质量管控上，相对薄弱。</p>
<blockquote>
<p>来源：《没有这些诀窍，我们够不着高端电容电阻》</p>
</blockquote>
<h4 id="核心工业软件">核心工业软件</h4>
<p>中国的核心工业软件领域，基本还是“无人区”。工业软件缺位，为智能制造带来了麻烦。工业系统复杂到一定程度，就需要以计算机辅助的工业软件来替代人脑计算。譬如，芯片设计生产“必备神器”EDA工业软件，国产EDA与美国主流EDA工具相较，设计原理上并无差异，但软件性能却存在不小差距，主要表现在对先进技术和工艺支持不足，和国外先进EDA工具之间存在“代差”。国外EDA三大巨头公司Cadence、Synopsys及Mentor，占据了全球该行业每年总收入的70%。发展自主工业操作系统+自主工业软件体系，刻不容缓。</p>
<blockquote>
<p>来源：《核心工业软件：智能制造的中国“无人区”》</p>
</blockquote>
<h5 id="ito靶材">ITO靶材</h5>
<p>ITO靶材不仅用于制作液晶显示器、平板显示器、等离子显示器、触摸屏、电子纸、有机发光二极管，还用于太阳能电池和抗静电镀膜、EMI屏蔽的透明传导镀膜等，在全球拥有广泛的市场。ITO膜的厚度因功能需求而有不同，一般在30纳米至200纳米。在尺寸的问题上，国内ITO靶材企业一直鲜有突破，而后端的平板显示制造企业也要仰人鼻息。烧结大尺寸ITO靶材，需要有大型的烧结炉。国外可以做宽1200毫米、长近3000毫米的单块靶材，国内只能制造不超过800毫米宽的。产出效率方面，日式装备月产量可达30吨至50吨，我们年产量只有30吨——而进口一台设备价格要花一千万元，这对国内小企业来说无异于天价。</p>
<p>每年我国ITO靶材消耗量超过1千吨，一半左右靠进口，用于生产高端产品。</p>
<blockquote>
<p>来源：《烧不出大号靶材，平板显示制造仰人鼻息》</p>
</blockquote>
<h4 id="核心算法">核心算法</h4>
<p>中国已经连续5年成为世界第一大机器人应用市场，但高端机器人仍然依赖于进口。由于没有掌握核心算法，国产工业机器人稳定性、故障率、易用性等关键指标远不如工业机器人“四大家族”发那科（日本）、ABB（瑞士）、安川（日本）、库卡（德国）的产品。核心算法差距过大，导致国产机器人稳定性不佳，故障率居高不下。算法的差距不只体现在核心控制器上，更拖慢了伺服系统响应的速度。</p>
<p>机器人每完成一个动作，需要核心控制器、伺服驱动器和伺服电机协同作战。对于单台伺服系统，国产机器人动态与静态精度都很高，但高端机器人一般同时有6台以上伺服系统，用传统的控制方法难以取得好的控制效果。</p>
<blockquote>
<p>来源：《算法不精，国产工业机器人有点“笨”》</p>
</blockquote>
<h5 id="航空钢材">航空钢材</h5>
<p>无论起飞还是降落，起落架都是支撑飞机的唯一部件，尤其是在飞机降落阶段，其承载的载荷不仅仅来自机身重量，还有飞机垂直方向的巨大冲力。因此，起落架的材料强度必须十分优异，只能依靠特种钢材才行。目前使用范围最广的是美国的300M钢，该材料采用真空热处理技术，避免了渗氢，零件表面光亮，无氧化脱碳、增碳和晶界氧化等缺陷，提高了表面质量。而国内用于制作起落架的国产超强度钢材有时会出现点状缺陷、硫化物夹杂、粗晶、内部裂纹、热处理渗氢等问题，这些问题都与冶炼过程中纯净度不够有关系。所以我国在高纯度熔炼技术方面与美国还有较大差距，存在很大提升空间。</p>
<blockquote>
<p>来源：《航空钢材不过硬，国产大飞机起落失据》</p>
</blockquote>
<h5 id="铣刀">铣刀</h5>
<p>随着我国近年来高铁的迅猛建设，钢轨养护问题也愈加让业内专家忧心。若养护不到位，不仅折损生命周期，还存在高风险隐患。我国自主创新研发的双动力电驱铣磨维护机器人装备——被称为钢轨‘急救车’的铣磨车可为钢轨“保驾护航”。但铣磨车最核心部件铣刀仍需从国外进口。铣刀的材料是一种超硬合金材料。对其中金属成分我们已然了解，但就是不知人家是怎么配比、合成的，如同琢磨某种中药的祖传秘方、各种药材比例是多少，都不甚明了。</p>
<blockquote>
<p>来源：《为高铁钢轨“整容”，国产铣刀难堪重任》</p>
</blockquote>
<h5 id="高端轴承钢">高端轴承钢</h5>
<p>作为机械设备中不可或缺的核心零部件，轴承支撑机械旋转体，降低其摩擦系数，并保证其回转精度。无论飞机、汽车、高铁，还是高精密机床、仪器仪表，都需要轴承。这就对其精度、性能、寿命和可靠性提出了高要求。而我国的制轴工艺已经接近世界顶尖水平，但材质——也就是高端轴承用钢几乎全部依赖进口。 高端轴承用钢的研发、制造与销售基本上被世界轴承巨头美国铁姆肯、瑞典SKF所垄断。前几年，他们分别在山东烟台、济南建立基地，采购中国的低端材质，运用他们的核心技术做成高端轴承，以十倍的价格卖给中国市场。炼钢过程中加入稀土，就能使原本优质的钢变得更加“坚强”。但怎么加，这是世界轴承巨头们的核心秘密。</p>
<blockquote>
<p>来源：《高端轴承钢，难以补齐的中国制造业短板》</p>
</blockquote>
<h5 id="高压柱塞泵">高压柱塞泵</h5>
<p>液压系统是装备制造业的关键部件之一，一切工程领域，凡是有机械设备的场合，都离不开液压系统。高压柱塞泵是高端液压装备的核心元件，被称作液压系统的“心脏”。中国液压工业的规模在2017年已经成为世界第二，但产业大而不强，尤其是额定压力35MPa以上高压柱塞泵，90%以上依赖进口。国内生产的液压柱塞泵与外国品牌相比，在技术先进性、工作可靠性、使用寿命、变量机构控制功能和动静态性能指标上都有较大差距，基本相当于国外上世纪90年代初水平。</p>
<blockquote>
<p>来源：《高压柱塞泵，鲠在中国装备制造业咽喉的一根刺》</p>
</blockquote>
<h5 id="航空设计软件">航空设计软件</h5>
<p>自上世纪80年代后，世界航空业就迈入数字化设计的新阶段，现在已经达到离开软件就无法设计的高度依赖程度。设计一架飞机至少需要十几种专业软件，全是欧美国家产品。国内设计单位不仅要投入巨资购买软件，而且头戴钢圈，一旦被念“紧箍咒”，整个航空产业将陷入瘫痪。据媒体报道，设计歼-10飞机时，主起落架主承力结构的整个金属部件是委托国外制造。但造完之后，起落架的收放出现问题，有5毫米的误差，只好重新订货制造。仅仅是这一点点的误差，影响了歼-10首飞推迟了八九个月。没有全数字化的软件支撑，任何一点细微的误差，都可能成为制造业的梦魇。</p>
<blockquote>
<p>来源：《航空软件困窘，国产飞机设计戴上“紧箍咒”》</p>
</blockquote>
<h5 id="光刻胶">光刻胶</h5>
<p>我国虽然已成为世界半导体生产大国，但面板产业整体产业链仍较为落后。目前，LCD用光刻胶几乎全部依赖进口，核心技术至今被TOK、JSR、住友化学、信越化学等日本企业所垄断。就拿在国际上具有一定竞争实力的京东方来说，目前已建立17个面板显示生产基地，其中有16个已经投产。但京东方用于高端面板的光刻胶，仍然由国外企业提供。光刻胶主要成分有高分子树脂、色浆、单体、感光引发剂、溶剂以及添加剂，开发所涉及的技术难题众多，需从低聚物结构设计和筛选、合成工艺的确定和优化、活性单体的筛选和控制、色浆细度控制和稳定、产品配方设计和优化、产品生产工艺优化和稳定、最终使用条件匹配和宽容度调整等方面进行调整。因此，要自主研发生产，技术难度非常之高。</p>
<p>来源：《中国半导体产业因光刻胶失色》</p>
<h5 id="高压共轨系统">高压共轨系统</h5>
<p>电控柴油高压共轨系统相当于柴油发动机的“心脏”和“大脑”，其品质的好坏，严重影响发动机的使用。柴油机产业是推动一个国家经济增长、社会运行的重要装备基础。中国是全球柴油发动机的主要市场和生产国家，而在国内的电控柴油机高压共轨系统市场，德国、美国和日本等企业占据了绝大份额。和国外先进公司的产品相比，国产高压共轨系统在性能、功能、质量及一致性上还存在一定的差距，成本上的优势也不明显。</p>
<blockquote>
<p>来源：《高压共轨不中用，国产柴油机很受伤》</p>
</blockquote>
<h5 id="透射式电镜">透射式电镜</h5>
<p>冷冻电镜可以拍摄微观结构高清3d“彩照”，是生命科学研究的利器，透射式电镜的生产能力是冷冻电镜制造能力的基础之一。目前世界上生产透射电镜的厂商只有3家，分别是日本电子、日立、FEI，国内没有一家企业生产透射式电镜。匹配冷冻电镜使用的工具都需要原装，零件坏了找不到人修理，只能等待零件邮寄到货后进行更换。对于中国的冷冻电镜使用者们来说，这样的体验可能还要持续不短的时间。</p>
<blockquote>
<p>来源：《我们的蛋白质3D高清照片仰赖舶来的透射式电镜》</p>
</blockquote>
<h5 id="掘进机主轴承">掘进机主轴承</h5>
<p>主轴承，有全断面隧道掘进机的“心脏”之称，承担着掘进机运转过程的主要载荷，是刀盘驱动系统的关键部件，工作所处状况十分恶劣。与直径仅有几百毫米的传统滚动轴承相比，掘进机主轴承直径一般为几米，是结构最复杂的一种轴承，制造需要上百道工序。就掘进机整机制造能力而言，国产掘进机已接近世界最先进水平，但最关键的主轴承全部依赖进口。德国的罗特艾德、IMO、FAG和瑞典的SKF占据市场。</p>
<blockquote>
<p>来源：《自家的掘进机却不得不用别人的主轴承》</p>
</blockquote>
<h5 id="微球">微球</h5>
<p>微球，直径是头发粗细的三十分之一。手机屏幕里，每平方毫米要用一百个微球，撑起了两块玻璃面板，相当于骨架，在两块玻璃面板的缝隙里，再灌进液晶。少了它，你正盯着的液晶屏幕将无法生产。没有微球，芯片生产、食品安全检测、疾病诊断、生物制药、环境监测……许多行业都会陷入窘境。仅微电子领域，中国每年就要进口价值几百亿元人民币的微球。2017年中国大陆的液晶面板出货量达到全球的33%，产业规模约千亿美元，位居全球第一。但这面板中的关键材料——间隔物微球，以及导电金球，全世界只有日本一两家公司可以提供。这些材料也像芯片一样，给人卡住了脖子。</p>
<blockquote>
<p>来源：《微球：民族工业不能承受之轻》</p>
</blockquote>
<h5 id="水下连接器">水下连接器</h5>
<p>除了船舶、遥感卫星，海底观测网已成为第三种海洋观测平台——通过它，人类可以深入到水下观测和认识海洋。如果将各类缆系观测平台比作胳膊、腿，水下连接器就好比关节，对海底观测网系统的建设、运行和维护有着不可替代的作用。目前我国水下连接器市场基本被外国垄断。一旦该连接器成为禁运品，整个海底观测网的建设和运行将被迫中断。</p>
<blockquote>
<p>来源：《水下连接缺国产利器，海底观测网傍人篱壁》</p>
</blockquote>
<h5 id="燃料电池关键材料">燃料电池关键材料</h5>
<p>国外的燃料电池车已实现量产，但我国车用燃料电池还处在技术验证阶段。我国车用燃料电池的现状是——几乎无部件生产商，无车用电堆生产公司，只有极少量商业运行燃料电池车。多项关键材料，决定着燃料电池的寿命和性能。这些材料我国并非完全没有，有些实验室成果甚至已达到国际水平。但是，没有批量生产线，燃料电池产业链依然梗阻。关键材料长期依赖国外，一旦遭遇禁售，我国的燃料电池产业便没有了基础支撑。</p>
<blockquote>
<p>来源：《少了三种关键材料，燃料电池商业化难成文章》</p>
</blockquote>
<h5 id="高端焊接电源">高端焊接电源</h5>
<p>我国是海洋大国，拥有300多万平方公里海域，正在大力发展高端海洋资源开发和海洋维权装备。海里的设备一旦出现开裂等故障，需要用有工业制造“缝纫机”之称的焊接装备修补。深海焊接的实现靠水下机器人。虽然我国是全球最大焊接电源制造基地，年产能已超1000万台套，但高端焊接电源基本上仍被国外垄断。我国水下机器人焊接技术一直难以提升，原因是高端焊接电源技术受制于人。国外焊接电源全数字化控制技术已相对成熟， 国内的仍以模拟控制技术为主。</p>
<blockquote>
<p>来源：《国产焊接电源“哑火”，机器人水下作业有心无力》</p>
</blockquote>
<h4 id="锂电池隔膜">锂电池隔膜</h4>
<p>作为新能源车的“心脏”，国产锂离子电池（以下简称锂电池）目前“跳”得还不够稳。电池四大核心材料中，正负极材料、电解液都已实现了国产化，唯独隔膜仍是短板。高端隔膜技术具有相当高的门槛，不仅要投入巨额的资金，还需要有强大的研发和生产团队、纯熟的工艺技术和高水平的生产线。高端隔膜目前依然大量依赖进口。</p>
<blockquote>
<p>来源：《一层隔膜两重天：国产锂电池尚需拨云见日》</p>
</blockquote>
<h5 id="医学影像设备元器件">医学影像设备元器件</h5>
<p>目前国产医学影像设备的大部分元器件依赖进口，至少要花10年、20年才能达到别人的现有水平。在传统医学成像（CT、磁共振等）上，中国最早的专利比美国平均晚20年。在专利数量上，美国是我国的10倍。这意味着整个产业已经完全掌握在国外企业的手里了，所有的知识产权，所有的原创成果，所有的科研积累都在国外，中国只占很少的一部分。</p>
<blockquote>
<p>来源：《拙钝的探测器模糊了医学影像》</p>
</blockquote>
<h5 id="超精密抛光工艺">超精密抛光工艺</h5>
<p>超精密抛光工艺在现代制造业中有多重要，其应用的领域能够直接说明问题：集成电路制造、医疗器械、汽车配件、数码配件、精密模具、航空航天。“它是技术灵魂”。美日牢牢把握了全球市场的主动权，其材料构成和制作工艺一直是个谜。换言之，购买和使用他们的产品，并不代表可以仿制甚至复制他们的产品。</p>
<blockquote>
<p>来源：《通往超精密抛光工艺之巅，路阻且长》</p>
</blockquote>
<h5 id="环氧树脂">环氧树脂</h5>
<p>碳纤维质量能比金属铝轻，但强度却高于钢铁，还具有耐高温、耐腐蚀、耐疲劳、抗蠕变等特性，其中一个关键的复合辅材就是环氧树脂。但目前国内生产的高端碳纤维，所使用的环氧树脂全部都是进口的。目前，我国已能生产T800等较高端的碳纤维，但日本东丽掌握这一技术的时间是上世纪90年代。相比于碳纤维，我国高端环氧树脂产业落后于国际的情况更为严重。</p>
<blockquote>
<p>来源：《环氧树脂韧性不足，国产碳纤维缺股劲儿》</p>
</blockquote>
<h5 id="高强度不锈钢">高强度不锈钢</h5>
<p>用于火箭发动机的钢材需具备多种特性，其中高强度是必须满足的重要指标。然而，不锈钢的强度和防锈性能，却是鱼和熊掌般难以兼得的矛盾体。火箭发动机材料如果如果严重生锈，将带来很大影响。完全依靠材料自身实现高强度和防锈性能兼备，这是世界性难题。现在，我国航天材料大多用的是国外上世纪六七十年代用的材料，发达国家在生产过程中会严格控制杂质含量，如果纯度不达标，便重新回炉，但国内厂家往往缺乏这种严谨的态度。</p>
<blockquote>
<p>来源：《去不掉的火箭发动机“锈疾”》</p>
</blockquote>
<h5 id="数据库管理系统">数据库管理系统</h5>
<p>目前全世界最流行的两种数据库管理系统是Oracle和MySQL，都是甲骨文公司旗下的产品。竞争者还有IBM公司以及微软公司的产品等。甲骨文、IBM、微软和Teradata几家美国公司，占了大部分市场份额。数据库管理系统国货也有市场份额，但只是个零头，其稳定性、性能都无法让市场信服，银行、电信、电力等要求极端稳妥的企业，不会考虑国货。</p>
<blockquote>
<p>来源：《数据库管理系统：中国还在寻找“正确打开方式”》</p>
</blockquote>
<h5 id="扫描电镜">扫描电镜</h5>
<p>扫描电子显微镜，一种高端的电子光学仪器，它被广泛地应用于材料、生物、医学、冶金、化学和半导体等各个研究领域和工业部门，被称为“微观相机”目前我国科研与工业部门所用的扫描电镜严重依赖进口，每年我国花费超过1亿美元采购的几百台扫描电镜中，主要产自美、日、德和捷克等国。国产扫描电镜只占约5%—10%。</p>
<blockquote>
<p>来源：《扫描电镜“弱视”，工业制造难以明察秋毫》</p>
</blockquote>
<p><strong>也许习大大看完我的第二个五年计划也会潸然泪下.</strong></p>
<p>我觉得相比许家印富豪造车，不如他投资一下我开个大学干我这个想法，比他造车更有意义，这关乎于国家前途的命运。然而我还是个不能解决温饱的工人阶级谈这个有点纸上谈兵人微言轻。</p>
<p>其实我清楚的知道第3个计划有点扯淡,但我不能没有梦想.万一实现了呢.</p>
<p>我认为我们总听到身边人说中国这不如外国那不如外国,但具体哪里不如外国我们一时半会还说不清楚.看了这34+项卡脖子技术就知道了我们国家的短板在哪,我们这一代人所需要努力的地方在哪里.我们最大的悲剧是不知自己和其它强国的具体差距到底在哪里,我相信看完<a href="https://mp.weixin.qq.com/s/ms2TbtZyEHYqoQGHQrJY5A" target="_blank" rel="noopener">这篇文章</a>你将有所收获.</p>
<h3 id="总结">总结</h3>
<p>每当写年终总结的时候别人都会给予我羡慕的目光,我想说我只是挣扎在温饱线上勉强度日.在没有<code>对价</code>的条件下只能直面惨淡的人生.2020年得继续奋斗.不但要为了国家和人民对美好生活的向往,还要为了自己诗和远方.</p>
<p>年华尚在,岁月尚好.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191231FinalSummary/AlanTuring.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2019年 &lt;a href=
    
    </summary>
    
      <category term="记录世界记录你" scheme="https://www.sunyazhou.com/categories/%E8%AE%B0%E5%BD%95%E4%B8%96%E7%95%8C%E8%AE%B0%E5%BD%95%E4%BD%A0/"/>
    
    
      <category term="生活" scheme="https://www.sunyazhou.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="年终总结" scheme="https://www.sunyazhou.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>简单了解LLDB调试工具chisel</title>
    <link href="https://www.sunyazhou.com/2019/12/06/20191206Chisel/"/>
    <id>https://www.sunyazhou.com/2019/12/06/20191206Chisel/</id>
    <published>2019-12-06T03:09:25.000Z</published>
    <updated>2020-09-15T02:06:46.763Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191206Chisel/lldb1.png"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<p>最近比较懒 Xcdeo每次启动的时候都会报一个找不到某某python文件的log在lldb中,为了一探究竟,花了点时间简单修复了</p>
<h1 id="chisel是啥">chisel是啥？</h1>
<p>这个问题我要是回答完都会被iOS开发者笑话死,这个工具facebook都开源很久了,只是自己以前研究过,换个电脑懒得布置环境.一直没当回事,这几天开发遇到了控制台问题顺手看到了,想来整理一下.</p>
<p>首先这个工具的的地址在<a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">https://github.com/facebook/chisel</a></p>
<p>这里面提供的安装方法如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install chisel</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 brew 安装完就行了</p>
</blockquote>
<p>然后它会告诉你看下用户home目录有个隐藏文件 <code>.lldbinit</code>如果没有就创建一下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">touch .lldbinit </span><br><span class="line">open .lldbinit</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191206Chisel/lldbinit.png"></p>
<p>创建完 把脚本命令搞进去 这里我就不说官方的写法了 跟屎一样一点不好使</p>
<p>我贴一下我的添加方法.</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191206Chisel/lldb2.png"></p>
<p>这是我用本地电脑安装完成之后的路径图</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">### Chisel LLDB add by sunyazhou</span></span><br><span class="line"><span class="built_in">command</span> script import /usr/<span class="built_in">local</span>/Cellar/chisel/1.8.1/libexec/fblldb.py</span><br></pre></td></tr></table></figure>
<p>本地的 .lldbinit 文件中加入上代码 记得必须对应上路径.然后重启Xcode运行即可在控制台使用无问题</p>
<p>由于这个文件会被Reveal改动 所以经常会有各种lldb工具修改这个文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">### Chisel LLDB add by sunyazhou</span></span><br><span class="line"><span class="built_in">command</span> script import /usr/<span class="built_in">local</span>/Cellar/chisel/1.8.1/libexec/fblldb.py</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### LLDB https://github.com/DerekSelander/LLDB</span></span><br><span class="line"><span class="built_in">command</span> script import /Users/sunyazhou/LLDB-master/lldb_commands/dslldb.py</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Reveal LLDB commands support - DO NOT MODIFY</span></span><br><span class="line"><span class="built_in">command</span> script import /Users/sunyazhou/Library/Application\ Support/Reveal/RevealServerCommands.py</span><br><span class="line"><span class="comment">###</span></span><br></pre></td></tr></table></figure>
<h2 id="chisel用法">chisel用法</h2>
<ul>
<li><code>pvc</code>：查看当前控制器状态<br>
</li>
<li><code>pviews</code>：查看UIWindow及其子视图层级关系<br>
</li>
<li><code>presponder</code>：打印一个对象的响应链关系<br>
</li>
<li><code>pclass</code>:根据内存地址打印相关信息<br>
</li>
<li><code>visualize</code>：使用mac系统preview程序查看UIImage、CGImage、UIView、CALayer、NSData(of an UIImage)、UIColor、CIColor。<br>
</li>
<li><code>show</code>/<code>hide</code>：显示or隐藏一个UIView<br>
</li>
<li><code>mask</code>/<code>umask</code>：给一个UIView或CALayer添加一个半透明蒙版<br>
</li>
<li><code>border</code>/<code>unborder</code>：给指定的UIView或CALayer添加边框或移除边框用于调试，记得执行后紧接着执行caflush<br>
</li>
<li><code>caflush</code>：刷新界面UI，类似于前面介绍的flush<br>
</li>
<li><code>bmessage</code>：添加一个断点，即使这个函数在子类没有实现（比如说在UIViewController中想在viewWillAppear中打断点，但是很可能没有实现父类方法，就可以通过bmessage [UIViewController viewWillAppear:]添加）<br>
</li>
<li><code>wivar</code>：相当于kvo，监听一个变量，例如wivar self _subviews<br>
</li>
<li><code>taplog</code>：开启点击log功能，当点击某个控件时会打印相关控件的信息<br>
</li>
<li><code>paltrace</code>： 打印指定view的自动布局信息,比如:paltrace self.view<br>
</li>
<li><code>ptv</code>：打印当前界面中的UITableView，相对应的还有pcells打印当前界面中的UITableViewCell</li>
<li><code>pdata</code>：Data的string解码</li>
<li><code>vs</code>：搜索指定的view并加上半透明蒙版（包含子命令），例如：vs 0x13a9efe00 就可以标注出对应的控件</li>
<li><code>slowanim</code>/<code>unslowanim</code>：降低(或取消)动画速度,默认0.1 ，可以在任意断点或Xcode暂定执行slowanim即可，方便动画调试</li>
</ul>
<p>演示效果</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191206Chisel/lldb3_chisel.png"></p>
<h2 id="其它调试lldb有哪些">其它调试lldb有哪些？</h2>
<p><a href="https://github.com/DerekSelander/LLDB" target="_blank" rel="noopener">lldb_commands</a> 是另一个第三方的lldb扩展库，其中提供了很多实用的文件操作</p>
<p><code>ls</code>：显示指定路径的目录或文件列表 <code>pexecutable</code>：打印当前可执行文件所在位置 <code>dumpenv</code>：查看环境信息，比如说沙盒地址 <code>yoink</code>：拷贝指定目录的文件到mac的临时目录 <code>keychain</code>：查看keychain信息</p>
<h1 id="总结">总结</h1>
<p>工欲善其事 必先利其器,作为一个iOS开发如果想做到极致就需要我们好的工具都需要试试,这样能不断提高生产效率</p>
<p><a href="https://www.cnblogs.com/kenshincui/p/11953536.html" target="_blank" rel="noopener">参考 iOS开发调试概览</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191206Chisel/lldb1.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本文具有强
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>图形示意绘制工具</title>
    <link href="https://www.sunyazhou.com/2019/12/04/20191204MathGraphicTool/"/>
    <id>https://www.sunyazhou.com/2019/12/04/20191204MathGraphicTool/</id>
    <published>2019-12-04T10:12:58.000Z</published>
    <updated>2020-09-15T02:12:46.083Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191204MathGraphicTool/MathGraphic.png"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<p>以前经常写一些动画需要描述示意图形的运动图.这样能生动形象的表述我所讲述的内容到底是什么样的</p>
<p>最近发现了一个网站,专门做数学图形绘制</p>
<h1 id="httpswww.geogebra.org"><a href="https://www.geogebra.org/" target="_blank" rel="noopener">https://www.geogebra.org/</a></h1>
<p>这里数学上用的东西都是可以直接拿来使用的,比如画个坐标系 表述一下 动画运动轨迹等</p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191204MathGraphicTool/MathGraphicOverView.gif"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20191204MathGraphicTool/MathGraphic.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;前
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用Masonry约束实现简单的高级拖拽视图</title>
    <link href="https://www.sunyazhou.com/2019/09/26/20190926MasonryPanViewDemo/"/>
    <id>https://www.sunyazhou.com/2019/09/26/20190926MasonryPanViewDemo/</id>
    <published>2019-09-26T12:05:20.000Z</published>
    <updated>2020-09-15T02:16:11.098Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20190926MasonryPanViewDemo/panviewdemo.gif"></p>
<h1 id="前言">前言</h1>
<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="背景">背景</h2>
<p>最近开发遇到一个上图的需求,做一个挂件能四处拖动并且上边还时不时的展示一个tips气泡的<code>Label</code>,在尽量使用少的代码来实现这个功能,作为我手一名iOS开发人员必须严格考究这个需求,显然这有点麻烦,一贯懒惰我的实在不想计算哪个边哪个角甚至滑动到哪里的<code>frame</code>,计算frame这既听起来可笑又觉的没什么技术含量. 为了让代码量少并且能满足需求,我选择使用Masonry来实现这个功能</p>
<h2 id="开搞">开搞</h2>
<p>首先我搞起之前我建议大家看下<a href="http://tutuge.me/" target="_blank" rel="noopener">土土哥</a>的<a href="http://tutuge.me/tags/Masonry/" target="_blank" rel="noopener">有趣的Autolayout示例1~5Masonry实现文章</a>,本文也是参考土土哥的文章学习写出的,见笑了各位,个人认为土土哥的文章简直就是Masonry自动布局的样板教程,强烈建议入门的小伙伴或者高手经常复写.</p>
<p>下面的图是土土哥实现的demo<br>
<img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20190926MasonryPanViewDemo/tutugeMasonry1.gif"></p>
<p><img src="https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20190926MasonryPanViewDemo/tutugeMasonry2.gif"></p>
<p>但我的问题是怎么保证那个tip的气泡label左右拖拽能辗转腾挪的允许logo图像之间有<code>旷量移动</code></p>
<h2 id="代码实现旷量移动">代码实现旷量移动</h2>
<p>首先我们创建一个demo,很简单VC的demo就行 创建相关绿色背景视图和图像imageView以及tipLabel的气泡视图,具体代码我贴了出来,我就不啰嗦如何创建其它视图了xib拖拽一下就行了.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Masonry/Masonry.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>  ) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span>        *greenView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>  ) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span>   *widgetView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>  ) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span>       *bubbleTitleLabel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) MASConstraint *leftConstraint; <span class="comment">//左侧约束变量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) MASConstraint *topConstraint;  <span class="comment">//顶部约束变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到有两个<code>leftConstraint</code>和<code>topConstraint</code>的约束全局变量,这两个就是实现拖拽的时候改变约束的偏移量来实现的.具体代码如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> screenWidth = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width;</span><br><span class="line"><span class="built_in">CGFloat</span> screenHeight = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.height;</span><br><span class="line">[<span class="keyword">self</span>.widgetView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    <span class="comment">// 设置边界条件约束，保证内容可见，优先级1000</span></span><br><span class="line">    make.left.greaterThanOrEqualTo(<span class="keyword">self</span>.greenView.mas_left);</span><br><span class="line">    make.right.lessThanOrEqualTo(<span class="keyword">self</span>.greenView.mas_right);</span><br><span class="line">    make.top.greaterThanOrEqualTo(<span class="keyword">self</span>.greenView.mas_top);</span><br><span class="line">    make.bottom.lessThanOrEqualTo(<span class="keyword">self</span>.greenView.mas_bottom);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.leftConstraint = make.centerX.equalTo(<span class="keyword">self</span>.greenView.mas_left).with.offset(screenWidth - <span class="number">20</span>).priorityHigh(); <span class="comment">// 优先级要比边界条件低</span></span><br><span class="line">    <span class="keyword">self</span>.topConstraint = make.centerY.equalTo(<span class="keyword">self</span>.greenView.mas_top).with.offset(screenHeight - <span class="number">100</span>).priorityHigh(); <span class="comment">// 优先级要比边界条件低</span></span><br><span class="line">    make.width.height.mas_equalTo(@<span class="number">100</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>上边的<code>greaterThanOrEqualTo</code>和<code>lessThanOrEqualTo</code>都是限制挂件的可滑动范围,而最后的<code>make.centerX/Y.equalTo</code>是限制挂件的默认位置,我让它默认在右下角,所以通过偏移量移动过去</p>
<blockquote>
<p>注意:这里有个坑就是因为这个东西能四处滑动 所以基本需要锁定<code>left</code>和<code>top</code>,我发现只有通过offset移动才能确定最初位置,如果equalTo直接写成xxxview的bottom或者right是滑动不了的,仔细思考一下masonry就知道为啥了.</p>
</blockquote>
<p>然后添加手势并实现相关滑动事件即可实现滑动</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(panWithGesture:)];</span><br><span class="line">[<span class="keyword">self</span>.greenView addGestureRecognizer:pan];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)panWithGesture:(<span class="built_in">UIPanGestureRecognizer</span> *)pan &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> touchPoint = [pan locationInView:<span class="keyword">self</span>.greenView];</span><br><span class="line">    <span class="keyword">self</span>.leftConstraint.offset = touchPoint.x;</span><br><span class="line">    <span class="keyword">self</span>.topConstraint.offset = touchPoint.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="旷量label的约束">旷量Label的约束</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.bubbleTitleLabel mas_remakeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">	make.height.equalTo(@<span class="number">26</span>);</span><br><span class="line">	make.bottom.equalTo(<span class="keyword">self</span>.widgetView.mas_top);</span><br><span class="line">	make.left.greaterThanOrEqualTo(<span class="keyword">self</span>.greenView.mas_left).offset(<span class="number">0</span>);</span><br><span class="line">	make.right.lessThanOrEqualTo(<span class="keyword">self</span>.greenView.mas_right).offset(<span class="number">0</span>);</span><br><span class="line">	make.centerX.lessThanOrEqualTo(<span class="keyword">self</span>.widgetView.mas_right).offset(<span class="number">10</span>);</span><br><span class="line">	make.centerX.greaterThanOrEqualTo(<span class="keyword">self</span>.widgetView.mas_left).offset(<span class="number">-10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>想要实现旷量移动必须增加更多的约束限制</p>
<p>这里就增加了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">make.centerX.lessThanOrEqualTo(<span class="keyword">self</span>.widgetView.mas_right).offset(<span class="number">10</span>);</span><br><span class="line">make.centerX.greaterThanOrEqualTo(<span class="keyword">self</span>.widgetView.mas_left).offset(<span class="number">-10</span>);</span><br></pre></td></tr></table></figure>
<p>这样就实现了 左右超过滑动便宜还依然控制着tip的label左右移动范围.</p>
<h1 id="总结">总结</h1>
<p>经过工作中遇到的问题实例,学习了一些Masonry的技巧,希望和大家分享,demo我已放到下面 喜欢自行下载学习.</p>
<p><a href="https://github.com/sunyazhou13/PanViewDemo" target="_blank" rel="noopener">demo下载</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/sunyazhou/sunyazhou13.github.io-images/raw/master/20190926MasonryPanViewDemo/panviewdemo.gif&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
