<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>東引甌越</title>
  <subtitle>不断学习, 与时俱进.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sunyazhou.com/"/>
  <updated>2018-06-01T12:02:57.245Z</updated>
  <id>https://www.sunyazhou.com/</id>
  
  <author>
    <name>sunyazhou</name>
    <email>sunyazhou13@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift中的随机数</title>
    <link href="https://www.sunyazhou.com/2018/06/01/20180601Random/"/>
    <id>https://www.sunyazhou.com/2018/06/01/20180601Random/</id>
    <published>2018-06-01T09:30:56.000Z</published>
    <updated>2018-06-01T12:02:57.245Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/d91bef0915eb510aeb874e05ccf21df897d2d03d/20180601Random/powered-by-Swift-random-numbers.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天儿童节,写一篇<code>随机数</code>技术文章纪念<code>留守儿童(资深)</code>的童年.</p>
<h2 id="swift中的随机数使用"><a href="#swift中的随机数使用" class="headerlink" title="swift中的随机数使用"></a>swift中的随机数使用</h2><p>在我们开发的过程中，经常用到求取一些随机数,今天列举几种写篇文章</p>
<h2 id="整型随机数"><a href="#整型随机数" class="headerlink" title="整型随机数"></a>整型随机数</h2><p>首先是这个arc4random()</p>
<blockquote>
<p><code>arc4random()</code>使用了<code>arc4</code>密码加密的<code>key</code> <code>stream</code>生成器，产生一个<code>[0, 2^32)</code>区间的随机数(注意是左闭右开区间)。这个函数的返回类型是<code>UInt32</code></p>
<p>提示: <em><code>[</code>和<code>]</code> 分别代表左右闭区间</em>,<br><em><code>(</code>和<code>)</code>代表左右开区间</em><br>也就是<code>中括号</code> -&gt; 代表 闭区间, 闭区间代表包含.<br>小括号 -&gt; 代表开区间, 开区间代表不包含.<br>所以以下看到</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">arc4random()   <span class="comment">//"4058056034"</span></div></pre></td></tr></table></figure>
<p>如果我们想生成一个<strong>指定范围内</strong>的整型随机数，则可以使用<code>arc4random()</code> <code>%</code> <code>upper_bound</code>的方式，其中<code>upper_bound</code>指定的是上边界，如下代码:</p>
<p>求一个10以内的随机数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">arc4random() % <span class="number">10</span>  <span class="comment">// 0~9 注意没有10哈</span></div></pre></td></tr></table></figure>
<p>不过使用这种方法，在<code>upper_bound</code>不是<code>2</code>的幂次方时，会产生一个所谓<code>Modulo bias</code>(模偏差)的问题。</p>
<p>可以使用<code>arc4random_uniform()</code>，它接受一个<code>UInt32</code>类型的参数，<strong>指定随机数区间的上边界</strong><code>upper_bound</code>，该函数生成的随机数范围是[0, upper_bound)，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">arc4random_uniform(<span class="number">10</span>)		<span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>那问题来了？我想指定区间随机 比如: <code>[10, 200)</code>.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> maxNum: <span class="type">UInt32</span> = <span class="number">200</span></div><div class="line"><span class="keyword">let</span> minNum: <span class="type">UInt32</span> = <span class="number">10</span></div><div class="line">arc4random_uniform(maxNum - minNum) + minNum   <span class="comment">// 153</span></div></pre></td></tr></table></figure>
<p>可以看到上述结果 是 <code>153</code>.</p>
<p>swift也可以用C函数中的随机 eg: random() 或者 rand(),但是这些有下面缺点:</p>
<ul>
<li>这两个函数都需要初始种子，通常是以当前时间来确定,属于伪随机.</li>
<li>这两个函数的上限在<code>RAND_MAX=0X7fffffff</code>(2147483647)，是<code>arc4random</code>的一半.</li>
<li><code>rand()</code>函数以有规律的低位循环方式实现，更容易预测</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">srand(UInt32(time(nil)))  <span class="comment">// 种子,random对应的是srandom</span></div><div class="line">rand()				      <span class="comment">// 1,314,695,483</span></div><div class="line">rand() % <span class="number">10</span>	   			  <span class="comment">// 8</span></div></pre></td></tr></table></figure>
<h2 id="64位整型随机数"><a href="#64位整型随机数" class="headerlink" title="64位整型随机数"></a>64位整型随机数</h2><p>我们发现这些函数主要都是针对<code>32</code>位整型数来操作的.如果需要生成一个<code>64</code>位的整型随机数呢?</p>
<p>可以使用如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">arc4random</span> &lt;T: ExpressibleByIntegerLiteral&gt; <span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span> &#123;</div><div class="line">    <span class="keyword">var</span> r: <span class="type">T</span> = <span class="number">0</span></div><div class="line">    arc4random_buf(&amp;r, <span class="type">MemoryLayout</span>&lt;<span class="type">T</span>&gt;.size)</div><div class="line">    <span class="keyword">return</span> r</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以像下面这样调用 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">arc4random(type: <span class="type">UInt64</span>.<span class="keyword">self</span>) <span class="comment">//8021765689869396105</span></div><div class="line">arc4random(type: <span class="type">UInt32</span>.<span class="keyword">self</span>) <span class="comment">//1293034028</span></div><div class="line">arc4random(type: <span class="type">UInt16</span>.<span class="keyword">self</span>) <span class="comment">//29059</span></div><div class="line">arc4random(type: <span class="type">UInt8</span>.<span class="keyword">self</span>)  <span class="comment">//183</span></div></pre></td></tr></table></figure>
<blockquote>
<p>swift 4 语法</p>
</blockquote>
<p>这个函数中使用了<code>arc4random_buf()</code>来生成随机数。</p>
<p>这个函数使用ARC4加密的随机数来填充该函数第二个参数指定的长度的缓存区域。因此，如果我们传入的是sizeof(UInt64)，该函数便会生成一个随机数来填充8个字节的区域，并返回给r。那么64位的随机数生成方法便可以如下实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt64</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: UInt64 = <span class="built_in">min</span>, upper: UInt64 = <span class="built_in">max</span>)</span></span> -&gt; <span class="type">UInt64</span> &#123;</div><div class="line">        <span class="keyword">var</span> m: <span class="type">UInt64</span></div><div class="line">        <span class="keyword">let</span> u = upper - lower</div><div class="line">        <span class="keyword">var</span> r = arc4random(type: <span class="type">UInt64</span>.<span class="keyword">self</span>)</div><div class="line">        <span class="keyword">if</span> u &gt; <span class="type">UInt64</span>(<span class="type">Int64</span>.<span class="built_in">max</span>) &#123;</div><div class="line">            m = <span class="number">1</span> + ~u</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            m = ((<span class="built_in">max</span> - (u * <span class="number">2</span>)) + <span class="number">1</span>) % u</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> r &lt; m &#123;</div><div class="line">            r = arc4random(type: <span class="type">UInt64</span>.<span class="keyword">self</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (r % u) + lower</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来试用一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">UInt64</span>.random()      <span class="comment">//9223372036854775807</span></div></pre></td></tr></table></figure>
<h2 id="浮点型随机数"><a href="#浮点型随机数" class="headerlink" title="浮点型随机数"></a>浮点型随机数</h2><p>如果需要一个浮点值的随机数，则可以使用drand48函数，这个函数产生一个[0.0, 1.0]区间中的浮点数。这个函数的返回值是Double类型。其使用如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">srand48(<span class="type">Int</span>(time(<span class="literal">nil</span>)))</div><div class="line">drand48()  <span class="comment">//0.4643666202473504</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意:需要先调用srand48()生成种子</p>
</blockquote>
<h2 id="示例实践"><a href="#示例实践" class="headerlink" title="示例实践"></a>示例实践</h2><p>如何生成一个0~9 这几个数组做个随机排序,实现类似银行类动态键盘的功能</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>]</div><div class="line">arr.<span class="built_in">sort</span> &#123; (s1, s2) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">    arc4random() &lt; arc4random()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(arr)</div></pre></td></tr></table></figure>
<p>在闭包中，随机生成两个数，比较它们之间的大小，来确定数组的排序.注意不需要重新赋值了在swift4上.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>随机数相关的知识容易忘记,特此记录一些技巧,争取每个月发布两篇文章.</p>
<p><a href="http://southpeak.github.io/2015/09/26/ios-techset-5/" target="_blank" rel="external">参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/d91bef0915eb510aeb874e05ccf21df897d2d03d/20180601Ran
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UIView不同方向的导角</title>
    <link href="https://www.sunyazhou.com/2018/05/15/20180515How-to-Create-Top-or-Bottom-Rounded-Corners-for-Views/"/>
    <id>https://www.sunyazhou.com/2018/05/15/20180515How-to-Create-Top-or-Bottom-Rounded-Corners-for-Views/</id>
    <published>2018-05-15T01:58:00.000Z</published>
    <updated>2018-05-15T02:55:50.911Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/1f076ce5865fc9f8d5acf7f1d808c6da04972014/20180515How-to-Create-Top-or-Bottom-Rounded-Corners-for-Views/WX20180515-104917%402x.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开发中总因为一些比较蛋疼的导角问题而困扰着我们,尤其是我们要给一个UIView导角成 左上 、左下。。。</p>
<p>这种需求很值得用代码实现一下, 今天突然在<a href="https://www.appcoda.com/rounded-corners-uiview/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+appcoda+%28AppCoda%3A+Your+iOS+Programming+Community%29" target="_blank" rel="external">AppCode</a>找到了一篇好文章.于是有了下文</p>
<h2 id="通常导角"><a href="#通常导角" class="headerlink" title="通常导角"></a>通常导角</h2><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">self</span>.view.cornerRadius = <span class="number">20.0</span></div><div class="line"><span class="keyword">self</span>.view.clipToBounds = <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>这两行代码是全方向导角</p>
<p>如果像要搞成不同方向的话可以用iOS11 新的API和 iOS11以前的<code>CAShapeLayer</code>画贝赛尔曲线来解决</p>
<p>首先我们要创建一个UIView</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> cardView: <span class="type">UIView</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        cardView = <span class="type">UIView</span>()</div><div class="line">        view.addSubview(cardView)</div><div class="line">        cardView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></div><div class="line">        <span class="comment">//把View居中</span></div><div class="line">        cardView.widthAnchor.constraint(equalToConstant: <span class="number">200</span>).isActive = <span class="literal">true</span></div><div class="line">        cardView.heightAnchor.constraint(equalToConstant: <span class="number">200</span>).isActive = <span class="literal">true</span></div><div class="line">        cardView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></div><div class="line">        cardView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = <span class="literal">true</span></div><div class="line">        cardView.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">1.0</span>, green: <span class="number">0.784</span>, blue: <span class="number">0.2</span>, alpha: <span class="number">1</span>)      </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>iOS11 以后苹果提供了一个<code>UIView</code>的属性叫<code>maskedCorners</code>用于CALayer的动画相关.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CACornerMask</span> : <span class="title">OptionSet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> layerMinXMinYCorner: <span class="type">CACornerMask</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> layerMaxXMinYCorner: <span class="type">CACornerMask</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> layerMinXMaxYCorner: <span class="type">CACornerMask</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> layerMaxXMaxYCorner: <span class="type">CACornerMask</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我说一下</p>
<ul>
<li>layerMinXMinYCorner 底部右侧 的圆角 -&gt; 右下角</li>
<li>layerMaxXMinYCorner 顶部右侧 的圆角 -&gt; 右上角</li>
<li>layerMinXMaxYCorner 底部左侧 的圆角 -&gt; 左下角</li>
<li>layerMinXMinYCorner 顶部左侧 的圆角 -&gt; 左上角</li>
</ul>
<p>一般我们都为UIView写个 extension</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">roundCorners</span><span class="params">(cornerRadius: Double)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.layer.cornerRadius = <span class="type">CGFloat</span>(cornerRadius)</div><div class="line">        <span class="keyword">self</span>.clipsToBounds = <span class="literal">true</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</div><div class="line">            <span class="keyword">self</span>.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>(roundedRect: <span class="keyword">self</span>.bounds, byRoundingCorners: [.topLeft, .topRight], cornerRadii: <span class="type">CGSize</span>(width: cornerRadius, height: cornerRadius))</div><div class="line">            <span class="keyword">let</span> maskLayer = <span class="type">CAShapeLayer</span>()</div><div class="line">            maskLayer.frame = <span class="keyword">self</span>.bounds</div><div class="line">            maskLayer.path = path.cgPath</div><div class="line">            <span class="keyword">self</span>.layer.mask = maskLayer</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里区分了iOS11之前和之后的两种搞法.</p>
<p>之前的话我们都是用一个贝塞尔曲线画path.然后创建CAShapeLayer 给self.layer.mask做一种透明的遮罩来解决不同方向导角问题.</p>
<h2 id="添加动画效果的导角"><a href="#添加动画效果的导角" class="headerlink" title="添加动画效果的导角"></a>添加动画效果的导角</h2><p>我们在原ViewDidLoad()方法里面加个手势.</p>
<p>并写好触发的事件, 完整的代码如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> cardView: <span class="type">UIView</span>!</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        </div><div class="line">        cardView = <span class="type">UIView</span>()</div><div class="line">        view.addSubview(cardView)</div><div class="line">        cardView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></div><div class="line">        cardView.widthAnchor.constraint(equalToConstant: <span class="number">200</span>).isActive = <span class="literal">true</span></div><div class="line">        cardView.heightAnchor.constraint(equalToConstant: <span class="number">200</span>).isActive = <span class="literal">true</span></div><div class="line">        cardView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = <span class="literal">true</span></div><div class="line">        cardView.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = <span class="literal">true</span></div><div class="line">        cardView.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">1.0</span>, green: <span class="number">0.784</span>, blue: <span class="number">0.2</span>, alpha: <span class="number">1</span>)</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">let</span> tapRecognizer = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(animateCornerChange(recognizer:)))</div><div class="line">        cardView.addGestureRecognizer(tapRecognizer)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">animateCornerChange</span><span class="params">(recognizer: UITapGestureRecognizer)</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> targetRadius: <span class="type">Double</span> = (cardView.layer.cornerRadius == <span class="number">0.0</span>) ? <span class="number">100.0</span>:<span class="number">0.0</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> #available(iOS <span class="number">10.0</span>, *) &#123;</div><div class="line">            <span class="type">UIViewPropertyAnimator</span>(duration: <span class="number">0.4</span>, curve: .easeInOut) &#123;</div><div class="line">                <span class="keyword">self</span>.cardView.roundCorners(cornerRadius: targetRadius)</div><div class="line">                &#125;.startAnimation()</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="type">UIView</span>.animate(withDuration: <span class="number">1.0</span>, delay: <span class="number">0.0</span>, options: .curveEaseInOut, animations: &#123;</div><div class="line">                </div><div class="line">            &#125;, completion: <span class="literal">nil</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">roundCorners</span><span class="params">(cornerRadius: Double)</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.layer.cornerRadius = <span class="type">CGFloat</span>(cornerRadius)</div><div class="line">        <span class="keyword">self</span>.clipsToBounds = <span class="literal">true</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</div><div class="line">            <span class="keyword">self</span>.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>(roundedRect: <span class="keyword">self</span>.bounds, byRoundingCorners: [.topLeft, .topRight], cornerRadii: <span class="type">CGSize</span>(width: cornerRadius, height: cornerRadius))</div><div class="line">            <span class="keyword">let</span> maskLayer = <span class="type">CAShapeLayer</span>()</div><div class="line">            maskLayer.frame = <span class="keyword">self</span>.bounds</div><div class="line">            maskLayer.path = path.cgPath</div><div class="line">            <span class="keyword">self</span>.layer.mask = maskLayer</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="这里主要强调一下动画的新API"><a href="#这里主要强调一下动画的新API" class="headerlink" title="这里主要强调一下动画的新API"></a>这里主要强调一下动画的新API</h3><p>iOS10之后U增加一个新的动画效果API</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">UIViewPropertyAnimator</span>(duration: <span class="number">0.4</span>, curve: .easeInOut) &#123;</div><div class="line"><span class="comment">//这里写相关View的操作代码 。。。eg:下面代码</span></div><div class="line">                <span class="keyword">self</span>.cardView.roundCorners(cornerRadius: targetRadius)</div><div class="line">                &#125;.startAnimation()</div></pre></td></tr></table></figure>
<p>iOS之前可以通过古老的API来实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="type">UIView</span>.animate(withDuration: <span class="number">1.0</span>, delay: <span class="number">0.0</span>, options: .curveEaseInOut, animations: &#123;</div><div class="line"><span class="comment">//这里写相关View的操作代码 。。。eg:下面代码</span></div><div class="line">                <span class="keyword">self</span>.cardView.roundCorners(cornerRadius: targetRadius)</div><div class="line">            &#125;, completion: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>最终的效果</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/b501b8cabbeaff551be152f8d812148eda1a5319/20180515How-to-Create-Top-or-Bottom-Rounded-Corners-for-Views/TopBottomCornerDemo.gif" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>iOS一些简单的动画导角比较常用所以记录下来,希望大家多多指教</p>
<p><a href="https://github.com/sunyazhou13/TopBottomCornerDemo" target="_blank" rel="external">本文Demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/1f076ce5865fc9f8d5acf7f1d808c6da04972014/20180515How
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>手动管理UIViewController的生命周期</title>
    <link href="https://www.sunyazhou.com/2018/05/08/20180508ManualControlUIViewControllerLifeCycle/"/>
    <id>https://www.sunyazhou.com/2018/05/08/20180508ManualControlUIViewControllerLifeCycle/</id>
    <published>2018-05-08T04:01:27.000Z</published>
    <updated>2018-05-08T06:29:41.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>话说很久不用UIViewController的不常用 的API渐渐的都没有了印象,在 iOS 客户端中，多个 childViewController 的页面是个很常见的交互设计,最早的网易新闻,今日头条等.这篇文章回味一下古老的手动控制视图控制器的生命周期的API.</p>
<h1 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h1><p>我们在使用<code>addChildViewController:</code>的时候会遇到个问题.如何手动控制被添加控制器的生命周期.</p>
<p>如下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">self</span>.vc1 = [[VC1ViewController alloc] init]; <span class="comment">//子控制器</span></div><div class="line"><span class="keyword">self</span>.vc2 = [[VC2ViewController alloc] init]; <span class="comment">//子控制器</span></div><div class="line">    </div><div class="line">[<span class="keyword">self</span> addChildViewController:<span class="keyword">self</span>.vc1]; <span class="comment">//添加到父控制器中</span></div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.vc1.view];   <span class="comment">//把子控制器的 view 添加到父控制器的 view 上面</span></div><div class="line"><span class="keyword">self</span>.vc1.view.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//设置 frame</span></div><div class="line">[<span class="keyword">self</span>.vc1 didMoveToParentViewController:<span class="keyword">self</span>];<span class="comment">//子控制器被通知有了一个父控制器</span></div><div class="line"></div><div class="line"></div><div class="line">    </div><div class="line">[<span class="keyword">self</span> addChildViewController:<span class="keyword">self</span>.vc2];</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.vc2.view];</div><div class="line"><span class="keyword">self</span>.vc2.view.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">[<span class="keyword">self</span>.vc2 didMoveToParentViewController:<span class="keyword">self</span>];<span class="comment">//子控制器被通知有了一个父控制器</span></div></pre></td></tr></table></figure>
<p>如果是移除的话使用如下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//移除一个 childViewController</span></div><div class="line">[<span class="keyword">self</span>.vc1 willMoveToParentViewController:<span class="literal">nil</span>];<span class="comment">//子控制器被通知即将解除父子关系</span></div><div class="line">[<span class="keyword">self</span>.vc1.view removeFromSuperview];<span class="comment">//把子控制器的 view 从到父控制器的 view 上面移除</span></div><div class="line">[<span class="keyword">self</span>.vc1 removeFromParentViewController];<span class="comment">//真正的解除关系,会自己调用 [self.vc1 didMoveToParentViewController:nil]</span></div></pre></td></tr></table></figure>
<p>当我们添加child到父控制器的时候<br>它的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</div><div class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated&#123;</div><div class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidDisappear:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些放系统内部会自动帮我们调用</p>
<h4 id="手动管理child-ViewController-的生命周期方法"><a href="#手动管理child-ViewController-的生命周期方法" class="headerlink" title="手动管理child ViewController 的生命周期方法"></a>手动管理child ViewController 的生命周期方法</h4><p>需要在父ViewController里面复写如下方法 并返回<code>NO</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)shouldAutomaticallyForwardAppearanceMethods&#123;</div><div class="line">    <span class="comment">//手动管理子VC的生命周期</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过我们需要注意的是，不能手动调用 viewWillAppear、viewDidAppear等等这些方法，而应该调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)beginAppearanceTransition:(<span class="built_in">BOOL</span>)isAppearing animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line">- (<span class="keyword">void</span>)endAppearanceTransition;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意:<em><strong>用这两个方法来间接触发子控制器的生命周期，并且它们需要成对使用</strong></em></p>
</blockquote>
<p><code>isAppearing</code> 设置为 <code>YES</code> : 触发 <code>viewWillAppear:</code>;  </p>
<p><code>isAppearing</code> 设置为 <code>NO</code> : 触发 <code>viewWillDisappear:</code>;</p>
<p><code>endAppearanceTransition</code>方法会基于我们传入的<code>isAppearing</code><br>来调用<code>viewDidAppear:</code>以及<code>viewDidDisappear:</code>方法</p>
<p>为了测试我写一段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)click:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    sender.selected = !sender.selected;</div><div class="line">    <span class="keyword">if</span> (sender.selected) &#123;</div><div class="line">        [<span class="keyword">self</span>.vc1 beginAppearanceTransition:<span class="literal">NO</span> animated:<span class="literal">YES</span>];  <span class="comment">//调用vc1的 viewWillDisappear:</span></div><div class="line">        [<span class="keyword">self</span>.vc2 beginAppearanceTransition:<span class="literal">YES</span> animated:<span class="literal">YES</span>];  <span class="comment">//调用vc2的 viewWillAppear:</span></div><div class="line">        [<span class="keyword">self</span>.vc1 endAppearanceTransition]; <span class="comment">//调用vc1的viewDidDisappear: </span></div><div class="line">        [<span class="keyword">self</span>.vc2 endAppearanceTransition]; <span class="comment">//调用vc2的viewDidAppear:</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span>.vc1 beginAppearanceTransition:<span class="literal">YES</span> animated:<span class="literal">YES</span>];</div><div class="line">        [<span class="keyword">self</span>.vc2 beginAppearanceTransition:<span class="literal">NO</span> animated:<span class="literal">YES</span>];</div><div class="line">        [<span class="keyword">self</span>.vc1 endAppearanceTransition];</div><div class="line">        [<span class="keyword">self</span>.vc2 endAppearanceTransition];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/sunyazhou13/VCLifeCycle" target="_blank" rel="external">Demo</a></p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;话说很久不用UIViewController的不常用 的API渐渐的都没有了印象,在 iOS 客户端中，多个 childViewContro
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AudioUnit</title>
    <link href="https://www.sunyazhou.com/2018/05/07/20180507AudioUnit/"/>
    <id>https://www.sunyazhou.com/2018/05/07/20180507AudioUnit/</id>
    <published>2018-05-07T06:59:41.000Z</published>
    <updated>2018-05-10T02:34:43.626Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180430AudioEffectImplement/au_host_app1.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>声音的渲染在iOS平台上回直接使用<code>AudioUnit</code>的API来完成.用来实现一些类似<code>大叔</code>,<code>KTV</code>,<code>耳返等效果</code>….</p>
<p>今天带领大家深入了解和学习一下这些音效.</p>
<h2 id="实现iOS变声的背景"><a href="#实现iOS变声的背景" class="headerlink" title="实现iOS变声的背景"></a>实现iOS变声的背景</h2><p>声音变声一般都是发生在 一端采集录制另一端播放音频, 忽略中间的转码过程,在输入输出的中间过程中进行相应的音频参数就实现了变声. </p>
<p>下图是AVAudioSession的工作流<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/9818fa6853c32f92936661cfc06f25c87f07f64f/20180430AudioEffectImplement/ASPG_intro_2x.png" alt=""></p>
<p>大家常用的变声方案有很多:</p>
<ol>
<li>FFMpeg提供内部效果器 eg:EQ均衡器  </li>
<li>AVFoundation底层的<code>Audio Unit</code> eg: 混响reverb</li>
<li>SoundTouch</li>
<li>其它方案…</li>
</ol>
<p>这里我们选用iOS AVFoundation本身提供的音频处理单元<code>Audio Unit</code>. </p>
<p><code>Audio Unit</code>提供如下功能:</p>
<ul>
<li>低延迟的音频I/O eg:voip</li>
<li>多路声音的合成并回放 eg:游戏中的音乐合成器</li>
<li>Audio Unit 自身提供 eg：回声消除、Mix两轨音频、均衡器、压缩器、混响效果器等.</li>
<li>需要图状的结构来处理音频. eg: 有点类似PC时代的主播经常用的一种叫KX 驱动. </li>
</ul>
<p>下图是KX 驱动连线图 windows平台 </p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/ce762c6a5f6eb1d09da7bde9c7ec773c42f2d663/20180430AudioEffectImplement/kx.jpeg" alt=""></p>
<h2 id="AudioUnit介绍"><a href="#AudioUnit介绍" class="headerlink" title="AudioUnit介绍"></a>AudioUnit介绍</h2><h4 id="iOS层级架构图"><a href="#iOS层级架构图" class="headerlink" title="iOS层级架构图"></a>iOS层级架构图</h4><p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180430AudioEffectImplement/iphone_os_audio_architecture_2x.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180430AudioEffectImplement/AboutAudioUnitHosting_2x.png" alt=""></p>
<blockquote>
<p>声音的处理过程, 首先需要认识一下<code>AUGraph</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/360b2677618e504462966e58d406d0a47a6e993d/20180430AudioEffectImplement/simple_au_chain_2x.png" alt=""></p>
<blockquote>
<p><strong>audio processing graph</strong>:  A representation of a signal chain comprising an interconnection of audio units. Also called an AUGraph or graph. Core Audio represents such an interconnected network as a software object of typeAUGraph. Audio processing graphs must end in an output unit. See also audio unit.<br>一种信号链的表示，包括音频单元的互连。也称为AUGraph或graph。Core Audio代表着这样一个相互连接的网络，它是一个<code>AUGraph</code>类型的对象。</p>
</blockquote>
<h4 id="audio-unit-结构图-工作流"><a href="#audio-unit-结构图-工作流" class="headerlink" title="audio unit 结构图(工作流)"></a>audio unit 结构图(工作流)</h4><p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/7e99645383e5db4837567bd9ec35fe78588439f6/20180430AudioEffectImplement/au_architecture.jpg" alt=""></p>
<h4 id="Audio-Unit-构成图"><a href="#Audio-Unit-构成图" class="headerlink" title="Audio Unit 构成图"></a>Audio Unit 构成图</h4><p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/0b99a7e821ed34b72dd684552394dda26c16cf2d/20180430AudioEffectImplement/audioUnitScopes_2x.png" alt=""></p>
<p>Unit 一般 分为 Element0 和  Element1</p>
<p>下面我们举Remote I/O Unit为例:  </p>
<p>RemoteIO 这个Unit是和硬件IO相关的Unit，它分为输入端和输出端, 输入端一般指麦克风,输出端一般指扬声器.</p>
<blockquote>
<p><code>Element0</code> 控制输出<br><code>Element1</code> 控制输入<br>图中Element 也叫 bus；<br>音频流从输入域（input scope）输入， 从输出域（output scope）输出<br>整个Render过程就是一次RenderCycle</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180430AudioEffectImplement/IO_unit_2x.png" alt=""></p>
<p><strong>同时每个Element分为Input Scope 和 Output Scope.如果我们想使用扬声器的声音播放功能,必须需将这个Unit的<code>Element0</code>的<code>OutputScope</code>和Speak进行连接. 如果想使用麦克风录音功能,那么必须将这个Unit的<code>Element1</code>的<code>InputScope</code>和麦克风进行连接.</strong></p>
<h3 id="构建Audio-Unit"><a href="#构建Audio-Unit" class="headerlink" title="构建Audio Unit"></a>构建Audio Unit</h3><p>首先需要启用音频会话 这些大家自己配置就好 了 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//配置会话相关伪代码</div><div class="line">[[AVAudioSession sharedInstance].xxxxx xxxxx];</div></pre></td></tr></table></figure>
<p>如何用代码构建一个Audio Unit？ 这里我们以Remote I/O Unit 为例:</p>
<p>创建AudioUnit有两种方式</p>
<ol>
<li>直接使用AudioUnit裸创建 </li>
<li>使用AUGraph和AUNode来构建</li>
</ol>
<ul>
<li>第一种 裸创建</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;AudioUnit/AudioUnit.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line">&#123;</div><div class="line">    AudioUnit ioUnitInstance; <span class="comment">//声明一变量</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//首先构造出要用到创建Unit的结构体</span></div><div class="line">    AudioComponentDescription ioUnitDescription;</div><div class="line">    ioUnitDescription.componentType = kAudioUnitType_Output;</div><div class="line">    ioUnitDescription.componentSubType = kAudioUnitSubType_RemoteIO;</div><div class="line">    ioUnitDescription.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">    ioUnitDescription.componentFlags = <span class="number">0</span>;</div><div class="line">    ioUnitDescription.componentFlagsMask = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    AudioComponent ioUnitRef = AudioComponentFindNext(<span class="literal">NULL</span>, &amp;ioUnitDescription);</div><div class="line">    <span class="comment">//创建AudioUnit实例</span></div><div class="line">    AudioComponentInstanceNew(ioUnitRef, &amp;ioUnitInstance);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第二种使用AUGraph和AUNode</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;AudioUnit/AudioUnit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;AudioToolbox/AudioToolbox.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line">&#123;</div><div class="line">    AUGraph     processingGraph;</div><div class="line">    AUNode      ioNode;</div><div class="line">    AudioUnit   ioUnit;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//首先构造出要用到创建Unit的结构体</span></div><div class="line">    AudioComponentDescription ioUnitDescription;</div><div class="line">    ioUnitDescription.componentType = kAudioUnitType_Output;</div><div class="line">    ioUnitDescription.componentSubType = kAudioUnitSubType_RemoteIO;</div><div class="line">    ioUnitDescription.componentManufacturer = kAudioUnitManufacturer_Apple;</div><div class="line">    ioUnitDescription.componentFlags = <span class="number">0</span>;</div><div class="line">    ioUnitDescription.componentFlagsMask = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//1 new</span></div><div class="line">    NewAUGraph(&amp;processingGraph);</div><div class="line">    AUGraphAddNode(processingGraph, &amp;ioUnitDescription, &amp;ioNode);</div><div class="line">    </div><div class="line">    <span class="comment">//2 open</span></div><div class="line">    AUGraphOpen(processingGraph);</div><div class="line">    </div><div class="line">    <span class="comment">//3 从相应的Node中获得AudioUnit</span></div><div class="line">    AUGraphNodeInfo(processingGraph, ioNode, <span class="literal">NULL</span>, &amp;ioUnit);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>推荐使用第二种因为这种创建扩展性更高一些<br>注意:<strong><em>AUNode必须和AudioUnit成对出现</em></strong></p>
</blockquote>
<p>如下图 ：Remote I/O Unit </p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/0b99a7e821ed34b72dd684552394dda26c16cf2d/20180430AudioEffectImplement/IO_unit_2x.png" alt=""></p>
<blockquote>
<p>麦克风或者扬声器在Audio Unit中有相应的枚举.<br>直播中的<code>耳返</code>就是用的这个把麦克风采集的数据直接扔给扬声器 这样就能做到 低延迟的实时听到麦克风的声音.<br>直播中一般使用<code>Remote I/O</code> unit来进行采集工作</p>
</blockquote>
<p>使用AudioUnit连接扬声器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">OSStatus status = noErr;</div><div class="line"><span class="built_in">UInt32</span> onFlag = <span class="number">1</span>;</div><div class="line"><span class="built_in">UInt32</span> busZero = <span class="number">0</span>; <span class="comment">//Element0  就是bus0</span></div><div class="line">status = AudioUnitSetProperty(remoteIOUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Output, busZero, &amp;onFlag, <span class="keyword">sizeof</span>(onFlag));</div><div class="line">CheckStatus(status, <span class="string">@"不能连接扬声器"</span>, <span class="literal">YES</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意: kAudioUnitScope_Output 就是连接扬声器的key</p>
</blockquote>
<p>连接麦克风</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">OSStatus status = noErr;</div><div class="line"><span class="built_in">UInt32</span> busOne = <span class="number">1</span>; <span class="comment">//Element1 就是bus1 接麦克风输入</span></div><div class="line"><span class="built_in">UInt32</span> oneFlag = <span class="number">1</span>;</div><div class="line">status =  AudioUnitSetProperty(remoteIOUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Input, busOne, &amp;oneFlag, <span class="keyword">sizeof</span>(oneFlag));</div><div class="line">CheckStatus(status, <span class="string">@"不能连接麦克风"</span>, <span class="literal">YES</span>);</div></pre></td></tr></table></figure>
<p>可以使用如下代码检查每一步执行出错debug  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> CheckStatus(OSStatus status, <span class="built_in">NSString</span> *message, <span class="built_in">BOOL</span> fatal) &#123;</div><div class="line">    <span class="keyword">if</span> (status != noErr) &#123;</div><div class="line">        <span class="keyword">char</span> fourCC[<span class="number">16</span>];</div><div class="line">        *(<span class="built_in">UInt32</span> *)fourCC = <span class="built_in">CFSwapInt32HostToBig</span>(status);</div><div class="line">        fourCC[<span class="number">4</span>] = <span class="string">'\0'</span>;</div><div class="line">        <span class="keyword">if</span> (isprint(fourCC[<span class="number">0</span>]) &amp;&amp; isprint(fourCC[<span class="number">1</span>]) &amp;&amp;</div><div class="line">            isprint(fourCC[<span class="number">2</span>]) &amp;&amp; isprint(fourCC[<span class="number">4</span>])) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@:%s"</span>,message, fourCC);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@:%d"</span>,message, (<span class="keyword">int</span>)status);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (fatal) &#123;</div><div class="line">            exit(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>由于status每次报错都打印 相关数字大家可能不理解可以点击<a href="https://www.osstatus.com/" target="_blank" rel="external">OSStatus</a> 查询相关错误码</p>
</blockquote>
<h4 id="AVAudioMix"><a href="#AVAudioMix" class="headerlink" title="AVAudioMix"></a>AVAudioMix</h4><p>我们一般都在采集、录制或编辑音视频相应的类中使用AVAudioMixer.</p>
<p>举个例子:我们变声实现的流程大概是这个样子 <strong>AVAudioPlayer -&gt; AVPlayerItem -&gt; AVAudioMixer-&gt; AUGraph -&gt; AUNode + AudioUnit</strong></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/903e2fa4eb2daafcc3b187854edc69d1bad8b382/20180430AudioEffectImplement/AVAudioMix-class.001.png" alt=""></p>
<h4 id="AudioStreamBasicDescription-配置麦克风输入的参数"><a href="#AudioStreamBasicDescription-配置麦克风输入的参数" class="headerlink" title="AudioStreamBasicDescription 配置麦克风输入的参数"></a>AudioStreamBasicDescription 配置麦克风输入的参数</h4><p>当我们控制Remote IO Unit的时候想告诉麦克风 各种input的参数 可以通过 一个叫ASBD 格式的结构体数据描述来设置给相应的Unit</p>
<h5 id="Audio-Stream-Format-描述ASBD"><a href="#Audio-Stream-Format-描述ASBD" class="headerlink" title="Audio Stream Format 描述ASBD"></a>Audio Stream Format 描述ASBD</h5><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">UInt32</span> bytePerSample = <span class="keyword">sizeof</span>(Float32);</div><div class="line">AudioStreamBasicDescription asbd;</div><div class="line">bzero(&amp;asbd, <span class="keyword">sizeof</span>(asbd));</div><div class="line">asbd.mFormatID = kAudioFormatLinearPCM;</div><div class="line">asbd.mSampleRate = <span class="number">44100</span>;</div><div class="line">asbd.mChannelsPerFrame = channels;</div><div class="line">asbd.mFramesPerPacket = <span class="number">1</span>;</div><div class="line">asbd.mFormatFlags = kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved;</div><div class="line">asbd.mBitsPerChannel = <span class="number">8</span> * bytePerSample;</div><div class="line">asbd.mBytesPerFrame = bytePerSample;</div><div class="line">asbd.mBytesPerPacket = bytePerSample;</div></pre></td></tr></table></figure>
<blockquote>
<p>上边代码展示了如何填充ASBD结构体,这个描述音视频的具体格式.</p>
</blockquote>
<p>下面具体介绍一下各个参数的意思</p>
<ul>
<li>mFormatID 可用来指定编码格式 eg:PCM</li>
<li>mSampleRate 采样率</li>
<li>mChannelsPerFrame 每个Frame有几个channel</li>
<li>mFramesPerPacket 每个Packet有几Frame</li>
<li>mFormatFlags 这个是用来描述声音格式表示格式的参数,上面代码我们指定的是每个sample的表示格式为Float格式,有点类似SInt16,如果后边是NonInterleaved代表非交错的,对于这个音频来讲就是左右声道的是非交错存放的,实际的音频数据会存储在一个AudioBufferList结构中的变量mBuffers中,如果mFormatFlags指定的是NonInterleaved,那么左声道就在会在mBuffers[0]里面,右声道就在mBuffers[1]里面.</li>
<li>mBitsPerChannel 表示一个声道的音频数据用多少位来表示,上面我们用的是Float来表示, 所以这里使用的是 8 乘以 每个采样的字节数来赋值.</li>
<li>mBytesPerFrame 和 mBytesPerPacket 这两个的赋值需要根据mFormatFlags 的值来进行分配,如果是NonInterleaved非交错的情况下, 就赋值bytePerSample(因为左右声道是分开的).但如果是Interleaved的话,那就应该是 bytePerSample * channels (因为左右声道是交错存放),这样才能表示一个Frame里面到底有多少byte.</li>
</ul>
<p>讲了这么多 那我们怎么把这个ASDB给 Unit?</p>
<p>如下代码 设置ASBD给相应的Audio Unit</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AudioUnitSetProperty(remoteIOUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, <span class="number">1</span>, &amp;asbd, <span class="keyword">sizeof</span>(asbd));</div></pre></td></tr></table></figure>
<p>完整的代码如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//设置ASBD</span></div><div class="line">AudioStreamBasicDescription inputFormat;</div><div class="line">inputFormat.mSampleRate = <span class="number">44100</span>;</div><div class="line">inputFormat.mFormatID = kAudioFormatLinearPCM;</div><div class="line">inputFormat.mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsNonInterleaved;</div><div class="line">inputFormat.mFramesPerPacket = <span class="number">1</span>;</div><div class="line">inputFormat.mChannelsPerFrame = <span class="number">1</span>;</div><div class="line">inputFormat.mBytesPerPacket = <span class="number">2</span>;</div><div class="line">inputFormat.mBytesPerFrame = <span class="number">2</span>;</div><div class="line">inputFormat.mBitsPerChannel = <span class="number">16</span>;</div><div class="line"><span class="comment">//设置给输入端 配置麦克风输出的数据是什么格式</span></div><div class="line">OSStatus status = noErr;</div><div class="line">status = AudioUnitSetProperty(audioUnit,</div><div class="line">                              kAudioUnitProperty_StreamFormat,</div><div class="line">                              kAudioUnitScope_Output,</div><div class="line">                              InputBus,</div><div class="line">                              &amp;inputFormat,</div><div class="line">                              <span class="keyword">sizeof</span>(inputFormat));</div><div class="line">CheckStatus(status, <span class="string">@"AudioUnitGetProperty bus1 output ASBD error"</span>, <span class="literal">YES</span>);</div></pre></td></tr></table></figure>
<h3 id="Audio-Unit-分类"><a href="#Audio-Unit-分类" class="headerlink" title="Audio Unit 分类"></a>Audio Unit 分类</h3><figure class="highlight"><table><tr><td class="code"><pre><div class="line">CF_ENUM(UInt32) &#123;</div><div class="line">	kAudioUnitType_Output					= 'auou',</div><div class="line">	kAudioUnitType_MusicDevice				= 'aumu',</div><div class="line">	kAudioUnitType_MusicEffect				= 'aumf',</div><div class="line">	kAudioUnitType_FormatConverter			= 'aufc',</div><div class="line">	kAudioUnitType_Effect					= 'aufx',</div><div class="line">	kAudioUnitType_Mixer					= 'aumx',</div><div class="line">	kAudioUnitType_Panner					= 'aupn',</div><div class="line">	kAudioUnitType_Generator				= 'augn',</div><div class="line">	kAudioUnitType_OfflineEffect			= 'auol',</div><div class="line">	kAudioUnitType_MIDIProcessor			= 'aumi'</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">功能/作用</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Effect Unit</td>
<td style="text-align:left">提供声音特效处理</td>
<td style="text-align:left">kAudioUnitType_Effect</td>
</tr>
<tr>
<td style="text-align:left">Mixer Units</td>
<td style="text-align:left">提供Mix多路声音的功能</td>
<td style="text-align:left">kAudioUnitType_Mixer</td>
</tr>
<tr>
<td style="text-align:left">I/O Units</td>
<td style="text-align:left">I/O 采集音频与播放音频功能</td>
<td style="text-align:left">kAudioUnitType_Output</td>
</tr>
<tr>
<td style="text-align:left">AUConverter Units</td>
<td style="text-align:left">格式转换 eg:采样格式Float转SInt16、交错或平铺、单双声道的转换</td>
<td style="text-align:left">kAudioUnitType_FormatConverter</td>
</tr>
<tr>
<td style="text-align:left">Generator Units</td>
<td style="text-align:left">提供播放器功能</td>
<td style="text-align:left">kAudioUnitType_Generator</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">CF_ENUM(UInt32) &#123;</div><div class="line">	kAudioUnitSubType_PeakLimiter			= 'lmtr',</div><div class="line">	kAudioUnitSubType_DynamicsProcessor		= 'dcmp',</div><div class="line">	kAudioUnitSubType_LowPassFilter			= 'lpas',</div><div class="line">	kAudioUnitSubType_HighPassFilter		= 'hpas',</div><div class="line">	kAudioUnitSubType_BandPassFilter		= 'bpas',</div><div class="line">	kAudioUnitSubType_HighShelfFilter		= 'hshf',</div><div class="line">	kAudioUnitSubType_LowShelfFilter		= 'lshf',</div><div class="line">	kAudioUnitSubType_ParametricEQ			= 'pmeq',</div><div class="line">	kAudioUnitSubType_Distortion			= 'dist',</div><div class="line">	kAudioUnitSubType_Delay					= 'dely',</div><div class="line">	kAudioUnitSubType_SampleDelay			= 'sdly',</div><div class="line">	kAudioUnitSubType_NBandEQ				= 'nbeq'</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">CF_ENUM(UInt32) &#123;</div><div class="line">	kAudioUnitSubType_Reverb2				= 'rvb2',</div><div class="line">	kAudioUnitSubType_AUiPodEQ				= 'ipeq'</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Effect-Unit-子类型及用途说明"><a href="#Effect-Unit-子类型及用途说明" class="headerlink" title="Effect Unit 子类型及用途说明"></a>Effect Unit 子类型及用途说明</h4><table>
<thead>
<tr>
<th style="text-align:left">子类型</th>
<th style="text-align:left">用途说明</th>
<th style="text-align:left">子枚举类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">均衡效果器</td>
<td style="text-align:left">为声音的某些<a href="https://baike.baidu.com/item/%E9%A2%91%E5%B8%A6" target="_blank" rel="external">频带</a>增强或衰减能量，效果器需要指定多个频带,然后为各频带设置增益最终改变声音在音域上的能量分布</td>
<td style="text-align:left">kAudioUnitSubType_NBandEQ</td>
</tr>
<tr>
<td style="text-align:left">压缩效果器</td>
<td style="text-align:left">当声音较小或较大通过设置阀值来提高或降低声音能量 eg:作用时间、释放时间、以及触发值从而最终控制声音在时域上的能量范围</td>
<td style="text-align:left">kAudioUnitSubType_DynamicsProcessor</td>
</tr>
<tr>
<td style="text-align:left">混响效果器</td>
<td style="text-align:left">通过声音反射的延迟控制声音效果</td>
<td style="text-align:left">kAudioUnitSubType_Reverb2</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Effect Unit 下最常用的效果器就上边这三种, 像高通(High Pass)、低通(Low Pass)、带通(Band Pass)、延迟(Delay)、压限(Limiter) 等这些不是很常用,如果大家对这个很熟悉可以试试使用一下.</p>
</blockquote>
<h4 id="Mixer-Units-子类型及用途说明"><a href="#Mixer-Units-子类型及用途说明" class="headerlink" title="Mixer Units 子类型及用途说明"></a>Mixer Units 子类型及用途说明</h4><table>
<thead>
<tr>
<th style="text-align:left">子类型</th>
<th style="text-align:left">用途说明</th>
<th style="text-align:left">子枚举类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">3D Mixer</td>
<td style="text-align:left">仅支持 macOS</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">MultiChannelMixer</td>
<td style="text-align:left">多路声音混音效果器,可以接受多路音频输入,还可以分别调整每一路的音频增益和开关,并将多路音频合成一路</td>
<td style="text-align:left">kAudioUnitSubType_MultiChannelMixer</td>
</tr>
</tbody>
</table>
<h4 id="I-O-Units-子类型及用途说明"><a href="#I-O-Units-子类型及用途说明" class="headerlink" title="I/O Units 子类型及用途说明"></a>I/O Units 子类型及用途说明</h4><table>
<thead>
<tr>
<th style="text-align:left">子类型</th>
<th style="text-align:left">用途说明</th>
<th style="text-align:left">子枚举类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Remote I/O</td>
<td style="text-align:left">采集音频与播放音频,在Audio Unit中使用麦克风和扬声器的时候会用到这个Unit</td>
<td style="text-align:left">kAudioUnitType_Output</td>
</tr>
<tr>
<td style="text-align:left">Generic Output</td>
<td style="text-align:left">进行离线处理,或者说AUGraph中不使用扬声器来驱动整个数据流,而希望使用一个输出(可以放入内存队列或者磁盘I/O操作)来驱动数据流时</td>
<td style="text-align:left">kAudioUnitSubType_GenericOutput</td>
</tr>
</tbody>
</table>
<h4 id="AUConverter-Units-子类型及用途说明"><a href="#AUConverter-Units-子类型及用途说明" class="headerlink" title="AUConverter Units 子类型及用途说明"></a>AUConverter Units 子类型及用途说明</h4><table>
<thead>
<tr>
<th style="text-align:left">子类型</th>
<th style="text-align:left">用途说明</th>
<th style="text-align:left">子枚举类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AUConverter</td>
<td style="text-align:left">格式转换,当某些效果器对输入的音频格式有明确要求时,或者我们将音频数据输入给一些其它的编码器进行编码。。。</td>
<td style="text-align:left">kAudioUnitSubType_AUConverter</td>
</tr>
<tr>
<td style="text-align:left">Time Pitch</td>
<td style="text-align:left">变速变调效果器,调整声音音高. eg:会说话的Tom猫</td>
<td style="text-align:left">kAudioUnitSubType_NewTimePitch</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意: AUConverter  如果由FFMpeg解码出来的PCM 是SInt16格式 如果要用格式转换效果器unit必须转成Float32格式表示的数据.</p>
</blockquote>
<h4 id="Generator-Units-子类型及用途说明"><a href="#Generator-Units-子类型及用途说明" class="headerlink" title="Generator Units 子类型及用途说明"></a>Generator Units 子类型及用途说明</h4><table>
<thead>
<tr>
<th style="text-align:left">子类型</th>
<th style="text-align:left">用途说明</th>
<th style="text-align:left">子枚举类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AudioFilePlayer</td>
<td style="text-align:left">接收裸PCM 播放 一般大家可以用这个配合Remote I/O 做播放器</td>
<td style="text-align:left">kAudioUnitSubType_AudioFilePlayer</td>
</tr>
</tbody>
</table>
<p>相关shell命令 <strong>将音频文件转成pcm</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">ffmpeg -i test.mp3 -acodec pcm_s16le -f s16le output.pcm</div></pre></td></tr></table></figure>
<blockquote>
<p>brew install ffmpeg</p>
</blockquote>
<p><a href="https://github.com/sunyazhou13/AduioUnitDemo" target="_blank" rel="external">Demo实现耳返功能</a><br><a href="https://github.com/sunyazhou13/AudioUnitDemo2" target="_blank" rel="external">Demo2实现耳返+伴奏播放</a></p>
<h4 id="下面我分享一个变声中混响效果代码"><a href="#下面我分享一个变声中混响效果代码" class="headerlink" title="下面我分享一个变声中混响效果代码"></a>下面我分享一个变声中混响效果代码</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//声明部分  .h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KSYAudioReverbFilter</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"></div><div class="line">-(<span class="keyword">instancetype</span>)init;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setupWithAUGraph:(AUGraph)auGraph asbd:(<span class="keyword">const</span> AudioStreamBasicDescription *)asbd maxFrame:(<span class="built_in">CMItemCount</span>)max;</div><div class="line"></div><div class="line"><span class="comment">// Global, CrossFade, 0-&gt;100, 100</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> dryWetMix;</div><div class="line"><span class="comment">// Global, Decibels, -20-&gt;20, 0dB.</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> gain;</div><div class="line"><span class="comment">// Global, Secs, 0.0001-&gt;1.0, 0.008</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> minDelayTime;</div><div class="line"><span class="comment">// Global, Secs, 0.0001-&gt;1.0, 0.050</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> maxDelayTime;</div><div class="line"><span class="comment">// Global, Secs, 0.001-&gt;20.0, 1.0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> decayTimeAt0Hz;</div><div class="line"><span class="comment">// Global, Secs, 0.001-&gt;20.0, 0.5</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> decayTimeAtNyquist;</div><div class="line"><span class="comment">// Global, Integer, 1-&gt;1000, 1</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">double</span> randomizeReflections;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//实现部分</span></div><div class="line"></div><div class="line"><span class="comment">//通用的宏</span></div><div class="line"><span class="meta">#define RC_CHECK(rc, str) if (rc != noErr) \</span></div><div class="line">&#123; \</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Err :%@ %@ %@"</span>, @(rc), str, @(__func__)); \</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KSYAudioReverbFilter</span></span></div><div class="line"></div><div class="line">-(<span class="keyword">instancetype</span>)init&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)&#123;</div><div class="line">        <span class="keyword">self</span>.acDes = (AudioComponentDescription)&#123;kAudioUnitType_Effect, kAudioUnitSubType_Reverb2, kAudioUnitManufacturer_Apple, <span class="number">0</span>, <span class="number">0</span>&#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setupWithAUGraph:(AUGraph)auGraph asbd:(<span class="keyword">const</span> AudioStreamBasicDescription *)asbd maxFrame:(<span class="built_in">CMItemCount</span>)maxFrame</div><div class="line">&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">    OSStatus status = noErr;</div><div class="line">    <span class="built_in">NSAssert</span>(auGraph != <span class="literal">nil</span>, <span class="string">@"auGraph is null"</span>);</div><div class="line">    audioGraph = auGraph;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"setup :%@"</span>, <span class="built_in">NSStringFromCode</span>(_acDes.componentSubType));</div><div class="line">    status = AUGraphAddNode(auGraph, &amp;_acDes, &amp;_node);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (noErr != status)&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSString</span> *error = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"add node with type %u failed"</span>, _acDes.componentType];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    status = AUGraphNodeInfo(auGraph, _node, <span class="literal">NULL</span>, &amp;_audioUnit);</div><div class="line">    <span class="keyword">if</span> (noErr != status)&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"create audiouinit failed err:%@"</span>, @(status));</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    RC_CHECK(AudioUnitSetProperty(_audioUnit,</div><div class="line">                                  kAudioUnitProperty_StreamFormat,</div><div class="line">                                  kAudioUnitScope_Input, <span class="number">0</span>, asbd, <span class="keyword">sizeof</span>(AudioStreamBasicDescription)),</div><div class="line">             <span class="string">@"kAudioUnitProperty_StreamFormat kAudioUnitScope_Input err"</span>);</div><div class="line">    </div><div class="line">    RC_CHECK(AudioUnitSetProperty(_audioUnit,</div><div class="line">                                  kAudioUnitProperty_StreamFormat,</div><div class="line">                                  kAudioUnitScope_Output, <span class="number">0</span>, asbd, <span class="keyword">sizeof</span>(AudioStreamBasicDescription)),</div><div class="line">             <span class="string">@"kAudioUnitProperty_StreamFormat kAudioUnitScope_Output err"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// Set audio unit maximum frames per slice to max frames.</span></div><div class="line">    RC_CHECK(AudioUnitSetProperty(_audioUnit,</div><div class="line">                                  kAudioUnitProperty_MaximumFramesPerSlice,</div><div class="line">                                  kAudioUnitScope_Global, <span class="number">0</span>, &amp;maxFrame, (<span class="built_in">UInt32</span>)<span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>)),</div><div class="line">             <span class="string">@"set kAudioUnitProperty_MaximumFramesPerSlice err"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Setters</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setDryWetMix:(<span class="keyword">double</span>)dryWetMix</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_DryWetMix value:dryWetMix];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setGain:(<span class="keyword">double</span>)gain</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_Gain value:gain];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setMinDelayTime:(<span class="keyword">double</span>)minDelayTime</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_MinDelayTime value:minDelayTime];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setMaxDelayTime:(<span class="keyword">double</span>)maxDelayTime</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_MaxDelayTime value:maxDelayTime];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setDecayTimeAt0Hz:(<span class="keyword">double</span>)decayTimeAt0Hz</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_DecayTimeAt0Hz value:decayTimeAt0Hz];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setDecayTimeAtNyquist:(<span class="keyword">double</span>)decayTimeAtNyquist</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_DecayTimeAtNyquist value:decayTimeAtNyquist];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setRandomizeReflections:(<span class="keyword">double</span>)randomizeReflections</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> setGlobalParam:kReverb2Param_RandomizeReflections value:randomizeReflections];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//通用方法</span></div><div class="line">- (<span class="keyword">void</span>)setGlobalParam:(AudioUnitParameterID)paramId value:(AudioUnitParameterValue)value</div><div class="line">&#123;</div><div class="line"></div><div class="line">    RC_CHECK(AudioUnitSetParameter(_audioUnit,</div><div class="line">                                   paramId,</div><div class="line">                                   kAudioUnitScope_Global, <span class="number">0</span>, value, <span class="number">0</span>),</div><div class="line">             ([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set %u value %f err"</span>, paramId, value]));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>外部调用的话就是这样的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AURenderCallbackStruct renderCallbackStruct;</div><div class="line">renderCallbackStruct.inputProc = ksyme_RenderCallback;</div><div class="line">renderCallbackStruct.inputProcRefCon = (<span class="keyword">void</span> *)<span class="keyword">self</span>.apt;</div><div class="line">    </div><div class="line"><span class="keyword">if</span> (!_reverbFilter)&#123;</div><div class="line">    _reverbFilter = [[KSYAudioReverbFilter alloc] init];</div><div class="line">    [_reverbFilter setupWithAUGraph:auGraph asbd:format maxFrame:max];</div><div class="line">    _reverbFilter.renderCallBack = renderCallbackStruct;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="连接node"><a href="#连接node" class="headerlink" title="连接node"></a>连接node</h3><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AUGraphClearConnections(auGraph);</div><div class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">[array addObject:@(_mixFilter.node)];</div><div class="line"></div><div class="line">[array addObjectsFromArray:@[@(_reverbFilter.node),@(_delayFilter.node),@(_pitchFilter.node)]];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.count <span class="number">-1</span>; i++) &#123;</div><div class="line">    AUGraphConnectNodeInput(auGraph,[array[i] intValue], <span class="number">0</span>,[array[i+<span class="number">1</span>] intValue], <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心代码就是如何连接Node</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AUGraphConnectNodeInput(auGraph,reverbNode, <span class="number">0</span>, remoteIONode, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>0代表 bus0</p>
</blockquote>
<p>系统定义的API是这样的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">extern</span> OSStatus</div><div class="line">AUGraphConnectNodeInput(	AUGraph			inGraph,</div><div class="line">						AUNode			inSourceNode,</div><div class="line">						<span class="built_in">UInt32</span>			inSourceOutputNumber,</div><div class="line">						AUNode			inDestNode,</div><div class="line">						<span class="built_in">UInt32</span>			inDestInputNumber)		__OSX_AVAILABLE_STARTING(__MAC_10_0,__IPHONE_2_0);</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Audio Unit的相关技术学习点比较多大家灵活掌握运用,不懂没关系从简单的Unit开始学起.</p>
<p>全文完</p>
<p>参考列表:<br><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Reference/CoreAudioGlossary/Glossary/core_audio_glossary.html#//apple_ref/doc/uid/TP40004453-CH210-SW1" target="_blank" rel="external">iOS Audio相关术语(Glossary)</a><br><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/Introduction/Introduction.html" target="_blank" rel="external">参考</a><br><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitProgrammingGuide/Tutorial-BuildingASimpleEffectUnitWithAGenericView/Tutorial-BuildingASimpleEffectUnitWithAGenericView.html#//apple_ref/doc/uid/TP40003278-CH5-SW4" target="_blank" rel="external">如何自己制作一个Audio Unit</a><br><a href="https://www.jianshu.com/p/05cae433faea" target="_blank" rel="external">金山云直播音效实现</a><br><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/AudioUnitHostingFundamentals/AudioUnitHostingFundamentals.html#//apple_ref/doc/uid/TP40009492-CH3-SW12" target="_blank" rel="external">Audio Unit官方文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180430AudioEffectImplement/au_host_app1.jpg
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解RunLoop</title>
    <link href="https://www.sunyazhou.com/2018/04/02/20180402RunLoop/"/>
    <id>https://www.sunyazhou.com/2018/04/02/20180402RunLoop/</id>
    <published>2018-04-02T06:16:34.000Z</published>
    <updated>2018-05-07T07:06:41.933Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/0fa4569bca7b3a2d5c1ee360f47ac1dd213ecbac/20180402RunLoop/runloop6.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>RunLoop</code> 是 <code>iOS</code> 和 <code>OSX</code> 开发中非常基础的一个概念，这篇文章将从<code>CFRunLoop</code>的源码入手，介绍 <code>RunLoop</code> 的概念以及底层实现原理。之后会介绍一下在 <code>iOS</code> 中，苹果是如何利用<code>RunLoop</code>实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p>
<h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><ul>
<li>RunLoop 的概念</li>
<li>RunLoop 与线程的关系</li>
<li>RunLoop 对外的接口</li>
<li>RunLoop 的 Mode</li>
<li>RunLoop 的内部逻辑</li>
<li>RunLoop 的底层实现</li>
<li>苹果用 RunLoop 实现的功能<ol>
<li>AutoreleasePool</li>
<li>事件响应</li>
<li>手势识别</li>
<li>界面更新</li>
<li>定时器</li>
<li>PerformSelecter</li>
<li>关于GCD</li>
<li>关于网络请求</li>
</ol>
</li>
<li>RunLoop 的实际应用举例<ol>
<li>AFNetworking</li>
<li>AsyncDisplayKit</li>
</ol>
</li>
</ul>
<h3 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h3><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">function loop() &#123;</div><div class="line">    initialize();</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">var</span> message = get_next_message();</div><div class="line">        process_message(message);</div><div class="line">    &#125; <span class="keyword">while</span> (message != quit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种模型通常被称作 <a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event Loop</a>。 <code>Event Loop</code> 在很多系统和框架里都有实现，比如 <code>Node.js</code>的事件处理，比如 <code>Windows</code> 程序的消息循环，再比如 <code>OSX/iOS</code> 里的 <code>RunLoop</code>。实现这种模型的关键点在于：如何<code>管理事件/消息</code>，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
<p>所以，<code>RunLoop</code> 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 <code>Event Loop</code> 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “<code>接受消息</code>-&gt;<code>等待-&gt;</code>处理<code>” 的循环中，直到这个循环结束（比如传入</code>quit` 的消息），函数返回。</p>
<p><code>OSX/iOS</code> 系统中，提供了两个这样的对象：<code>NSRunLoop</code> 和 <code>CFRunLoopRef</code>。  </p>
<p><code>CFRunLoopRef</code> 是在 <code>CoreFoundation</code> 框架内的，它提供了纯 <code>C</code> 函数的 <code>API</code>，所有这些 <code>API</code> 都是线程安全的。  </p>
<p><code>NSRunLoop</code> 是基于 <code>CFRunLoopRef</code> 的封装，提供了面向对象的 <code>API</code>，但是这些 <code>API</code> 不是线程安全的。  </p>
<p>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c" target="_blank" rel="external">开源</a>的，你可以在这里 <a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">http://opensource.apple.com/tarballs/CF/</a> 下载到整个 <code>CoreFoundation</code> 的源码来查看。</p>
<p>(Update: Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：<a href="https://github.com/apple/swift-corelibs-foundation/" target="_blank" rel="external">https://github.com/apple/swift-corelibs-foundation/</a>，这个版本的源码可能和现有<code>iOS</code>系统中的实现略不一样，但更容易编译，而且已经适配了<code>Linux/Windows</code>。)</p>
<h3 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h3><p>首先，<code>iOS</code> 开发中能遇到两个线程对象: <code>pthread_t</code> 和 <code>NSThread</code>。过去苹果有份文档标明了 <code>NSThread</code> 只是 <code>pthread_t</code> 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 <code>mach thread</code>。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 <code>pthread_t</code> 和 <code>NSThread</code> 是一一对应的。比如，你可以通过 <code>pthread_main_thread_np()</code> 或 <code>[NSThread mainThread]</code> 来获取主线程；也可以通过 <code>pthread_self()</code> 或 <code>[NSThread currentThread]</code> 来获取当前线程。<code>CFRunLoop</code> 是基于 <code>pthread</code> 来管理的。</p>
<p>苹果不允许直接创建 <code>RunLoop</code>，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> 和 <code>CFRunLoopGetCurrent()</code>。 这两个函数内部的逻辑大概是下面这样:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></div><div class="line"><span class="keyword">static</span> CFMutableDictionaryRef loopsDic;</div><div class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></div><div class="line"><span class="keyword">static</span> CFSpinLock_t loopsLock;</div><div class="line"> </div><div class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></div><div class="line">CFRunLoopRef _CFRunLoopGet(<span class="keyword">pthread_t</span> thread) &#123;</div><div class="line">    OSSpinLockLock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</div><div class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></div><div class="line">        loopsDic = CFDictionaryCreateMutable();</div><div class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</div><div class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></div><div class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!loop) &#123;</div><div class="line">        <span class="comment">/// 取不到时，创建一个</span></div><div class="line">        loop = _CFRunLoopCreate();</div><div class="line">        CFDictionarySetValue(loopsDic, thread, loop);</div><div class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></div><div class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    OSSpinLockUnLock(&amp;loopsLock);</div><div class="line">    <span class="keyword">return</span> loop;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和<code>RunLoop</code>之间是一一对应的，其关系是保存在一个全局的 <code>Dictionary</code> 里。线程刚创建时并没有 <code>RunLoop</code>，如果你不主动获取，那它一直都不会有。<code>RunLoop</code> 的创建是发生在第一次获取时，<code>RunLoop</code> 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 <code>RunLoop</code>（主线程除外）.</p>
<h3 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h3><p>在 <code>CoreFoundation</code> 里面关于 <code>RunLoop</code> 有5个类:</p>
<ul>
<li><code>CFRunLoopRef</code></li>
<li><code>CFRunLoopModeRef</code></li>
<li><code>CFRunLoopSourceRef</code></li>
<li><code>CFRunLoopTimerRef</code></li>
<li><code>CFRunLoopObserverRef</code></li>
</ul>
<p>其中 <code>CFRunLoopModeRef</code> 类并没有对外暴露，只是通过 <code>CFRunLoopRef</code> 的接口进行了封装。他们的关系如下:</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_0.png" alt=""></p>
<p>一个 <code>RunLoop</code> 包含若干个 <code>Mode</code>，每个 <code>Mode</code>又包含若干个 <code>Source</code>/<code>Timer</code>/<code>Observer</code>。每次调用 <code>RunLoop</code> 的主函数时，只能指定其中一个 <code>Mode</code>，这个<code>Mode</code>被称作 <code>CurrentMode</code>。如果需要切换 <code>Mode</code>，只能退出 <code>Loop</code>，再重新指定一个 <code>Mode</code> 进入。这样做主要是为了分隔开不同组的 <code>Source</code>/<code>Timer</code>/<code>Observer</code>，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。<code>Source</code>有两个版本：<code>Source0</code> 和 <code>Source1</code>。</p>
<ul>
<li><code>Source0</code> 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 <code>Source</code> 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 <code>RunLoop</code>，让其处理这个事件。  </li>
<li><code>Source1</code> 包含了一个 <code>mach_port</code> 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 <code>Source</code> 能主动唤醒 <code>RunLoop</code> 的线程，其原理在下面会讲到。</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 <code>NSTimer</code> 是<code>toll-free bridged</code>的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 <code>RunLoop</code> 时，<code>RunLoop</code>会注册对应的时间点，当时间点到时，<code>RunLoop</code>会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 <code>Observer</code> 都包含了一个回调（函数指针），当 <code>RunLoop</code> 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</div><div class="line">    kCFRunLoopEntry         = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></div><div class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></div><div class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></div><div class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></div><div class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></div><div class="line">    kCFRunLoopExit          = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的 <code>Source</code>/<code>Timer</code>/<code>Observer</code> 被统称为 <code>__mode item__</code>，一个 <code>item</code> 可以被同时加入多个<code>mode</code>。但一个 <code>item</code> 被重复加入同一个 <code>mode</code> 时是不会有效果的。如果一个 <code>mode</code> 中一个 <code>item</code> 都没有，则 <code>RunLoop</code> 会直接退出，不进入循环。</p>
<h3 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h3><p><code>CFRunLoopMode</code> 和 <code>CFRunLoop</code> 的结构大致如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</div><div class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></div><div class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></div><div class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></div><div class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></div><div class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</div><div class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></div><div class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></div><div class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></div><div class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里有个概念叫 “<code>CommonModes</code>”：一个 <code>Mode</code> 可以将自己标记为”<code>Common</code>”属性（通过将其 <code>ModeName</code> 添加到 <code>RunLoop</code> 的 “<code>commonModes</code>” 中）。每当 <code>RunLoop</code> 的内容发生变化时，<code>RunLoop</code> 都会自动将 <code>_commonModeItems</code> 里的 <code>Source</code>/<code>Observer</code>/<code>Timer</code>同步到具有 “<code>Common</code>” 标记的所有<code>Mode</code>里。</p>
<p>应用场景举例：主线程的 <code>RunLoop</code> 里有两个预置的 <code>Mode</code>：<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>。这两个 <code>Mode</code> 都已经被标记为”<code>Common</code>”属性。<code>DefaultMode</code> 是 <code>App</code> 平时所处的状态，<code>TrackingRunLoopMode</code> 是追踪 <code>ScrollView</code>滑动时的状态。当你创建一个<code>Timer</code>并加到 <code>DefaultMode</code> 时，<code>Timer</code> 会得到重复回调，但此时滑动一个<code>TableView</code>时，<code>RunLoop</code> 会将 <code>mode</code> 切换为 <code>TrackingRunLoopMode</code>，这时 <code>Timer</code> 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个<code>Timer</code>，在两个 <code>Mode</code> 中都能得到回调，一种办法就是将这个 <code>Timer</code> 分别加入这两个 <code>Mode</code>。还有一种方式，就是将 <code>Timer</code> 加入到顶层的 <code>RunLoop</code> 的 “<code>commonModeItems</code>” 中。”<code>commonModeItems</code>” 被 <code>RunLoop</code> 自动更新到所有具有”<code>Common</code>”属性的 <code>Mode</code> 里去。</p>
<p><code>CFRunLoop</code>对外暴露的管理 <code>Mode</code> 接口只有下面2个:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</div><div class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</div></pre></td></tr></table></figure>
<p><code>Mode</code> 暴露的管理 <code>mode item</code> 的接口有下面几个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div><div class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div></pre></td></tr></table></figure>
<p>你只能通过 <code>mode name</code> 来操作内部的 <code>mode</code>，当你传入一个新的 <code>mode name</code> 但 <code>RunLoop</code> 内部没有对应 <code>mode</code> 时，<code>RunLoop</code>会自动帮你创建对应的 <code>CFRunLoopModeRef</code>。对于一个 <code>RunLoop</code> 来说，其内部的 <code>mode</code> 只能增加不能删除。</p>
<p>苹果公开提供的 <code>Mode</code> 有两个：<code>kCFRunLoopDefaultMode</code> (<code>NSDefaultRunLoopMode</code>) 和 <code>UITrackingRunLoopMode</code>，你可以用这两个 <code>Mode Name</code> 来操作其对应的<code>Mode</code>。</p>
<p>同时苹果还提供了一个操作 <code>Common</code> 标记的字符串：<code>kCFRunLoopCommonModes</code> (<code>NSRunLoopCommonModes</code>)，你可以用这个字符串来操作 <code>Common Items</code>，或标记一个 <code>Mode</code> 为 “<code>Common</code>”。使用时注意区分这个字符串和其他 <code>mode name</code>。</p>
<h3 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h3><p>根据苹果在<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="external">文档</a>里的说明，<code>RunLoop</code> 内部的逻辑大致如下:</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_1.png" alt=""></p>
<p>其内部代码整理如下 (太长了不想看可以直接跳过去，后面会有说明)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// 用DefaultMode启动</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/// RunLoop的实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunSpecific</span><span class="params">(runloop, modeName, seconds, stopAfterHandle)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</div><div class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></div><div class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></div><div class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</div><div class="line">    </div><div class="line">    <span class="comment">/// 内部函数，进入loop</span></div><div class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</div><div class="line">        </div><div class="line">        Boolean sourceHandledThisLoop = NO;</div><div class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line"> </div><div class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</div><div class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</div><div class="line">            <span class="comment">/// 执行被加入的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line">            </div><div class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></div><div class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</div><div class="line">            <span class="comment">/// 执行被加入的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line"> </div><div class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></div><div class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</div><div class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</div><div class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></div><div class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</div><div class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></div><div class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></div><div class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></div><div class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></div><div class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</div><div class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</div><div class="line">            </div><div class="line">            <span class="comment">/// 收到消息，处理消息。</span></div><div class="line">            handle_msg:</div><div class="line"> </div><div class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></div><div class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</div><div class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</div><div class="line">            &#125; </div><div class="line"> </div><div class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</div><div class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            &#125; </div><div class="line"> </div><div class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</div><div class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</div><div class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 执行加入到Loop的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line">            </div><div class="line"> </div><div class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></div><div class="line">                retVal = kCFRunLoopRunHandledSource;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</div><div class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></div><div class="line">                retVal = kCFRunLoopRunTimedOut;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</div><div class="line">                <span class="comment">/// 被外部调用者强制停止了</span></div><div class="line">                retVal = kCFRunLoopRunStopped;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</div><div class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></div><div class="line">                retVal = kCFRunLoopRunFinished;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></div><div class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></div><div class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h3><p>从上面代码可以看到，<code>RunLoop</code> 的核心是基于 <code>mach port</code> 的，其进入休眠时调用的函数是 <code>mach_msg()</code>。为了解释这个逻辑，下面稍微介绍一下 <code>OSX/iOS</code> 的系统架构。</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_3.png" alt=""></p>
<p>苹果官方将整个系统大致划分为上述4个层次：<br>应用层包括用户能接触到的图形应用，例如 <code>Spotlight</code>、<code>Aqua</code>、<code>SpringBoard</code> 等。<br>应用框架层即开发人员接触到的 <code>Cocoa</code>等框架。<br>核心框架层包括各种核心框架、<code>OpenGL</code> 等内容。<br><code>Darwin</code> 即操作系统的核心，包括系统内核、驱动、<code>Shell</code> 等内容，这一层是开源的，其所有源码都可以在 <a href="https://opensource.apple.com/" target="_blank" rel="external">opensource.apple.com</a> 里找到。</p>
<p><strong>我们在深入看一下 Darwin 这个核心的架构：</strong></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_4.png" alt=""></p>
<p>其中，在硬件层上面的三个组成部分：<code>Mach</code>、<code>BSD</code>、<code>IOKit</code> (还包括一些上面没标注的内容)，共同组成了 <code>XNU</code> 内核。<br><code>XNU</code> 内核的内环被称作 <code>Mach</code>，其作为一个微内核，仅提供了诸如处理器调度、<code>IPC</code> (进程间通信)等非常少量的基础服务。<br><code>BSD</code> 层可以看作围绕 <code>Mach</code> 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。<br><code>IOKit</code> 层是为设备驱动提供了一个面向对象(<code>C++</code>)的一个框架。</p>
<p><code>Mach</code> 本身提供的 <code>API</code> 非常有限，而且苹果也不鼓励使用 <code>Mach</code> 的 <code>API</code>，但是这些<code>API</code>非常基础，如果没有这些<code>API</code>的话，其他任何工作都无法实施。在 <code>Mach</code> 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， <code>Mach</code> 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”<code>消息</code>”是 <code>Mach</code> 中最基础的概念，消息在两个端口 (<code>port</code>) 之间传递，这就是 <code>Mach</code> 的 <code>IPC</code> (进程间通信) 的核心。</p>
<p><code>Mach</code> 的消息定义是在 <code>&lt;mach/message.h&gt;</code> 头文件的，很简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">  <span class="keyword">mach_msg_header_t</span> header;</div><div class="line">  <span class="keyword">mach_msg_body_t</span> body;</div><div class="line">&#125; <span class="keyword">mach_msg_base_t</span>;</div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">  <span class="keyword">mach_msg_bits_t</span> msgh_bits;</div><div class="line">  <span class="keyword">mach_msg_size_t</span> msgh_size;</div><div class="line">  <span class="keyword">mach_port_t</span> msgh_remote_port;</div><div class="line">  <span class="keyword">mach_port_t</span> msgh_local_port;</div><div class="line">  <span class="keyword">mach_port_name_t</span> msgh_voucher_port;</div><div class="line">  <span class="keyword">mach_msg_id_t</span> msgh_id;</div><div class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</div></pre></td></tr></table></figure>
<p>一条 <code>Mach</code> 消息实际上就是一个二进制数据包 (<code>BLOB</code>)，其头部定义了当前端口 <code>local_port</code> 和目标端口 <code>remote_port</code>，发送和接受消息是通过同一个 <code>API</code> 进行的，其 <code>option</code> 标记了消息传递的方向：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">mach_msg_return_t</span> mach_msg(</div><div class="line">			<span class="keyword">mach_msg_header_t</span> *msg,</div><div class="line">			<span class="keyword">mach_msg_option_t</span> option,</div><div class="line">			<span class="keyword">mach_msg_size_t</span> send_size,</div><div class="line">			<span class="keyword">mach_msg_size_t</span> rcv_size,</div><div class="line">			<span class="keyword">mach_port_name_t</span> rcv_name,</div><div class="line">			<span class="keyword">mach_msg_timeout_t</span> timeout,</div><div class="line">			<span class="keyword">mach_port_name_t</span> notify);</div></pre></td></tr></table></figure>
<p>为了实现消息的发送和接收，<code>mach_msg()</code> 函数实际上是调用了一个 <code>Mach</code> 陷阱 <code>(trap)</code>，即函数<code>mach_msg_trap()</code>，陷阱这个概念在 <code>Mach</code> 中等同于系统调用。当你在用户态调用<code>mach_msg_trap()</code> 时会触发陷阱机制，切换到内核态；内核态中内核实现的 <code>mach_msg()</code> 函数会完成实际的工作，如下图：</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_5.png" alt=""></p>
<p>这些概念可以参考维基百科: <a href="http://en.wikipedia.org/wiki/System_call" target="_blank" rel="external">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing" target="_blank" rel="external">Trap_(computing)</a>)。</p>
<p><code>RunLoop</code> 的核心就是一个 <code>mach_msg()</code> (见上面代码的第7步)，<code>RunLoop</code> 调用这个函数去接收消息，如果没有别人发送 <code>port</code> 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 <code>iOS</code> 的 <code>App</code>，然后在 <code>App</code> 静止时点击暂停，你会看到主线程调用栈是停留在 <code>mach_msg_trap()</code> 这个地方。</p>
<p>关于具体的如何利用 <code>mach port</code> 发送信息，可以看看 <a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="external">NSHipster 这一篇文章</a>，或者<a href="http://segmentfault.com/a/1190000002400329" target="_blank" rel="external">这里</a>的中文翻译.</p>
<p>关于<code>Mach</code>的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/" target="_blank" rel="external">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>
<h3 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h3><p>首先我们可以看一下<code>App</code>启动后<code>RunLoop</code>的状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">CFRunLoop &#123;</div><div class="line">    current mode = kCFRunLoopDefaultMode</div><div class="line">    common modes = &#123;</div><div class="line">        UITrackingRunLoopMode</div><div class="line">        kCFRunLoopDefaultMode</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    common mode items = &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// source0 (manual)</span></div><div class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = PurpleEventSignalCallback &#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</div><div class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// source1 (mach port)</span></div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = PurpleEventCallback&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</div><div class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</div><div class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1b</span>03,</div><div class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</div><div class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// Ovserver</span></div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></div><div class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></div><div class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _afterCACommitHandler&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// Timer</span></div><div class="line">        CFRunLoopTimer &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</div><div class="line">            next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</div><div class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</div><div class="line">    &#125;,</div><div class="line"> </div><div class="line">    modes ＝ &#123;</div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 = &#123;</div><div class="line">                CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</div><div class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            sources1 = (null),</div><div class="line">            observers = &#123;</div><div class="line">                CFRunLoopObserver &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</div><div class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</div><div class="line">            )&#125;,</div><div class="line">            timers = (null),</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 = &#123;</div><div class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</div><div class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            sources1 = &#123;</div><div class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</div><div class="line">                    callout = PurpleEventCallback&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            observers = (null),</div><div class="line">            timers = (null),</div><div class="line">        &#125;,</div><div class="line">        </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 = (null),</div><div class="line">            sources1 = (null),</div><div class="line">            observers = (null),</div><div class="line">            timers = (null),</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，系统默认注册了5个`Mode:</p>
<ol>
<li><code>kCFRunLoopDefaultMode</code>: <code>App</code>的默认 <code>Mode</code>，通常主线程是在这个 <code>Mode</code> 下运行的。</li>
<li><code>UITrackingRunLoopMode</code>: 界面跟踪 <code>Mode</code>，用于 <code>ScrollView</code> 追踪触摸滑动，保证界面滑动时不受其他 <code>Mode</code> 影响。</li>
<li><code>UIInitializationRunLoopMode</code>: 在刚启动 <code>App</code> 时第进入的第一个 <code>Mode</code>，启动完成后就不再使用。</li>
<li><code>GSEventReceiveRunLoopMode</code>: 接受系统事件的内部 <code>Mode</code>，通常用不到。</li>
<li><code>kCFRunLoopCommonModes</code>: 这是一个占位的 <code>Mode</code>，没有实际作用。</li>
</ol>
<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="external">这里</a>看到更多的苹果内部的 <code>Mode</code>，但那些 <code>Mode</code> 在开发中就很难遇到了。</p>
<p>当 <code>RunLoop</code> 进行回调时，一般都是通过一个很长的函数调用出去 (<code>call out</code>), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">/// 1. 通知Observers，即将进入RunLoop</span></div><div class="line">    <span class="comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></div><div class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line"> </div><div class="line">        <span class="comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</div><div class="line">        <span class="comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line"> </div><div class="line">        <span class="comment">/// 4. 触发 Source0 (非基于port的) 回调。</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line"> </div><div class="line">        <span class="comment">/// 6. 通知Observers，即将进入休眠</span></div><div class="line">        <span class="comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</div><div class="line"> </div><div class="line">        <span class="comment">/// 7. sleep to wait msg.</span></div><div class="line">        mach_msg() -&gt; mach_msg_trap();</div><div class="line">        </div><div class="line"> </div><div class="line">        <span class="comment">/// 8. 通知Observers，线程被唤醒</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</div><div class="line"> </div><div class="line">        <span class="comment">/// 9. 如果是被Timer唤醒的，回调Timer</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</div><div class="line"> </div><div class="line">        <span class="comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></div><div class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</div><div class="line"> </div><div class="line">        <span class="comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></div><div class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</div><div class="line"> </div><div class="line"> </div><div class="line">    &#125; <span class="keyword">while</span> (...);</div><div class="line"> </div><div class="line">    <span class="comment">/// 10. 通知Observers，即将退出RunLoop</span></div><div class="line">    <span class="comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></div><div class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>App启动后，苹果在主线程 <code>RunLoop</code> 里注册了两个 <code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<p>第一个 <code>Observer</code> 监视的事件是 <code>Entry</code>(即将进入<code>Loop</code>)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 <code>order</code> 是<code>-2147483647</code>，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 <code>Observer</code> 监视了两个事件： <code>BeforeWaiting</code>(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；<code>Exit</code>(即将退出<code>Loop</code>) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 <code>Observer</code> 的 <code>order</code> 是 <code>2147483647</code>，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、<code>Timer</code>回调内的。这些回调会被 <code>RunLoop</code> 创建好的 <code>AutoreleasePool</code> 环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>Pool</code> 了。</p>
<h4 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h4><p>苹果注册了一个 <code>Source1</code> (基于 <code>mach port</code> 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 <code>IOHIDEvent</code> 事件并由 <code>SpringBoard</code> 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="external">这里</a>。<code>SpringBoard</code> 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 <code>Event</code>，随后用 <code>mach port</code> 转发给需要的<code>App</code>进程。随后苹果注册的那个 <code>Source1</code> 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p>
<p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent</code> 处理并包装成 <code>UIEvent</code> 进行处理或分发，其中包括识别 <code>UIGesture</code>/<code>处理屏幕旋转</code>/发送给 <code>UIWindow</code> 等。通常事件比如 <code>UIButton</code> 点击、<code>touchesBegin</code>/<code>Move</code>/<code>End</code>/<code>Cancel</code> 事件都是在这个回调中完成的。</p>
<h4 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h4><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 <code>Cancel</code> 将当前的 <code>touchesBegin</code>/<code>Move</code>/<code>End</code> 系列回调打断。随后系统将对应的 <code>UIGestureRecognizer</code> 标记为待处理。</p>
<p>苹果注册了一个 <code>Observer</code> 监测 <code>BeforeWaiting</code> (<code>Loop</code>即将进入休眠) 事件，这个<code>Observer</code>的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 <code>GestureRecognizer</code>，并执行<code>GestureRecognizer</code>的回调。</p>
<p>当有 <code>UIGestureRecognizer</code> 的变化(<code>创建</code>/<code>销毁</code>/<code>状态改变</code>)时，这个回调都会进行相应处理。</p>
<h4 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h4><p>当在操作 <code>UI</code> 时，比如改变了 <code>Frame</code>、更新了 <code>UIView</code>/<code>CALayer</code> 的层次时，或者手动调用了 <code>UIView</code>/<code>CALayer</code> 的 <code>setNeedsLayout</code>/<code>setNeedsDisplay</code>方法后，这个 <code>UIView</code>/<code>CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 <code>Observer</code> 监听 <code>BeforeWaiting</code>(即将进入休眠) 和 <code>Exit</code> (即将退出<code>Loop</code>) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 <code>UIView</code>/<code>CAlayer</code> 以执行实际的绘制和调整，并更新 <code>UI</code> 界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</div><div class="line">    QuartzCore:CA::Transaction::observer_callback:</div><div class="line">        CA::Transaction::commit();</div><div class="line">            CA::Context::commit_transaction();</div><div class="line">                CA::Layer::layout_and_display_if_needed();</div><div class="line">                    CA::Layer::layout_if_needed();</div><div class="line">                        [CALayer layoutSublayers];</div><div class="line">                            [UIView layoutSubviews];</div><div class="line">                    CA::Layer::display_if_needed();</div><div class="line">                        [CALayer display];</div><div class="line">                            [UIView drawRect];</div></pre></td></tr></table></figure>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p><code>NSTimer</code> 其实就是 <code>CFRunLoopTimerRef</code>，他们之间是 <code>toll-free bridged</code> 的。一个 <code>NSTimer</code> 注册到 <code>RunLoop</code> 后，<code>RunLoop</code> 会为其重复的时间点注册好事件。例如 <code>10:00</code>, <code>10:10</code>, <code>10:20</code> 这几个时间点。<code>RunLoop</code>为了节省资源，并不会在非常准确的时间点回调这个<code>Timer</code>。<code>Timer</code> 有个属性叫做 <code>Tolerance</code> (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 <code>10:10</code> 时我忙着玩手机错过了那个点的公交，那我只能等 <code>10:20</code> 这一趟了。</p>
<p><code>CADisplayLink</code> 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 <code>NSTimer</code> 并不一样，其内部实际是操作了一个 <code>Source</code>）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 <code>NSTimer</code> 相似），造成界面卡顿的感觉。在快速滑动<code>TableView</code>时，即使一帧的卡顿也会让用户有所察觉。<code>Facebook</code> 开源的<code>AsyncDisplayLink</code> 就是为了解决界面卡顿的问题，其内部也用到了 <code>RunLoop</code>，这个稍后我会再单独写一页博客来分析。</p>
<h4 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h4><p>当调用 <code>NSObject</code> 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 <code>Timer</code> 并添加到当前线程的 <code>RunLoop</code> 中。所以如果当前线程没有 <code>RunLoop</code>，则这个方法会失效。</p>
<p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 <code>Timer</code> 加到对应的线程去，同样的，如果对应线程没有 <code>RunLoop</code> 该方法也会失效。</p>
<h4 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h4><p>实际上 <code>RunLoop</code> 底层也会用到 GCD 的东西， 例如 <code>dispatch_async()</code>。</p>
<blockquote>
<p>NSTimer 是用了 XNU 内核的 <code>mk_timer</code>来驱动的，而非 GCD 驱动的.</p>
</blockquote>
<p>当调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code> 时，<code>libDispatch</code> 会向主线程的 <code>RunLoop</code> 发送消息，RunLoop会被唤醒，并从消息中取得这个 <code>block</code>，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 <code>block</code>。但这个逻辑仅限于 <code>dispatch</code> 到主线程，<code>dispatch</code> 到其他线程仍然是由 <code>libDispatch</code> 处理的。</p>
<h4 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h4><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">CFSocket</div><div class="line">CFNetwork       -&gt;ASIHttpRequest</div><div class="line">NSURLConnection -&gt;AFNetworking</div><div class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</div></pre></td></tr></table></figure>
<ul>
<li><code>CFSocket</code> 是最底层的接口，只负责 <code>socket</code> 通信。</li>
<li><code>CFNetwork</code> 是基于 <code>CFSocket</code> 等接口的上层封装，<code>ASIHttpRequest</code> 工作于这一层。</li>
<li><code>NSURLConnection</code> 是基于 <code>CFNetwork</code> 的更高层的封装，提供面向对象的接口，<code>AFNetworking</code>工作于这一层。</li>
<li><code>NSURLSession</code> 是 <code>iOS7</code> 中新增的接口，表面上是和 <code>NSURLConnection</code>并列的，但底层仍然用到了 <code>NSURLConnection</code> 的部分功能 (比如 <code>com.apple.NSURLConnectionLoader</code> 线程)，<code>AFNetworking2</code> 和 <code>Alamofire</code> 工作于这一层。</li>
</ul>
<h5 id="下面主要介绍下-NSURLConnection-的工作过程。"><a href="#下面主要介绍下-NSURLConnection-的工作过程。" class="headerlink" title="下面主要介绍下 NSURLConnection 的工作过程。"></a>下面主要介绍下 NSURLConnection 的工作过程。</h5><p>通常使用 <code>NSURLConnection</code>时，你会传入一个 <code>Delegate</code>，当调用了 <code>[connection start]</code> 后，这个 <code>Delegate</code> 就会不停收到事件回调。实际上，<code>start</code> 这个函数的内部会会获取 <code>CurrentRunLoop</code>，然后在其中的 <code>DefaultMode</code> 添加了4个 <code>Source0</code>(即需要手动触发的<code>Source</code>)。<code>CFMultiplexerSource</code> 是负责各种 <code>Delegate</code> 回调的，<code>CFHTTPCookieStorage</code> 是处理各种 <code>Cookie</code> 的。</p>
<p>当开始网络传输时，我们可以看到 <code>NSURLConnection</code> 创建了两个新线程：<code>com.apple.NSURLConnectionLoader</code> 和 <code>com.apple.CFSocket.private</code>。其中 <code>CFSocket</code> 线程是处理底层 <code>socket</code> 连接的。<code>NSURLConnectionLoader</code> 这个线程内部会使用 <code>RunLoop</code> 来接收底层 <code>socket</code> 的事件，并通过之前添加的 <code>Source0</code> 通知到上层的 <code>Delegate</code>。</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/4c86bd0822184191d50271b4dfbd1b8f185a08d2/20180402RunLoop/RunLoop_network.png" alt=""></p>
<p><code>NSURLConnectionLoader</code> 中的 <code>RunLoop</code> 通过一些基于 <code>mach port</code> 的<code>Source</code> 接收来自底层 <code>CFSocket</code> 的通知。当收到通知后，其会在合适的时机向 <code>CFMultiplexerSource</code> 等 <code>Source0</code> 发送通知，同时唤醒 <code>Delegate</code> 线程的 <code>RunLoop</code> 来让其处理这些通知。<code>CFMultiplexerSource</code> 会在 <code>Delegate</code> 线程的 <code>RunLoop</code> 对 <code>Delegate</code> 执行实际的回调。</p>
<h3 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h3><h4 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h4><p><a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m" target="_blank" rel="external">AFURLConnectionOperation</a> 这个类是基于 <code>NSURLConnection</code> 构建的，其希望能在后台线程接收 <code>Delegate</code> 回调。为此 <code>AFNetworking</code>单独创建了一个线程，并在这个线程中启动了一个 <code>RunLoop</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</div><div class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</div><div class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line">        [runLoop run];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</div><div class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</div><div class="line">        [_networkRequestThread start];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _networkRequestThread;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>RunLoop</code> 启动前内部必须要有至少一个 <code>Timer</code>/<code>Observer</code>/<code>Source</code>，所以 <code>AFNetworking</code> 在 <code>[runLoop run]</code> 之前先创建了一个新的 <code>NSMachPort</code> 添加进去了。通常情况下，调用者需要持有这个 <code>NSMachPort</code> (<code>mach_port</code>) 并在外部线程通过这个 <code>port</code> 发送消息到 <code>loop</code> 内；但此处添加 <code>port</code> 只是为了让 <code>RunLoop</code> 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    [<span class="keyword">self</span>.lock lock];</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</div><div class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</div><div class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</div><div class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当需要这个后台线程执行任务时，<code>AFNetworking</code> 通过调用 <code>[NSObject performSelector:onThread:..]</code> 将这个任务扔到了后台线程的 <code>RunLoop</code> 中。</p>
<h4 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h4><p><a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p><code>UI</code> 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：<code>排版</code>，<code>绘制</code>，<code>UI对象操作</code>。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 <code>CoreText</code>)、图片绘制 (例如预先解压)、元素绘制 (<code>Quartz</code>)等操作。<br><code>UI</code>对象操作通常包括 <code>UIView</code>/<code>CALayer</code> 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如<code>TextView</code>创建时可能需要提前计算出文本的大小）。<code>ASDK</code> 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，<code>ASDK</code> 创建了一个名为 <code>ASDisplayNode</code> 的对象，并在内部封装了 <code>UIView</code>/<code>CALayer</code>，它具有和 <code>UIView</code>/<code>CALayer</code> 相似的属性，例如 <code>frame</code>、<code>backgroundColor</code>等。所有这些属性都可以在后台线程更改，开发者可以只通过 <code>Node</code> 来操作其内部的 <code>UIView</code>/<code>CALayer</code>，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 <code>UIView</code>/<code>CALayer</code> 去。</p>
<p><code>ASDK</code> 仿照 <code>QuartzCore</code>/<code>UIKit</code> 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 <code>RunLoop</code> 中添加一个 <code>Observer</code>，监听了 <code>kCFRunLoopBeforeWaiting</code> 和 <code>kCFRunLoopExit</code> 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。<br>具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m" target="_blank" rel="external">_ASAsyncTransactionGroup</a>。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><code>RunLoop</code> 需要深入理解</p>
<p>全文完</p>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="external">参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/0fa4569bca7b3a2d5c1ee360f47ac1dd213ecbac/20180402Run
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 4 中的数组技巧</title>
    <link href="https://www.sunyazhou.com/2018/03/14/20180314Swft4-Array-skills/"/>
    <id>https://www.sunyazhou.com/2018/03/14/20180314Swft4-Array-skills/</id>
    <published>2018-03-14T02:17:56.000Z</published>
    <updated>2018-03-14T12:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>年前买了本<a href="https://objccn.io/products/advanced-swift/" target="_blank" rel="external">Swift 进阶</a>(swift4.0),过完年回来正在一点点学习,不得不说喵神写的东西还是不错的,￥69元对广大程序员来说已经不算啥了.如果感兴趣可以买一本,真心不错</p>
<p>当我从头来学习数组的时候发现好多函数真的太有用了</p>
<h2 id="Swift-4-0-中的可变数组技巧"><a href="#Swift-4-0-中的可变数组技巧" class="headerlink" title="Swift 4.0 中的可变数组技巧"></a>Swift 4.0 中的可变数组技巧</h2><p>我们可用 Xcode 创建playground 来进行练习</p>
<p><strong>首先创建个数组</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> array = <span class="type">NSMutableArray</span>(array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> , <span class="number">5</span>, <span class="number">6</span>])</div></pre></td></tr></table></figure>
<p><strong>for in 循环遍历</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array &#123;</div><div class="line">    <span class="built_in">print</span>(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">1 2 3 4 5 6</div></pre></td></tr></table></figure>
<p><strong>想要扣除第一个元素剩余的元素进行迭代遍历呢？</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array.<span class="built_in">dropFirst</span>()&#123;</div><div class="line">    <span class="built_in">print</span>(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">2 3 4 5 6</div></pre></td></tr></table></figure>
<blockquote>
<p>dropFirst() 函数参数是可以添加数值的  for x in array.dropFirst(3) 打印:4 5 6.</p>
</blockquote>
<p>有 <code>first</code> 的地方基本就有<code>last</code></p>
<p><strong>想要扣除最后 3 个元素以外的元素进行遍历？</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array.<span class="built_in">dropLast</span>(<span class="number">3</span>)&#123;</div><div class="line">    <span class="built_in">print</span>(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">1 2 3</div></pre></td></tr></table></figure>
<p><strong>带下标和数组元素遍历</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (num, element) <span class="keyword">in</span> array.enumerated() &#123;</div><div class="line">    <span class="built_in">print</span>(num, element)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印 左边下标 右边元素</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">0 1</div><div class="line">1 2</div><div class="line">2 3</div><div class="line">3 4</div><div class="line">4 5</div><div class="line">5 6</div></pre></td></tr></table></figure>
<blockquote>
<p>左边下标 右边元素</p>
</blockquote>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;年前买了本&lt;a href=&quot;https://objccn.io/products/advanced-swift/&quot; target=&quot;_bla
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>什么是符号表?</title>
    <link href="https://www.sunyazhou.com/2018/03/08/20180308What-is-the-dSYM/"/>
    <id>https://www.sunyazhou.com/2018/03/08/20180308What-is-the-dSYM/</id>
    <published>2018-03-08T03:14:12.000Z</published>
    <updated>2018-03-11T23:32:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/home_page_log.jpeg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS 开发中经常回定位 bug 通过崩溃堆栈,此时我们需要借助符号表来恢复内存地址对应代码调用信息,为了解开这个大家耳熟能详却总有人问的问题的面纱,我在 bugle 平台和一些文章中收集了相关知识整理出来,以便后续方便记忆.</p>
<h2 id="本周主要内容如下"><a href="#本周主要内容如下" class="headerlink" title="本周主要内容如下"></a>本周主要内容如下</h2><ul>
<li>什么是符号表？</li>
<li>为什么要配置符号表？</li>
<li>dSYM文件？</li>
</ul>
<h3 id="什么是符号表？"><a href="#什么是符号表？" class="headerlink" title="什么是符号表？"></a>什么是符号表？</h3><p>符号表是内存地址与函数名、文件名、行号的映射表。符号表元素如下所示：</p>
<p><code>&lt;起始地址&gt;</code> <code>&lt;结束地址&gt;</code> <code>&lt;函数&gt;</code> [<code>&lt;文件名&gt;</code>:<code>&lt;行号&gt;</code>]  </p>
<h3 id="为什么要配置符号表？"><a href="#为什么要配置符号表？" class="headerlink" title="为什么要配置符号表？"></a>为什么要配置符号表？</h3><p>为了能快速并准确地定位用户APP发生<code>Crash</code>的代码<code>位置</code>，我们可以使用符号表对APP发生<code>Crash</code>的程序<code>堆栈</code>进行<code>解析</code>和<code>还原</code>。</p>
<p>举一个例子：</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/f84e46105c453408a030c50d802695917bf5ea4c/20180308What-is-the-dSYM/stack_symbol.png" alt=""></p>
<p>上图是我们通过符号表来解析出来崩溃堆栈的调用</p>
<h3 id="什么是dSYM文件？"><a href="#什么是dSYM文件？" class="headerlink" title="什么是dSYM文件？"></a>什么是dSYM文件？</h3><p>iOS平台中，<code>dSYM</code>文件是指具有调试信息的目标文件，文件名通常为： <code>com.公司名.dSYM</code>。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/test_dSYM.png" alt=""></p>
<p>一般都是和Xcode 工程名的 aget一样的名字</p>
<blockquote>
<p>为了方便找回Crash对应的dSYM文件和还原堆栈，建议每次构建或者发布APP版本的时候，备份好dSYM文件</p>
</blockquote>
<h4 id="如何定位dSYM文件？"><a href="#如何定位dSYM文件？" class="headerlink" title="如何定位dSYM文件？"></a>如何定位dSYM文件？</h4><p>一般情况下，项目编译完<code>dSYM</code>文件跟<code>app</code>文件在同一个目录下，下面以<code>XCode</code>作为IDE详细说明定位<code>dSYM</code>文件</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/dSYM1%402x.png" alt=""></p>
<p><img src="https://github.com/sunyazhou13/sunyazhou13.github.io-images/blob/master/20180308What-is-the-dSYM/dSYM2@2x.png?raw=true" alt=""></p>
<blockquote>
<p>这里用 release 模式做的测试 </p>
</blockquote>
<p>我们看到 和工程 <code>target</code>一样的名称的 <code>.dSYM</code>.</p>
<h4 id="XCode编译后没有生成dSYM文件"><a href="#XCode编译后没有生成dSYM文件" class="headerlink" title="XCode编译后没有生成dSYM文件?"></a>XCode编译后没有生成dSYM文件?</h4><p>XCode在 <code>Release</code>编译环境下默认会生成<code>dSYM</code>文件，而<code>Debug</code>编译环境下默认不会生成</p>
<p>如果要在<code>Debug</code>对应的<code>Xcode</code>配置如下:</p>
<p><code>XCode -&gt; Build Settings -&gt; Code Generation -&gt; Generate Debug Symbols -&gt; Yes</code><br><code>XCode -&gt; Build Settings -&gt; Build Option -&gt; Debug Information Format -&gt; DWARF with dSYM File</code></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/dsym3%402x.png" alt=""><br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/dsym4%402x.png" alt=""></p>
<h4 id="开启Bitcode之后需要注意哪些问题"><a href="#开启Bitcode之后需要注意哪些问题" class="headerlink" title="开启Bitcode之后需要注意哪些问题?"></a>开启Bitcode之后需要注意哪些问题?</h4><ul>
<li>在点<code>Upload to App Store</code>上传到<code>App Store</code>服务器的时候需要声明符号文件(<code>dSYM</code>文件)的生成:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/3d0ace06f1a780aa3691cc55af98d2403a7cfce1/20180308What-is-the-dSYM/dsym5.jpg" alt=""></p>
<ul>
<li>在配置符号表文件之前，需要从App Store中把该版本对应的dSYM文件下载回本地,然后用符号表工具生成和上传符号表文件。</li>
</ul>
<p>这里找回<code>ipa</code>版本对应的dSYM文件有两种方式</p>
<ol>
<li><p>通过Xcode的归档文件找回dSYM,打开<code>Xcode</code> 顶部菜单栏 -&gt; <code>Window</code> -&gt; <code>Organizer</code> 窗口,如下图:<br> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/BitcodedSYM-2.jpg" alt=""><br> 打开 <code>Xcode</code> 顶部菜单栏，选择<code>Archive</code> 标签:<br> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/BitcodedSYM-3.jpg" alt=""><br> 找到发布的归档包，右键点击对应归档包，选择<code>Show in Finder</code>操作:<br> <img src="https://bugly.qq.com/docs/img/symbol-ios/BitcodedSYM-4.jpg?v=20180119105842" alt=""><br> 右键选择定位到的归档文件，选择显示包内容操作:<br> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/BitcodedSYM-5.jpg" alt=""><br> 选择<code>dSYMs</code>目录，目录内即为下载到的 <code>dSYM</code> 文件:<br> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/BitcodedSYM-6.jpg" alt=""></p>
</li>
<li><p>通过<a href="https://itunesconnect.apple.com/" target="_blank" rel="external">iTunes Connect</a>找回</p>
<p> <img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/757ac10eb4448e952a1f9b42d71073de424da159/20180308What-is-the-dSYM/itunes_connect%402x.png" alt=""></p>
<p> 在“所有构件版本（All Builds）”中选择某一个版本，点“下载<code>dSYM</code>（Download dSYM）”下载dSYM文件.</p>
</li>
</ol>
<blockquote>
<p>注意:<em>一个<code>Archiver</code>与<code>dSYM</code>文件一一对应,搞错了容易翻译不出来来源码的调用</em></p>
</blockquote>
<p>参考如下:</p>
<p><a href="https://bugly.qq.com/docs/user-guide/symbol-configuration-ios/?v=1520478187041#dsym_1" target="_blank" rel="external">Bugly iOS 符号表配置</a><br><a href="https://techblog.toutiao.com/2017/07/05/session413/" target="_blank" rel="external">App 启动时间：过去，现在和未来</a></p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180308What-is-the-dSYM/home_page_log.jpeg&quot; 
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形渲染的流程</title>
    <link href="https://www.sunyazhou.com/2018/03/05/20180305Computer-graphics-rendering-process/"/>
    <id>https://www.sunyazhou.com/2018/03/05/20180305Computer-graphics-rendering-process/</id>
    <published>2018-03-05T04:11:41.000Z</published>
    <updated>2018-03-05T13:00:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180305Computer-graphics-rendering-process/%20Ivan-Sutherland.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在网上找到了一篇有价值的文章,来说明计算机中的图像渲染流程以及像素点计算和坐标点相关的知识.</p>
<h2 id="计算机图形渲染的流程"><a href="#计算机图形渲染的流程" class="headerlink" title="计算机图形渲染的流程"></a>计算机图形渲染的流程</h2><p>计算机的绘图过程可以简单用流水线来说明，而产品(数据)就是经过流水线作业(渲染)到屏幕的图像。这条流水线可以简化为(本文的概念):绘图位置座标指定;着色指定;输出指定;下图简单解释了这一个流水线过程。计算机绘图需要一个输入绘图数据，这个数据可以是用户指定的，也可以是操作系统决定的，也可以是混合的。这些数据是分组的。</p>
<ul>
<li>座标生成：当绘图数据送入座标生成系统后，流水线就会对其进行座标分派，图1右上的线框图抽象描述了这个过程。</li>
<li>着色指定：当座标系统生成出带座标的绘图数据后就需要送入着色器，着色器指定了这些线框的填充颜色或纹理。</li>
<li>渲染：着色器将绘图数据加上着色数据后就被送入渲染器，渲染器根据绘图数据描述，将像素填充到描述的线框组里并送入帧缓存，然后然后送入显示器，显示器获取到帧缓存的数据后再根据数据的描述来绘图到屏幕上。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180305Computer-graphics-rendering-process/render1.png" alt=""></p>
<h2 id="像素与点（point）与点（dot）"><a href="#像素与点（point）与点（dot）" class="headerlink" title="像素与点（point）与点（dot）"></a>像素与点（point）与点（dot）</h2><p>像素与点（point），点（dot）这三个单位很容易令人混淆，原因在于它们在很多场合上是可以互换的。但是本文需要区分这两者的概念。</p>
<p>像素指的是一种数据结构，这个数据结构包含了RGB三个数据，分别对应的是红色，绿色，蓝色。我们说一张计算机生成的位图时，我们会说这图是多少像素x多少像素，例如800x600像素。值得注意的是，像素没有一个固定的尺寸单位，它只是一个抽象概念。</p>
<p>点（dot）指的是显示器屏幕的点或打印的点，是具体指代的事物。我们想说的DPI即dot per inch，每英寸多少个点。一般来说1个点对应一个像素，常见的打印尺寸是72DPI，即每英寸72点，也就是包含72个像素的数据。当像素被计算机输出成点投射都屏幕或纸面上时，它才具备了尺寸的概念，即点（dot）。</p>
<p>点（point）指的是座标点，是一个数据结构，包含了两个数据（或三个）X和Y(和Z)座标。绘图数据里是包含了这个座标数据的。对于没有使用HiDPI的操作系统来说，一个座标点对应一个像素。</p>
<h2 id="点（point）不一定等于像素"><a href="#点（point）不一定等于像素" class="headerlink" title="点（point）不一定等于像素"></a>点（point）不一定等于像素</h2><p>一般来说，点（dot）与像素是可以互换指代的，而且我们在Retina的概念被提出前一直这样使用它们。但是，现在这两个概念必须要区分出来。像素只是一个描述RGB的数据结构，它没有任何尺寸单位，它更不是一个矩形。当像素被输出到屏幕或纸张上时，我们应该用点来指代这种含有颜色，有尺寸的具体事物。</p>
<p>普通的显示屏幕或打印机，我们会说屏幕上的一个点（dot）是由一个像素（RGB数据）组成的，打印后的点是由一个像素经过色彩转换（CMYK数据）组成的。</p>
<p>对于打印机来说，一般的DPI是72。也就是指我们在显示器屏幕上看到720x720像素的位图，在打印出来后的面积是10x10英寸，但是屏幕上的位图面积并不会跟打印出来的面积一致。因为屏幕上的一个点与打印的点的尺寸不一样。</p>
<p>PPI指的是每英寸多少像素，与DPI有一定概念上的区别。PPI一般指的是屏幕的点密度，DPI指的是打印点的密度。PPI不是固定的，不同屏幕尺寸结合不同的分辨率会有不同的PPI，但是DPI则是相对固定在72。</p>
<p>HiDPI是苹果的一项绘图技术，结合这种技术，计算机座标系统上的一个点（point）不再对应一个像素，一般来说会是一个座标点对应四个像素，而一个像素对应屏幕的一个物理点（dot）。</p>
<p>由于像素是一组色彩数据，所以绘图数据在经过着色器后才包含了它。举个例子，绘图数据在送入着色器前是描述一个100x100的矩形，经过着色器指定色彩属性后会被送入一个HiDPI系统，这个系统将200x200个像素的数据添加到绘图数据里。在经过渲染器后，相当于将200x200个像素填充进100x100这个矩形线框。</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180305Computer-graphics-rendering-process/render2.png" alt=""></p>
<h2 id="帧缓存与显示器屏幕"><a href="#帧缓存与显示器屏幕" class="headerlink" title="帧缓存与显示器屏幕"></a>帧缓存与显示器屏幕</h2><p>帧缓存是储存计算机渲染后的图形数据的，这些数据包括座标，像素，分辨率等等。。简单来说就是描述图象的数据，当这些描述数据送入显示器后，显示器就知道怎么绘图了。</p>
<p>一般来说的屏幕分辨率指的是渲染器生产出来的像素数据排列，例如1280x800像素。值得注意的是这个屏幕分辨率与显示器屏幕的物理点排列没关系的。屏幕分辨率是可设置的，显示器的物理点排列是固定的。例如帧缓存里的分辨率是1280x800像素，但是显示器屏幕是1920x1200点排列的，那么显示器会怎么将帧缓存里的数据呈现到屏幕上呢？答案是通过自适应放缩，是经过显示器内部芯片来转换的。</p>
<p>13寸的RMBP在分辨率设置里是这样描述的，看起来像1280x800像素，看起来像1440x900像素。我们需要这样理解，1280x800像素是相对于旧款不带Retina的机器，也就是绘图数据送入着色器前的座标系统与渲染后的座标是1:1对应的参考值。实际上在经过渲染后，它的实际像素是2560x1600，也就是帧缓存里是数据是2560x1600像素。同样地看起来1440x900像素实际渲染后的像素是2880x1800。由于13寸的屏幕实际点排列是2560x1600，所以帧缓存2880x1800像素在输出到屏幕后会被自适应缩放掉。</p>
<h2 id="DPI与Retina"><a href="#DPI与Retina" class="headerlink" title="DPI与Retina"></a>DPI与Retina</h2><p>操作系统标准的桌面打印DPI是72，但是随着HiDPI技术和高PPI屏幕出现后，这个标准也许会有一定的变化。我们在Retina的OS X下用Photoshop新建一个文件时默认的DPI指定在144上了，这是标准转变的一个信号。</p>
<p>在没有使用类似HiDPI技术的操作系统上，屏幕分辨率对应的打印DPI是72。使用HiDPI的Retina机器的打印DPI是144，用以保证在统一尺下具有更多的点密度。这点对于印前工作非常重要。</p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180305Computer-graphics-rendering-process/%
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Learning AV Foundation(五)播放视频</title>
    <link href="https://www.sunyazhou.com/2018/03/04/Learning-AV-Foundation-Playing-Video/"/>
    <id>https://www.sunyazhou.com/2018/03/04/Learning-AV-Foundation-Playing-Video/</id>
    <published>2018-03-04T08:56:06.000Z</published>
    <updated>2018-03-04T09:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/5k-airplay.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很久没有写Learning AV Foundation相关的文章了,言归正传<br>本篇介绍一下简单的视频播放</p>
<p>了解视频播放之前我们来看戏<code>AVPlayer</code>需要的一些组件模型</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/AVPlayer.png" alt="AVPlayer组件模型"></p>
<h2 id="AVPlayer"><a href="#AVPlayer" class="headerlink" title="AVPlayer"></a>AVPlayer</h2><p><code>AVPlayer</code>是一个用来播放基于基于时间的视听媒体的控制对象,支持播放:</p>
<ul>
<li>本地 媒体文件</li>
<li>异步下载 媒体文件</li>
<li>HTTP Live Streaming协议的流媒体 文件</li>
</ul>
<p><code>AVPlayer</code> 是个 逻辑层组件</p>
<p>(应用可以分为如下几层)</p>
<blockquote>
<p>UI层<br>业务逻辑层<br>持久层+网络层  </p>
</blockquote>
<p>如果播放<code>MP3</code>或<code>AAC</code>等音频文件, 是没有啥UI可视化的页面的。要是播放一个<code>QuickTime</code>的电影或一个<code>MPEG-4</code>视频, 就会搞得很不适应.<br>如果要播放视频等功能设计到UI的话，可以使用<code>AVPlayerLayer</code>类。</p>
<blockquote>
<p>注意: <em><code>AVPlayer</code>只管理一个单独资源的播放, 如果播放多个可以使用<code>AVPlayer</code>的子类<code>AVQueuePlayer</code>, 用它来管理一个资源队列, 当需要在一个序列中播放多个条目或者 为音频、视频资源设置播放循环时刻使用这个类</em>.</p>
</blockquote>
<h2 id="AVPlayerLayer"><a href="#AVPlayerLayer" class="headerlink" title="AVPlayerLayer"></a>AVPlayerLayer</h2><p><code>AVPlayerLayer</code>构建于 <code>Core Animation</code>之上, 是<code>AV Foundation</code>中能找到的位数不多的UI组件. <code>Core Animation</code> 是<code>Mac</code>和<code>iOS</code>平台上负责图形渲染与动画的基础框架,主要用于这些平台的美化和动画流畅度的提升. <code>Core Animation</code>本身具有基于时间的属性,并且由于它基于<code>OpenGL</code>,所以具有很好的性能.</p>
<p><code>AVPlayerLayer</code>扩展了<code>Core Animation</code> 的<code>CALayer</code>类, 并通过框架显示视频内容到屏幕上.<br>我们知道Layer是不响应事件的.</p>
<p>创建<code>AVPlayerLayer</code>需要实例化一个<code>AVPlayer</code>的对象，<code>AVPlayerLayer</code>有一个<code>videoGravity</code>属性可以设置三种类似填充模式的东西,用来拉扯和缩放的视频. 下面列举了16:9的视频置于4:3矩形范围来说明不同的<code>gravity</code>.</p>
<p>如下图:</p>
<p><strong>AVLayerVideoGravityResizeAspect</strong>保持缩放比例<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/AVLayerVideoGravityResizeAspect.png" alt=""></p>
<p><strong>AVLayerVideoGravityResizeAspectFill</strong>填充<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/AVLayerVideoGravityResizeAspectFill.png" alt=""></p>
<p><strong>AVLayerVideoGravityResize</strong>拉伸</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/AVLayerVideoGravityResize.png" alt=""></p>
<h2 id="AVPlayerItem"><a href="#AVPlayerItem" class="headerlink" title="AVPlayerItem"></a>AVPlayerItem</h2><p>我们需要使用<code>AVPlayer</code>播放<code>AVAsset</code>,前面我知道<code>AVAsset</code>元数据里面有<code>创建时间</code>、<code>元数据</code>和<code>时长</code>等信息.但是并没有媒体中特定位置的方法.</p>
<p><strong>这是因为<code>AVAsset</code>模型只包含媒体资源的静态信息.这些不变的属性用来描述对象的静态信息.这就意味着仅使用<code>AVAsset</code>对象是不能实现播放功能的.如果播放我们需要使用<code>AVPlayerItem</code></strong></p>
<p><strong><code>AVPlayerItem</code>可以理解成是一个动态的<code>AVAsset</code>模型,</strong><br><code>AVPlayerItem</code>有<code>seekToTime:</code>方法和<code>presentationSize:</code>,<code>AVPlayerItem</code>由一个或多个媒体曲目组成.</p>
<p><code>AVPlayerItem</code>里面有<code>`AVPlayerItemTrack</code>轨道属性.</p>
<h2 id="播放示例"><a href="#播放示例" class="headerlink" title="播放示例"></a>播放示例</h2><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">	<span class="keyword">self</span>.localURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"hubblecast"</span> withExtension:<span class="string">@"m4v"</span>];</div><div class="line"></div><div class="line">    <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:<span class="keyword">self</span>.localURL];</div><div class="line">    </div><div class="line">    <span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</div><div class="line">    </div><div class="line">    <span class="built_in">AVPlayer</span> *player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:item];</div><div class="line">    </div><div class="line">    <span class="built_in">AVPlayerLayer</span> *layer = [<span class="built_in">AVPlayerLayer</span> playerLayerWithPlayer:player];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.view.layer addSublayer:layer];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>AVPlayerItem</code>并没有任何代理告知我们是否已经开始播放,所以一般的搞法都是使用<code>KVO</code>去监听它的一个属性,<code>AVPlayerItemStatus</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">AVPlayerItemStatus</span>) &#123;</div><div class="line">	<span class="built_in">AVPlayerItemStatusUnknown</span>,</div><div class="line">	<span class="built_in">AVPlayerItemStatusReadyToPlay</span>,</div><div class="line">	<span class="built_in">AVPlayerItemStatusFailed</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当它的<code>status</code>变成<code>AVPlayerItemStatusReadyToPlay</code>就说明已载入完成准备播放.</p>
<h2 id="CMTime"><a href="#CMTime" class="headerlink" title="CMTime"></a>CMTime</h2><p>使用<code>CMTime</code>来处理各种音视频相关的时间操作,他是<code>CoreMedia</code>framework中的结构体.专门用于处理精确的时间,我们以前用的<code>NSTimeInterval</code>是存在计算不精确的问题(苹果官方说的).</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">CMTimeValue</span>	value;		<span class="comment">//分子</span></div><div class="line">	<span class="built_in">CMTimeScale</span>	timescale; <span class="comment">//分母</span></div><div class="line">	<span class="built_in">CMTimeFlags</span>	flags;		<span class="comment">//标记是否失效 eg. kCMTimeFlags_Valid, kCMTimeFlags_PositiveInfinity</span></div><div class="line">	<span class="built_in">CMTimeEpoch</span>	epoch;		</div><div class="line">&#125; <span class="built_in">CMTime</span>;</div></pre></td></tr></table></figure>
<p>这个结构体最关键的即使<code>value</code>(64位整形)和<code>timescale</code>(32位整形).</p>
<p>它表达时间的方式以分数表示比如:</p>
<p><code>0.5</code>秒</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">CMTime</span> halfSecond = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//0.5秒</span></div><div class="line"><span class="built_in">CMTime</span> fiveSecond = <span class="built_in">CMTimeMake</span>(<span class="number">5</span>, <span class="number">1</span>); <span class="comment">//5秒</span></div><div class="line"><span class="built_in">CMTime</span> oneSample = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">44100</span>); <span class="comment">//一个抽样的样本</span></div><div class="line"><span class="built_in">CMTime</span> zeroTime = kCMTimeZero;</div></pre></td></tr></table></figure>
<h2 id="创建自己的播放器"><a href="#创建自己的播放器" class="headerlink" title="创建自己的播放器"></a>创建自己的播放器</h2><p>首先需要封装一个<code>player</code>,</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"TransportProtocol.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">AVPlayer</span>;</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerView</span> : <span class="title">UIView</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> &lt;TransportProtocol&gt;  transport;</div><div class="line">- (<span class="keyword">id</span>)initWithPlayer:(<span class="built_in">AVPlayer</span> *)player;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>.m文件实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"PlayerView.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"THOverlayView.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerView</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) THOverlayView *overlayView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PlayerView</span></span></div><div class="line">+ (Class)layerClass&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">AVPlayerLayer</span> <span class="keyword">class</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithPlayer:(<span class="built_in">AVPlayer</span> *)player&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:<span class="built_in">CGRectZero</span>];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">        <span class="keyword">self</span>.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</div><div class="line">        [(<span class="built_in">AVPlayerLayer</span> *)[<span class="keyword">self</span> layer] setPlayer:player];</div><div class="line">        [[<span class="built_in">NSBundle</span> mainBundle] loadNibNamed:<span class="string">@"THOverlayView"</span> owner:<span class="keyword">self</span> options:<span class="literal">nil</span>];</div><div class="line">        [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.overlayView];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)layoutSubviews&#123;</div><div class="line">    [<span class="keyword">super</span> layoutSubviews];</div><div class="line">    <span class="keyword">self</span>.overlayView.frame = <span class="keyword">self</span>.bounds;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span> &lt;TransportProtocol&gt;)transport&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.overlayView;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>transport 是播放器的视图点击视图代理等集成了 在一起</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TransportDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)play;</div><div class="line">- (<span class="keyword">void</span>)pause;</div><div class="line">- (<span class="keyword">void</span>)stop;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)scrubbingDidStart;</div><div class="line">- (<span class="keyword">void</span>)scrubbedToTime:(<span class="built_in">NSTimeInterval</span>)time;</div><div class="line">- (<span class="keyword">void</span>)scrubbingDidEnd;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)jumpedToTime:(<span class="built_in">NSTimeInterval</span>)time;</div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)subtitleSelected:(<span class="built_in">NSString</span> *)subtitle;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TransportProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> &lt;TransportDelegate&gt; delegate;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title;</div><div class="line">- (<span class="keyword">void</span>)setCurrentTime:(<span class="built_in">NSTimeInterval</span>)time duration:(<span class="built_in">NSTimeInterval</span>)duration;</div><div class="line">- (<span class="keyword">void</span>)setScrubbingTime:(<span class="built_in">NSTimeInterval</span>)time;</div><div class="line">- (<span class="keyword">void</span>)playbackComplete;</div><div class="line">- (<span class="keyword">void</span>)setSubtitles:(<span class="built_in">NSArray</span> *)subtitles;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>THOverlayView文件是顶层视图点击播放等等控件.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerController</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIView</span> *view;</div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)assetURL;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>播放器的实现文件如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"PlayerController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"TransportProtocol.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"PlayerView.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"AVAsset+Additions.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"UIAlertView+Additions.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"THThumbnail.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">// AVPlayerItem's status property</span></div><div class="line"><span class="meta">#define STATUS_KEYPATH @<span class="meta-string">"status"</span></span></div><div class="line"></div><div class="line"><span class="comment">// Refresh interval for timed observations of AVPlayer</span></div><div class="line"><span class="meta">#define REFRESH_INTERVAL 0.5f</span></div><div class="line"></div><div class="line"><span class="comment">// Define this constant for the key-value observation context.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *PlayerItemStatusContext;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerController</span> () &lt;<span class="title">TransportDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVAsset</span>               *asset;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVPlayerItem</span>          *playerItem;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVPlayer</span>              *player;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) PlayerView            *playerView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;TransportProtocol&gt;  transport;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>                    timeObserver;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>                    itemEndObserver;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span>                 lastPlaybackRate;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">AVAssetImageGenerator</span> *imageGenerator;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PlayerController</span></span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Setup</span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)assetURL &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _asset = [<span class="built_in">AVAsset</span> assetWithURL:assetURL];                           <span class="comment">// 1</span></div><div class="line">        [<span class="keyword">self</span> prepareToPlay];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)prepareToPlay &#123;</div><div class="line">    <span class="built_in">NSArray</span> *keys = @[</div><div class="line">                      <span class="string">@"tracks"</span>,</div><div class="line">                      <span class="string">@"duration"</span>,</div><div class="line">                      <span class="string">@"commonMetadata"</span>,</div><div class="line">                      <span class="string">@"availableMediaCharacteristicsWithMediaSelectionOptions"</span></div><div class="line">                      ];</div><div class="line">    <span class="keyword">self</span>.playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:<span class="keyword">self</span>.asset          <span class="comment">// 2</span></div><div class="line">                           automaticallyLoadedAssetKeys:keys];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span>                                       <span class="comment">// 3</span></div><div class="line">                      forKeyPath:STATUS_KEYPATH</div><div class="line">                         options:<span class="number">0</span></div><div class="line">                         context:&amp;PlayerItemStatusContext];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:<span class="keyword">self</span>.playerItem];          <span class="comment">// 4</span></div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.playerView = [[PlayerView alloc] initWithPlayer:<span class="keyword">self</span>.player];    <span class="comment">// 5</span></div><div class="line">    <span class="keyword">self</span>.transport = <span class="keyword">self</span>.playerView.transport;</div><div class="line">    <span class="keyword">self</span>.transport.delegate = <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (context == &amp;PlayerItemStatusContext) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;                        <span class="comment">// 1</span></div><div class="line">            </div><div class="line">            [<span class="keyword">self</span>.playerItem removeObserver:<span class="keyword">self</span> forKeyPath:STATUS_KEYPATH];</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.playerItem.status == <span class="built_in">AVPlayerItemStatusReadyToPlay</span>) &#123;</div><div class="line">                </div><div class="line">                <span class="comment">// Set up time observers.                                   // 2</span></div><div class="line">                [<span class="keyword">self</span> addPlayerItemTimeObserver];</div><div class="line">                [<span class="keyword">self</span> addItemEndObserverForPlayerItem];</div><div class="line">                </div><div class="line">                <span class="built_in">CMTime</span> duration = <span class="keyword">self</span>.playerItem.duration;</div><div class="line">                </div><div class="line">                <span class="comment">// Synchronize the time display                             // 3</span></div><div class="line">                [<span class="keyword">self</span>.transport setCurrentTime:<span class="built_in">CMTimeGetSeconds</span>(kCMTimeZero)</div><div class="line">                                      duration:<span class="built_in">CMTimeGetSeconds</span>(duration)];</div><div class="line">                </div><div class="line">                <span class="comment">// Set the video title.</span></div><div class="line">                [<span class="keyword">self</span>.transport setTitle:<span class="keyword">self</span>.asset.title];                 <span class="comment">// 4</span></div><div class="line">                </div><div class="line">                [<span class="keyword">self</span>.player play];                                         <span class="comment">// 5</span></div><div class="line">                </div><div class="line">                [<span class="keyword">self</span> loadMediaOptions];</div><div class="line">                [<span class="keyword">self</span> generateThumbnails];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                [<span class="built_in">UIAlertView</span> showAlertWithTitle:<span class="string">@"Error"</span></div><div class="line">                                        message:<span class="string">@"Failed to load video"</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)loadMediaOptions &#123;</div><div class="line">    <span class="built_in">NSString</span> *mc = <span class="built_in">AVMediaCharacteristicLegible</span>;                            <span class="comment">// 1</span></div><div class="line">    <span class="built_in">AVMediaSelectionGroup</span> *group =</div><div class="line">    [<span class="keyword">self</span>.asset mediaSelectionGroupForMediaCharacteristic:mc];          <span class="comment">// 2</span></div><div class="line">    <span class="keyword">if</span> (group) &#123;</div><div class="line">        <span class="built_in">NSMutableArray</span> *subtitles = [<span class="built_in">NSMutableArray</span> array];                 <span class="comment">// 3</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">AVMediaSelectionOption</span> *option <span class="keyword">in</span> group.options) &#123;</div><div class="line">            [subtitles addObject:option.displayName];</div><div class="line">        &#125;</div><div class="line">        [<span class="keyword">self</span>.transport setSubtitles:subtitles];                            <span class="comment">// 4</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span>.transport setSubtitles:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)subtitleSelected:(<span class="built_in">NSString</span> *)subtitle &#123;</div><div class="line">    <span class="built_in">NSString</span> *mc = <span class="built_in">AVMediaCharacteristicLegible</span>;</div><div class="line">    <span class="built_in">AVMediaSelectionGroup</span> *group =</div><div class="line">    [<span class="keyword">self</span>.asset mediaSelectionGroupForMediaCharacteristic:mc];          <span class="comment">// 1</span></div><div class="line">    <span class="built_in">BOOL</span> selected = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">AVMediaSelectionOption</span> *option <span class="keyword">in</span> group.options) &#123;</div><div class="line">        <span class="keyword">if</span> ([option.displayName isEqualToString:subtitle]) &#123;</div><div class="line">            [<span class="keyword">self</span>.playerItem selectMediaOption:option                       <span class="comment">// 2</span></div><div class="line">                         inMediaSelectionGroup:group];</div><div class="line">            selected = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!selected) &#123;</div><div class="line">        [<span class="keyword">self</span>.playerItem selectMediaOption:<span class="literal">nil</span>                              <span class="comment">// 3</span></div><div class="line">                     inMediaSelectionGroup:group];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Time Observers</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addPlayerItemTimeObserver &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// Create 0.5 second refresh interval - REFRESH_INTERVAL == 0.5</span></div><div class="line">    <span class="built_in">CMTime</span> interval =</div><div class="line">    <span class="built_in">CMTimeMakeWithSeconds</span>(REFRESH_INTERVAL, <span class="built_in">NSEC_PER_SEC</span>);              <span class="comment">// 1</span></div><div class="line">    </div><div class="line">    <span class="comment">// Main dispatch queue</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();                     <span class="comment">// 2</span></div><div class="line">    </div><div class="line">    <span class="comment">// Create callback block for time observer</span></div><div class="line">    __<span class="keyword">weak</span> PlayerController *weakSelf = <span class="keyword">self</span>;                             <span class="comment">// 3</span></div><div class="line">    <span class="keyword">void</span> (^callback)(<span class="built_in">CMTime</span> time) = ^(<span class="built_in">CMTime</span> time) &#123;</div><div class="line">        <span class="built_in">NSTimeInterval</span> currentTime = <span class="built_in">CMTimeGetSeconds</span>(time);</div><div class="line">        <span class="built_in">NSTimeInterval</span> duration = <span class="built_in">CMTimeGetSeconds</span>(weakSelf.playerItem.duration);</div><div class="line">        [weakSelf.transport setCurrentTime:currentTime duration:duration];  <span class="comment">// 4</span></div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">// Add observer and store pointer for future use</span></div><div class="line">    <span class="keyword">self</span>.timeObserver =                                                     <span class="comment">// 5</span></div><div class="line">    [<span class="keyword">self</span>.player addPeriodicTimeObserverForInterval:interval</div><div class="line">                                              queue:queue</div><div class="line">                                         usingBlock:callback];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addItemEndObserverForPlayerItem &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *name = <span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> mainQueue];</div><div class="line">    </div><div class="line">    __<span class="keyword">weak</span> PlayerController *weakSelf = <span class="keyword">self</span>;                             <span class="comment">// 1</span></div><div class="line">    <span class="keyword">void</span> (^callback)(<span class="built_in">NSNotification</span> *note) = ^(<span class="built_in">NSNotification</span> *notification) &#123;</div><div class="line">        [weakSelf.player seekToTime:kCMTimeZero                             <span class="comment">// 2</span></div><div class="line">                  completionHandler:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                      [weakSelf.transport playbackComplete];                          <span class="comment">// 3</span></div><div class="line">                  &#125;];</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.itemEndObserver =                                                  <span class="comment">// 4</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:name</div><div class="line">                                                      object:<span class="keyword">self</span>.playerItem</div><div class="line">                                                       queue:queue</div><div class="line">                                                  usingBlock:callback];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - THTransportDelegate Methods</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)play &#123;</div><div class="line">    [<span class="keyword">self</span>.player play];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)pause &#123;</div><div class="line">    <span class="keyword">self</span>.lastPlaybackRate = <span class="keyword">self</span>.player.rate;</div><div class="line">    [<span class="keyword">self</span>.player pause];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line">    [<span class="keyword">self</span>.player setRate:<span class="number">0.0</span>f];</div><div class="line">    [<span class="keyword">self</span>.transport playbackComplete];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)jumpedToTime:(<span class="built_in">NSTimeInterval</span>)time &#123;</div><div class="line">    [<span class="keyword">self</span>.player seekToTime:<span class="built_in">CMTimeMakeWithSeconds</span>(time, <span class="built_in">NSEC_PER_SEC</span>)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)scrubbingDidStart &#123;                                                 <span class="comment">// 1</span></div><div class="line">    <span class="keyword">self</span>.lastPlaybackRate = <span class="keyword">self</span>.player.rate;</div><div class="line">    [<span class="keyword">self</span>.player pause];</div><div class="line">    [<span class="keyword">self</span>.player removeTimeObserver:<span class="keyword">self</span>.timeObserver];</div><div class="line">    <span class="keyword">self</span>.timeObserver = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)scrubbedToTime:(<span class="built_in">NSTimeInterval</span>)time &#123;                               <span class="comment">// 2</span></div><div class="line">    [<span class="keyword">self</span>.playerItem cancelPendingSeeks];</div><div class="line">    [<span class="keyword">self</span>.player seekToTime:<span class="built_in">CMTimeMakeWithSeconds</span>(time, <span class="built_in">NSEC_PER_SEC</span>) toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)scrubbingDidEnd &#123;                                                   <span class="comment">// 3</span></div><div class="line">    [<span class="keyword">self</span> addPlayerItemTimeObserver];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastPlaybackRate &gt; <span class="number">0.0</span>f) &#123;</div><div class="line">        [<span class="keyword">self</span>.player play];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Thumbnail Generation</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)generateThumbnails &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.imageGenerator =                                                   <span class="comment">// 1</span></div><div class="line">    [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:<span class="keyword">self</span>.asset];</div><div class="line">    </div><div class="line">    <span class="comment">// Generate the @2x equivalent</span></div><div class="line">    <span class="keyword">self</span>.imageGenerator.maximumSize = <span class="built_in">CGSizeMake</span>(<span class="number">200.0</span>f, <span class="number">0.0</span>f);             <span class="comment">// 2</span></div><div class="line">    </div><div class="line">    <span class="built_in">CMTime</span> duration = <span class="keyword">self</span>.asset.duration;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableArray</span> *times = [<span class="built_in">NSMutableArray</span> array];                         <span class="comment">// 3</span></div><div class="line">    <span class="built_in">CMTimeValue</span> increment = duration.value / <span class="number">20</span>;</div><div class="line">    <span class="built_in">CMTimeValue</span> currentValue = <span class="number">2.0</span> * duration.timescale;</div><div class="line">    <span class="keyword">while</span> (currentValue &lt;= duration.value) &#123;</div><div class="line">        <span class="built_in">CMTime</span> time = <span class="built_in">CMTimeMake</span>(currentValue, duration.timescale);</div><div class="line">        [times addObject:[<span class="built_in">NSValue</span> valueWithCMTime:time]];</div><div class="line">        currentValue += increment;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSUInteger</span> imageCount = times.count;                            <span class="comment">// 4</span></div><div class="line">    __block <span class="built_in">NSMutableArray</span> *images = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    </div><div class="line">    <span class="built_in">AVAssetImageGeneratorCompletionHandler</span> handler;                         <span class="comment">// 5</span></div><div class="line">    </div><div class="line">    handler = ^(<span class="built_in">CMTime</span> requestedTime,</div><div class="line">                <span class="built_in">CGImageRef</span> imageRef,</div><div class="line">                <span class="built_in">CMTime</span> actualTime,</div><div class="line">                <span class="built_in">AVAssetImageGeneratorResult</span> result,</div><div class="line">                <span class="built_in">NSError</span> *error) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorSucceeded</span>) &#123;                     <span class="comment">// 6</span></div><div class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</div><div class="line">            <span class="keyword">id</span> thumbnail =</div><div class="line">            [THThumbnail thumbnailWithImage:image time:actualTime];</div><div class="line">            [images addObject:thumbnail];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, [error localizedDescription]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// If the decremented image count is at 0, we're all done.</span></div><div class="line">        <span class="keyword">if</span> (--imageCount == <span class="number">0</span>) &#123;                                            <span class="comment">// 7</span></div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="built_in">NSString</span> *name = THThumbnailsGeneratedNotification;</div><div class="line">                <span class="built_in">NSNotificationCenter</span> *nc = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</div><div class="line">                [nc postNotificationName:name object:images];</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.imageGenerator generateCGImagesAsynchronouslyForTimes:times       <span class="comment">// 8</span></div><div class="line">                                              completionHandler:handler];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Housekeeping</span></div><div class="line"></div><div class="line">- (<span class="built_in">UIView</span> *)view &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.playerView;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.itemEndObserver) &#123;                                             <span class="comment">// 5</span></div><div class="line">        <span class="built_in">NSNotificationCenter</span> *nc = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</div><div class="line">        [nc removeObserver:<span class="keyword">self</span>.itemEndObserver</div><div class="line">                      name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></div><div class="line">                    object:<span class="keyword">self</span>.player.currentItem];</div><div class="line">        <span class="keyword">self</span>.itemEndObserver = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这里说一下如何监听时间从而得知播放时间回调</p>
<h3 id="监听时间"><a href="#监听时间" class="headerlink" title="监听时间"></a>监听时间</h3><p>当播放器播放的时候我们无法得知播放到播放器的哪个位置,为了解决这个问题<code>AVPlayerItem</code>添加了两个监听播放的方法以及具体的用法<code>API</code>.</p>
<h4 id="定期监听"><a href="#定期监听" class="headerlink" title="定期监听"></a>定期监听</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)addPeriodicTimeObserverForInterval:(<span class="built_in">CMTime</span>)interval</div><div class="line">                                   queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue</div><div class="line">                              usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> time))block;</div></pre></td></tr></table></figure>
<p>这里主要是为了随着时间的变化移动播放器seek位置更新时间显示,通过<code>AVPlayer</code>的<code>addPeriodicTimeObserverForInterval:queue:usingBlock:</code> 来监听播放时间的变化</p>
<ul>
<li><code>interv</code><em>监听周期的间隔<code>CMTime</code></em></li>
<li><code>queue</code> <em>通知发送的顺序调度队列,一般我们都放在主线程回掉.(注意这里不能放在并行队列中)</em></li>
<li><code>block</code> <em>指定周期的时间回调.</em></li>
</ul>
<p>下面是示例代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addPlayerItemTimeObserver &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// Create 0.5 second refresh interval - REFRESH_INTERVAL == 0.5</span></div><div class="line">    <span class="built_in">CMTime</span> interval =</div><div class="line">    <span class="built_in">CMTimeMakeWithSeconds</span>(REFRESH_INTERVAL, <span class="built_in">NSEC_PER_SEC</span>);              <span class="comment">// 1</span></div><div class="line">    </div><div class="line">    <span class="comment">// Main dispatch queue</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();                     <span class="comment">// 2</span></div><div class="line">    </div><div class="line">    <span class="comment">// Create callback block for time observer</span></div><div class="line">    __<span class="keyword">weak</span> PlayerController *weakSelf = <span class="keyword">self</span>;                             <span class="comment">// 3</span></div><div class="line">    <span class="keyword">void</span> (^callback)(<span class="built_in">CMTime</span> time) = ^(<span class="built_in">CMTime</span> time) &#123;</div><div class="line">        <span class="built_in">NSTimeInterval</span> currentTime = <span class="built_in">CMTimeGetSeconds</span>(time);</div><div class="line">        <span class="built_in">NSTimeInterval</span> duration = <span class="built_in">CMTimeGetSeconds</span>(weakSelf.playerItem.duration);</div><div class="line">        [weakSelf.transport setCurrentTime:currentTime duration:duration];  <span class="comment">// 4</span></div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">// Add observer and store pointer for future use</span></div><div class="line">    <span class="keyword">self</span>.timeObserver =                                                     <span class="comment">// 5</span></div><div class="line">    [<span class="keyword">self</span>.player addPeriodicTimeObserverForInterval:interval</div><div class="line">                                              queue:queue</div><div class="line">                                         usingBlock:callback];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="边界监听"><a href="#边界监听" class="headerlink" title="边界监听"></a>边界监听</h4><p>什么叫边界监听呢?就是播放器播放到某个时间的触发的 时间位置.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)addBoundaryTimeObserverForTimes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)times</div><div class="line">                                queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue</div><div class="line">                           usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</div></pre></td></tr></table></figure>
<ul>
<li><code>times</code> <em>CMTime值组成一个<code>NSArray</code>,这里面定义的一个时间点的数组.eg: 25% 50% 75%等时间点.</em></li>
<li><code>queue</code> <em>通知发送的顺序调度队列,一般我们都放在主线程回掉.(注意这里不能放在并行队列中)</em></li>
<li><code>block</code> <em>指定周期的时间回调.</em></li>
</ul>
<h3 id="显示字幕"><a href="#显示字幕" class="headerlink" title="显示字幕"></a>显示字幕</h3><p><code>AVPlayerLayer</code>里有两个类来处理字幕</p>
<ul>
<li>AVMediaSelectionGroup</li>
<li>AVMediaSelectionOption</li>
</ul>
<p><code>AVMediaSelectionOption</code> 用于表示<code>AVAsset</code>备用媒体显示.在前几篇中我讲过一个媒体元数据中有<code>音频轨</code>、<code>视频轨</code>、<code>字幕轨</code>,<code>备用相机角度</code>等.</p>
<p>我们如果想找出字幕的话需要用到<code>AVAsset</code>的<code>availableMediaCharacteristicsWithMediaSelectionOptions</code>属性.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMediaCharacteristic</span>&gt; *availableMediaCharacteristicsWithMediaSelectionOptions <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_8, <span class="number">5</span>_0);</div></pre></td></tr></table></figure>
<p>这个属性会返回一个数组的<code>字符串</code>,这些<code>字符串</code>用于表示保存在资源中可用选项的媒体特征,其实数组中包含的字符串的值为如下：</p>
<ul>
<li>AVMediaCharacteristicVisual 视频</li>
<li>AVMediaCharacteristicAudible 音频</li>
<li>AVMediaCharacteristicLegible 字幕或隐藏式字幕</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">AVMediaSelectionGroup</span> *)mediaSelectionGroupForMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_8, <span class="number">5</span>_0);</div></pre></td></tr></table></figure>
<p>请求可用媒体特性数据后,调用<code>AVAsset</code>的<code>mediaSelectionGroupForMediaCharacteristic:</code>方法.为其传递要检索的选项的特定媒体特征.这个方法返回一个<code>AVMediaSelectionGroup</code>,它作为一个或多个互斥的<code>AVMediaSelectionGroup</code>实例的容器.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadMediaOptions &#123;</div><div class="line">    <span class="built_in">NSString</span> *mc = <span class="built_in">AVMediaCharacteristicLegible</span>;                            <span class="comment">// 1</span></div><div class="line">    <span class="built_in">AVMediaSelectionGroup</span> *group =</div><div class="line">        [<span class="keyword">self</span>.asset mediaSelectionGroupForMediaCharacteristic:mc];          <span class="comment">// 2</span></div><div class="line">    <span class="keyword">if</span> (group) &#123;</div><div class="line">        <span class="built_in">NSMutableArray</span> *subtitles = [<span class="built_in">NSMutableArray</span> array];                 <span class="comment">// 3</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">AVMediaSelectionOption</span> *option <span class="keyword">in</span> group.options) &#123;</div><div class="line">            [subtitles addObject:option.displayName];</div><div class="line">        &#125;</div><div class="line">        [<span class="keyword">self</span>.transport setSubtitles:subtitles];                            <span class="comment">// 4</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span>.transport setSubtitles:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AirPlay"><a href="#AirPlay" class="headerlink" title="AirPlay"></a>AirPlay</h2><p>AirPlay相信大部分iOS开发者都耳熟能详,这个东西是用于无线方式将流媒体音频/视频内容在<code>Apple TV</code>上播放.或者将纯音频内容在多种第三方音频系统中播放(如汽车中内置的CarPlay).如果大家有<code>Apple TV</code>或其它音频系统中的一个,就会觉得这个功能实在太实用了.其实把这个功能整合到我们的APP中十分容易.</p>
<p><code>AVPlayer</code>有一个属性是<code>allowsExternalPlayback</code>,允许启用或者禁用<code>AirPlay</code>播放功能.该属性默认是<code>YES</code>,即在不做任何额外编码的情况下,播放器应用程序也会自动支持<code>AirPlay</code>功能.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> allowsExternalPlayback <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">6</span>_0);</div></pre></td></tr></table></figure>
<p>不过从iOS11之后才有专门针对AirPlay的framework功能API,在以前我们使用<code>Media Player</code>中的<code>MPVolumeView</code>来实现.</p>
<p>示例代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MPVolumeView *volumeView = [[MPVolumeView alloc] init];</div><div class="line">   volumeView.showsVolumeSlider = NO;</div><div class="line">   [volumeView sizeToFit];</div><div class="line">   [transportView addSubview:volumeView];</div></pre></td></tr></table></figure>
<p>当AirPlay可用时,而且WIFI 网络启用时才会显示线路选择按钮.这两个条件只有一个不满足, MPVolumeView 就会自动隐藏按钮.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章讲述了 如何使用AVPlayer以及AVPlayerItem 的一些属性 监听播放进度回调,取 字幕等等.</p>
<p><a href="https://github.com/sunyazhou13/Learning-AV-Foundation-Demos" target="_blank" rel="external">详细demo请参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/Learning-AV-Foundation-Playing-Video/5k-airpl
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="Learning AV Foundation" scheme="https://www.sunyazhou.com/tags/Learning-AV-Foundation/"/>
    
  </entry>
  
  <entry>
    <title>NLP分词WordEmbeding</title>
    <link href="https://www.sunyazhou.com/2018/02/04/20180204Word-Embeding/"/>
    <id>https://www.sunyazhou.com/2018/02/04/20180204Word-Embeding/</id>
    <published>2018-02-04T04:24:30.000Z</published>
    <updated>2018-02-04T04:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180204Word-Embeding/wordembeding.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习过程中记录一下python代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 加载包</span></div><div class="line"><span class="keyword">from</span> gensim.models <span class="keyword">import</span> Word2Vec</div><div class="line"><span class="keyword">from</span> gensim.models.word2vec <span class="keyword">import</span> LineSentence</div><div class="line"></div><div class="line"><span class="comment"># 训练模型</span></div><div class="line"><span class="comment"># sentences = LineSentence('wiki.zh.word.text')</span></div><div class="line"><span class="comment"># size：词向量的维度</span></div><div class="line"><span class="comment"># window：上下文环境的窗口大小</span></div><div class="line"><span class="comment"># min_count：忽略出现次数低于min_count的词</span></div><div class="line"><span class="comment"># model = Word2Vec(sentences, size=128, window=5, min_count=5, workers=4)</span></div><div class="line"></div><div class="line"><span class="comment"># 保存模型</span></div><div class="line"><span class="comment"># model.save('word_embedding_128')</span></div><div class="line"></div><div class="line"><span class="comment"># 如果已经保存过模型，则直接加载即可</span></div><div class="line"><span class="comment"># 前面训练并保存的代码都可以省略</span></div><div class="line">model = Word2Vec.load(<span class="string">"word_embedding_128"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 使用模型</span></div><div class="line"><span class="comment"># 返回和一个词语最相关的多个词语以及对应的相关度</span></div><div class="line">items = model.most_similar(<span class="string">u'中国'</span>)</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">	<span class="comment"># 词的内容，词的相关度</span></div><div class="line">	<span class="keyword">print</span> item[<span class="number">0</span>], item[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment"># 返回两个词语之间的相关度</span></div><div class="line">model.similarity(<span class="string">u'男人'</span>,  <span class="string">u'女人'</span>)</div></pre></td></tr></table></figure>
<p>参考分词如下:  </p>
<p><a href="https://www.ltp-cloud.com/demo/" target="_blank" rel="external">哈工大分词</a><br><a href="https://github.com/fxsjy/jieba" target="_blank" rel="external">jieba分词</a><br><a href="https://nlp.stanford.edu/software/segmenter.shtml" target="_blank" rel="external">stanford分词</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180204Word-Embeding/wordembeding.png&quot; alt=&quot;
    
    </summary>
    
      <category term="python开发" scheme="https://www.sunyazhou.com/categories/python%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="python开发" scheme="https://www.sunyazhou.com/tags/python%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用Python操作MySQL数据库</title>
    <link href="https://www.sunyazhou.com/2018/01/13/20180113Python-MySQL/"/>
    <id>https://www.sunyazhou.com/2018/01/13/20180113Python-MySQL/</id>
    <published>2018-01-13T14:27:18.000Z</published>
    <updated>2018-02-04T04:23:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/mysql-python.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了实现<code>不斷學習 與時俱進</code>周末把大部分时间放在了学习<code>Python</code>上.<br>在最近的学习中有一些有价值的部分都摘录整理出来放到博客上,以免后续用到的时候忘记时回来翻翻博客.</p>
<p>我是在<code>study.163.com</code>的这个<a href="http://study.163.com/course/courseMain.htm?courseId=1003520028" target="_blank" rel="external">《全栈数据工程师养成攻略》</a>课程中学习的,推荐大家学习一下.</p>
<h2 id="本篇主要内容"><a href="#本篇主要内容" class="headerlink" title="本篇主要内容"></a>本篇主要内容</h2><p>主要分为三个大部分</p>
<ol>
<li>搭建<code>Web</code>环境</li>
<li>数据库MySQL的使用方法</li>
<li>使用Python操作MySQL</li>
</ol>
<h3 id="搭建Web环境"><a href="#搭建Web环境" class="headerlink" title="搭建Web环境"></a>搭建<code>Web</code>环境</h3><ul>
<li>Web环境: Apache、Nginx…</li>
<li>Web服务启动中相关配置.</li>
</ul>
<h4 id="Web环境-Apache、Nginx…"><a href="#Web环境-Apache、Nginx…" class="headerlink" title="Web环境: Apache、Nginx…"></a>Web环境: Apache、Nginx…</h4><p>两个平台的相关的下载</p>
<p><a href="https://www.mamp.info/en/" target="_blank" rel="external">MAMP</a>: Mac, Apache, MySQL, PHP </p>
<blockquote>
<p>Mac, Apache, MySQL, PHP 缩写<code>MAMP</code></p>
</blockquote>
<p><a href="https://www.mamp.info/en/" target="_blank" rel="external">WAMP</a>: Windows, Apache, MySQL, PHP </p>
<blockquote>
<p>Windows, Apache, MySQL, PHP 缩写<code>WAMP</code></p>
</blockquote>
<p>当然还有linux版本这里就不做多介绍了</p>
<p>总之需要安装这个软件进行环境配置的搭建.</p>
<p>我这里用<code>MAMP</code>举例说明一下</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/mamp1.png" alt=""></p>
<p>打开之后<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/mamp2.png" alt=""></p>
<h4 id="Web服务启动中相关配置"><a href="#Web服务启动中相关配置" class="headerlink" title="Web服务启动中相关配置"></a>Web服务启动中相关配置</h4><p>开启<code>Apatch Server</code>和<code>MySQL Server</code>服务(右上角).<br>然后点击<code>Perferences</code>,进行本地端口配置.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/mamp3.png" alt=""></p>
<p>这里有两种默认配置(红色框选部分) </p>
<p>如果把服务开启的话那么打开浏览器输入:<code>localhost:8888</code>就可以看到相关的效果</p>
<blockquote>
<p>localhost == 127.0.0.1</p>
</blockquote>
<p><code>8888</code>是服务的端口</p>
<p>下面这张图可以选择文件根目录<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/mamp4.png" alt=""></p>
<p>什么意思呢?</p>
<p>就是你把网页的相关文件放到 这个文件夹的话<br>就会在浏览器上直接浏览.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/mamp2.png" alt=""></p>
<p>这张图中间的<code>Open Start Page</code>. </p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/sql1.png" alt=""></p>
<p>进入到数据库配置相关</p>
<p>配置数据库名称<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/sql2.png" alt=""></p>
<p>输入表名</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/sql3.png" alt=""></p>
<p>配置数据库表<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/sql4.png" alt=""></p>
<p>配置完右侧完成</p>
<h3 id="数据库MySQL的使用方法"><a href="#数据库MySQL的使用方法" class="headerlink" title="数据库MySQL的使用方法"></a>数据库MySQL的使用方法</h3><ul>
<li>基本概念</li>
<li>终端配置Python MySQL</li>
<li>Navicat 数据的导出导入</li>
<li>个人的习惯搞法</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>CURD</code>操作:</p>
<ul>
<li><code>C</code> Create</li>
<li><code>R</code> Read</li>
<li><code>U</code> Update</li>
<li><code>D</code> Delete</li>
</ul>
<p>这就是数据库相关知识中 <code>增``删``改``查</code></p>
<h4 id="终端配置Python-MySQL"><a href="#终端配置Python-MySQL" class="headerlink" title="终端配置Python MySQL"></a>终端配置Python MySQL</h4><p>在终端中使用如下指令安装MySQL环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">pip install MySQL-python</div></pre></td></tr></table></figure>
<p>我安装的时候出错了</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/pip_install_mysql-python.png" alt=""></p>
<p>最后执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">brew install mysql-python</div></pre></td></tr></table></figure>
<p>然后再去执行<code>pip install MySQL-python</code></p>
<p>如何测试是否成功</p>
<p>在shell中输入<code>python</code></p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/pythonshell1.png" alt=""></p>
<p>执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> MySQLdb</div></pre></td></tr></table></figure>
<p>如果没有错误就是OK的.</p>
<h4 id="Navicat-数据的导出导入"><a href="#Navicat-数据的导出导入" class="headerlink" title="Navicat 数据的导出导入"></a>Navicat 数据的导出导入</h4><p>这个数据库可视化操作软件大家自行下载吧<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/navicat1.png" alt=""></p>
<p>打开之后点击左上角点击新建connect 选择MySQL<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/navicat2.png" alt=""></p>
<p>接着配置数据库的信息<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/navicat3.png" alt=""></p>
<p>这里的名称就是<strong>数据库名称</strong><br><code>host</code>地方本地,如果是远程的话,填写<code>ip</code>或者<code>url</code><br><code>port</code>前面我们设置了<code>8889</code><br>账号和密码输入<code>root</code>(前面图里面已经看到了账号密码都是一样的)</p>
<p>下面就是连接数据库</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/navicat4.png" alt=""></p>
<p>下面这张图就是</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/navicat5.png" alt=""></p>
<p><strong>数据库导出和导入,当然也可以导出导入数据表.</strong></p>
<h4 id="个人的习惯搞法"><a href="#个人的习惯搞法" class="headerlink" title="个人的习惯搞法"></a>个人的习惯搞法</h4><ul>
<li>使用<code>phpmyadmin</code>新建数据库和数据表</li>
<li>使用<code>python</code>插入、读取、更新、修改数据</li>
<li>使用<code>Navicat</code>导出数据库</li>
<li>使用<code>phpmyadmin</code>导入数据库 </li>
</ul>
<p>最后deloy(部署)到线上,这样就可以避免各种错误操作数据库的问题</p>
<h3 id="使用Python操作MySQL"><a href="#使用Python操作MySQL" class="headerlink" title="使用Python操作MySQL"></a>使用Python操作MySQL</h3><p>这个没啥就是coding部分,使用之前把点击<a href="https://github.com/sunyazhou13/sunyazhou13.github.io-images/blob/master/20180113Python-MySQL/douban_movie_clean.txt" target="_blank" rel="external">这里下载</a>这个文本文件</p>
<p>我们用<code>sublime text</code>新建一个<code>text.py</code>文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">"utf8"</span>)</div><div class="line"></div><div class="line"><span class="keyword">import</span> MySQLdb</div><div class="line"><span class="keyword">import</span> MySQLdb.cursors</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/Pythoncode1.png" alt=""></p>
<blockquote>
<p>注意:_test.py最好和douban_movie<em>clean.txt保持在同一个目录这样就不用写路径了</em></p>
</blockquote>
<p>接着创建数据库连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"></div><div class="line">db = MySQLdb.connect(host=<span class="string">'127.0.0.1'</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'root'</span>, db=<span class="string">'douban'</span>, port=<span class="number">8889</span>, charset=<span class="string">'utf8'</span>, cursorclass=MySQLdb.cursors.DictCursor) //<span class="number">1</span></div><div class="line">db.autocommit(<span class="keyword">True</span>) //<span class="number">2</span></div><div class="line">cursor = db.cursor() //<span class="number">3</span></div><div class="line"></div><div class="line">fr = open(<span class="string">'douban_movie_clean.txt'</span>,<span class="string">'r'</span>) //<span class="number">4</span></div><div class="line"></div><div class="line">fr.close() //<span class="number">4</span></div><div class="line"></div><div class="line">cursor.close() //<span class="number">3</span></div><div class="line">db.close() //<span class="number">1</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意 <code>db</code>记得用完关闭,<code>cursor</code>也要记得关闭, <code>fr</code>是文件的读写 和数据库没啥关系也需要记得用完关闭</p>
</blockquote>
<p>下面解释一下什么意思</p>
<ol>
<li><code>db</code>创建输入库实例,输入参数 <code>host</code>(这里用的是127.0.0.1也可以换成localhost)、<code>passwd</code>、<code>db</code>、<code>port</code>、<code>charset</code>、<code>cursorclass</code>.</li>
<li>自动改完提交完成更新数据库</li>
<li>通过<code>db</code>实例拿到一个连接<code>cursor</code> 每次都通过<code>cursor.execute()</code>执行增删改查操作sql语句</li>
<li>读取本地的文本文件</li>
</ol>
<p>大概就是这个意思</p>
<h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Create</span></div><div class="line"><span class="comment"># 读取数据</span></div><div class="line">fr = open(<span class="string">'douban_movie_clean.txt'</span>, <span class="string">'r'</span>)</div><div class="line"></div><div class="line">count = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fr:</div><div class="line">	count += <span class="number">1</span></div><div class="line">	<span class="comment"># count表示当前处理到第几行了</span></div><div class="line">	<span class="keyword">print</span> count</div><div class="line">	<span class="comment"># 跳过表头</span></div><div class="line">	<span class="keyword">if</span> count == <span class="number">1</span>:</div><div class="line">		<span class="keyword">continue</span></div><div class="line"></div><div class="line">	<span class="comment"># strip()函数可以去掉字符串两端的空白符</span></div><div class="line">	<span class="comment"># split()函数按照给定的分割符将字符串分割为列表</span></div><div class="line">	line = line.strip().split(<span class="string">'^'</span>)</div><div class="line">	<span class="comment"># 插入数据，注意对齐字段</span></div><div class="line">	<span class="comment"># execute()函数第一个参数为要执行的SQL命令</span></div><div class="line">	<span class="comment"># 这里用字符串格式化的方法生成一个模板</span></div><div class="line">	<span class="comment"># %s表示一个占位符</span></div><div class="line">	<span class="comment"># 第二个参数为需要格式化的参数，传入到模板中</span></div><div class="line">	cursor.execute(<span class="string">"insert into movie(title, url, rate, length, description) values(%s, %s, %s, %s, %s)"</span>, [line[<span class="number">1</span>], line[<span class="number">2</span>], line[<span class="number">4</span>], line[<span class="number">-3</span>], line[<span class="number">-1</span>]])</div><div class="line"></div><div class="line"><span class="comment"># 关闭读文件</span></div><div class="line">fr.close()</div></pre></td></tr></table></figure>
<p>通过我们拿到的<code>cursor</code>连接实例来执行<code>cursor.execute()</code>函数进行<code>sql</code>的插入操作.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/Pythoncode2.png" alt=""></p>
<p>来看下结果<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/sqlresult.png" alt=""></p>
<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>更新数据 比如我想把id=1的记录更新一下<code>title</code>字段和<code>length</code>长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Update</span></div><div class="line">cursor.execute(<span class="string">"update movie set title=%s, length=%s where id=1"</span>, [<span class="string">'孙亚洲'</span>, <span class="number">999</span>])</div></pre></td></tr></table></figure>
<h4 id="读取数据-1"><a href="#读取数据-1" class="headerlink" title="读取数据"></a>读取数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Read</span></div><div class="line">cursor.execute(<span class="string">"select title, length from movie where id=1"</span>)</div><div class="line">movies = cursor.fetchone()</div></pre></td></tr></table></figure>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Delete</span></div><div class="line">cursor.execute(<span class="string">"delete from movie where id=%s"</span>,[<span class="number">2</span>])</div></pre></td></tr></table></figure>
<hr>
<p>下面看下完成的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding:utf8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">"utf8"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> MySQLdb</div><div class="line"><span class="keyword">import</span> MySQLdb.cursors</div><div class="line"></div><div class="line">db = MySQLdb.connect(host=<span class="string">'127.0.0.1'</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'root'</span>, db=<span class="string">'douban'</span>, port=<span class="number">8889</span>, charset=<span class="string">'utf8'</span>, cursorclass=MySQLdb.cursors.DictCursor)</div><div class="line">db.autocommit(<span class="keyword">True</span>)</div><div class="line">cursor = db.cursor()</div><div class="line"></div><div class="line">fr = open(<span class="string">'douban_movie_clean.txt'</span>,<span class="string">'r'</span>)</div><div class="line"></div><div class="line"><span class="comment"># Create</span></div><div class="line">count = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fr:</div><div class="line">	count += <span class="number">1</span></div><div class="line">	<span class="keyword">print</span> count</div><div class="line">	<span class="keyword">if</span> count == <span class="number">1</span>:</div><div class="line">		<span class="keyword">continue</span></div><div class="line">	line = line.strip().split(<span class="string">'^'</span>)</div><div class="line">	cursor.execute(<span class="string">"insert into movie(title, url, rate, length, description) values(%s, %s, %s, %s, %s)"</span>, [line[<span class="number">1</span>], line[<span class="number">2</span>], line[<span class="number">4</span>], line[<span class="number">-3</span>], line[<span class="number">-1</span>]])</div><div class="line">fr.close()</div><div class="line"></div><div class="line"><span class="comment"># Update</span></div><div class="line">cursor.execute(<span class="string">"update movie set title=%s, length=%s where id=1"</span>, [<span class="string">'孙亚洲'</span>, <span class="number">999</span>])</div><div class="line"></div><div class="line"><span class="comment"># Read</span></div><div class="line">cursor.execute(<span class="string">"select title, length from movie where id=1"</span>)</div><div class="line">movies = cursor.fetchone()</div><div class="line"></div><div class="line"><span class="keyword">print</span> len(movies)</div><div class="line"><span class="comment"># print movies[0]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Delete</span></div><div class="line"></div><div class="line">cursor.execute(<span class="string">"delete from movie where id=%s"</span>,[<span class="number">2</span>])</div><div class="line"></div><div class="line"></div><div class="line">cursor.close()</div><div class="line">db.close()</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过学习<code>python</code>操作数据库很有收获,想起了大学李月辉老师教我怎么用java连接数据库.<br>在工作中我们可能会遇到一大堆数据如何插入到数据等问题,通过学习了本章内容可以很容易的处理批量数据.</p>
<p>关于更多的SQL语句<br>参考<a href="http://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="external">SQL 教程</a></p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180113Python-MySQL/mysql-python.png&quot; alt=&quot;&quot;
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web开发" scheme="https://www.sunyazhou.com/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="python" scheme="https://www.sunyazhou.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>AVAudioSession-Category各种姿势</title>
    <link href="https://www.sunyazhou.com/2018/01/12/20180112AVAudioSession-Category/"/>
    <id>https://www.sunyazhou.com/2018/01/12/20180112AVAudioSession-Category/</id>
    <published>2018-01-12T02:32:18.000Z</published>
    <updated>2018-06-04T08:44:05.530Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180112AVAudioSession-Category/ASPG_intro_2x.png" alt="AVAudioSession"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2018新年第一篇, 梳理<code>AVAudioSession</code>的<code>Category</code>,解决音频开发中的各种播放被打断或者首次启动时无声音的问题</p>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>由于<code>iOS</code>系统的特殊性,所有<code>App</code>共用一个<code>AVAudioSession</code>所以这个会话是个单例对象.(<code>macOS</code>是支持同时播放多路音频文件)</p>
<p>当遇到<code>插拔耳机</code>,<code>接电话</code>,<code>调起 siri</code>,等等,就出现音频会话被系统时间打断等行为表现:</p>
<ul>
<li>是进行录音还是播放？</li>
<li>当系统静音键按下时该如何表现？</li>
<li>是从扬声器还是从听筒里面播放声音？</li>
<li>插拔耳机后如何表现？</li>
<li>来电话/闹钟响了后如何表现？</li>
<li>其他音频App启动后如何表现？</li>
</ul>
<h3 id="Session默认行为"><a href="#Session默认行为" class="headerlink" title="Session默认行为"></a>Session默认行为</h3><ul>
<li>可以进行播放，但是不能进行录制。</li>
<li>当用户将手机上的静音拨片拨到“静音”状态时，此时如果正在播放音频，那么播放内容会被静音。</li>
<li>当用户按了手机的锁屏键或者手机自动锁屏了，此时如果正在播放音频，那么播放会静音并被暂停。</li>
<li>如果你的App在开始播放的时候，此时QQ音乐等其他App正在播放，那么其他播放器会被静音并暂停。</li>
</ul>
<p><code>AVAudioSession</code>默认的行为相当于设置了<code>Category</code>为<code>AVAudioSessionCategorySoloAmbient</code></p>
<p>示例代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)configSession&#123;	</div><div class="line">    [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategorySoloAmbient</span> error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AVAudioSession"><a href="#AVAudioSession" class="headerlink" title="AVAudioSession"></a>AVAudioSession</h3><p>上边说了 这个类是个单例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">+ (<span class="built_in">AVAudioSession</span> *)sharedInstance;</div></pre></td></tr></table></figure>
<p>通过上边方法获得单例</p>
<p>虽然系统会在App启动的时候，激活这个唯一的<code>AVAudioSession</code>，但是最好还是在自己用的时候再次进行激活：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (BOOL)setActive:(BOOL)active error:(NSError * _Nullable *)outError;</div></pre></td></tr></table></figure>
<p>通过设置<code>active</code>为<code>YES</code>激活<code>Session</code>，设置为<code>NO</code>解除<code>Session</code>的激活状态。<code>BOOL</code>返回值表示是否成功，如果失败的话可以通过<code>NSError</code>的<code>error.localizedDescription</code>查看出错原因。</p>
<blockquote>
<p>因为<code>AVAudioSession</code>会影响其他<code>App</code>的表现，当自己<code>App</code>的<code>Session</code>被激活，其他<code>App</code>的就会被解除激活.</p>
</blockquote>
<p><strong>如何要让自己的<code>Session</code>解除激活后恢复其他<code>App Session</code>的激活状态呢?</strong></p>
<p>此时可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- (BOOL)setActive:(BOOL)active withOptions:(AVAudioSessionSetActiveOptions)options error:(NSError * _Nullable *)outError;</div></pre></td></tr></table></figure>
<p><strong>这里的<code>options</code>传入<code>AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation</code>即可.</strong></p>
<p>当然，也可以通过<code>otherAudioPlaying</code>变量来提前判断当前是否有其他App在播放音频。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Current Category:%@"</span>, [<span class="built_in">AVAudioSession</span> sharedInstance].category); <span class="comment">//返回当前 category</span></div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">Current Category:AVAudioSessionCategorySoloAmbien</div></pre></td></tr></table></figure>
<h3 id="七大Category"><a href="#七大Category" class="headerlink" title="七大Category"></a>七大Category</h3><p>下面介绍一下<code>AVAudioSession</code>非常重要的七种<code>Category</code>.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#pragma mark -- Values for the category property --</span></div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionCategoryAmbient</span>;</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionCategorySoloAmbient</span>;</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionCategoryPlayback</span>;</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionCategoryRecord</span>;</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionCategoryPlayAndRecord</span>;</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionCategoryAudioProcessing</span> <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">3</span>_0, <span class="number">10</span>_0) __TVOS_PROHIBITED __WATCHOS_PROHIBITED;</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionCategoryMultiRoute</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div></pre></td></tr></table></figure>
<p><code>AVAudioSession</code>将使用音频的场景分成七大类，通过设置<code>Session</code>为不同的类别，可以控制：</p>
<ul>
<li>当App激活Session的时候，是否会打断其他不支持混音的App声音</li>
<li>当用户触发手机上的“静音”键时或者锁屏时，是否相应静音</li>
<li>当前状态是否支持录音</li>
<li>当前状态是否支持播放</li>
<li>每个App启动时都会设置成上面说的默认状态，即其他App会被中断同时相应“静音”键的播放模式。通过下表可以细分每个类别的支持情况：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">当按“静音”或者锁屏是是否静音</th>
<th style="text-align:center">是否引起不支持混音的App中断</th>
<th style="text-align:center">是否支持录音和播放</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AVAudioSessionCategoryAmbient</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">只支持播放</td>
</tr>
<tr>
<td style="text-align:center">AVAudioSessionCategoryAudioProcessing</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">都不支持</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td style="text-align:center">AVAudioSessionCategoryMultiRoute</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">既可以录音也可以播放</td>
</tr>
<tr>
<td style="text-align:center">AVAudioSessionCategoryPlayAndRecord</td>
<td style="text-align:center">否</td>
<td style="text-align:center">默认不引起</td>
<td style="text-align:center">既可以录音也可以播放</td>
</tr>
<tr>
<td style="text-align:center">AVAudioSessionCategoryPlayback</td>
<td style="text-align:center">否</td>
<td style="text-align:center">默认引起</td>
<td style="text-align:center">只用于播放</td>
</tr>
<tr>
<td style="text-align:center">AVAudioSessionCategoryRecord</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">只用于录音</td>
</tr>
<tr>
<td style="text-align:center">AVAudioSessionCategorySoloAmbient</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">只用于播放</td>
</tr>
</tbody>
</table>
<p>可以看到，其实默认的就是<code>AVAudioSessionCategorySoloAmbient</code>类别.<br>从表中我们可以总结如下：  </p>
<ul>
<li><p><em><code>AVAudioSessionCategoryAmbient</code>:只用于播放音乐时，并且可以和QQ音乐同时播放，比如玩游戏的时候还想听QQ音乐的歌，那么把游戏播放背景音就设置成这种类别。同时，当用户锁屏或者静音时也会随着静音，这种类别基本使用所有App的背景场景。</em></p>
</li>
<li><p><em><code>AVAudioSessionCategoryAudioProcessing</code>:主要用于音频格式处理，一般可以配合AudioUnit进行使用.</em></p>
</li>
<li><p><em><code>AVAudioSessionCategoryMultiRoute</code>:想象一个DJ用的App，手机连着HDMI到扬声器播放当前的音乐，然后耳机里面播放下一曲，这种常人不理解的场景，这个类别可以支持多个设备输入输出.</em></p>
</li>
<li><p><em><code>AVAudioSessionCategoryPlayAndRecord</code>: 如果既想播放又想录制该用什么模式呢？比如VoIP，打电话这种场景，PlayAndRecord就是专门为这样的场景设计的.</em></p>
</li>
<li><p><em><code>AVAudioSessionCategoryPlayback</code>:如果锁屏了还想听声音怎么办？用这个类别，比如App本身就是播放器，同时当App播放时，其他类似QQ音乐就不能播放了。所以这种类别一般用于播放器类App.</em></p>
</li>
<li><p><em><code>AVAudioSessionCategoryRecord</code>:有了播放器，肯定要录音机，比如微信语音的录制，就要用到这个类别，既然要安静的录音，肯定不希望有QQ音乐了，所以其他播放声音会中断。想想微信语音的场景，就知道什么时候用他了.</em></p>
</li>
<li><p><em><code>AVAudioSessionCategorySoloAmbient</code>:也是只用于播放,但是和”AVAudioSessionCategoryAmbient”不同的是，用了它就别想听QQ音乐了，比如不希望QQ音乐干扰的App，类似节奏大师。同样当用户锁屏或者静音时也会随着静音，锁屏了就玩不了节奏大师了.</em></p>
</li>
</ul>
<p>了解了这七大类别，我们就可以根据自己的需要进行对应类别的设置了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)setCategory:(<span class="built_in">NSString</span> *)category error:(<span class="built_in">NSError</span> **)outError;</div></pre></td></tr></table></figure>
<p>传入对应的列表枚举即可。如果返回<code>NO</code>可以通过<code>NSError</code>的<code>error.localizedDescription</code>查看原因.</p>
<p>可以通过:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *availableCategories;</div></pre></td></tr></table></figure>
<p>属性,查看当前设备支持哪些类别,然后再进行设置,从而保证传入参数的合法,减少错误的可能.</p>
<p>比如使用如下代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Current Category:%@"</span>, [<span class="built_in">AVAudioSession</span> sharedInstance].category);</div><div class="line">   <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">   [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:&amp;error];</div><div class="line">   <span class="keyword">if</span> (<span class="literal">nil</span> != error) &#123;</div><div class="line">       <span class="built_in">NSLog</span>(<span class="string">@"set Option error %@"</span>, error.localizedDescription);</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"Current Category:%@"</span>, [<span class="built_in">AVAudioSession</span> sharedInstance].category);</div></pre></td></tr></table></figure>
<p>此时在播放音乐的时候，再去按下静音键，会发现，音乐还在继续播放，不会被静音。</p>
<h3 id="类别的选项-Category-Options"><a href="#类别的选项-Category-Options" class="headerlink" title="类别的选项(Category Options)"></a>类别的选项(Category Options)</h3><p>上面介绍的这个七大类别，可以认为是设定了七种主场景，而这七类肯定是不能满足开发者所有的需求的。<code>CoreAudio</code>提供的方法是，<strong>首先定下七种的一种基调,然后在进行微调.<code>CoreAudio</code>为每种<code>Category</code>都提供了些许选项来进行微调.</strong></p>
<p>在设置完类别后，可以通过:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">AVAudioSessionCategoryOptions</span> categoryOptions;</div></pre></td></tr></table></figure>
<p>属性,查看当前类别设置了哪些选项,注意这里的返回值是<code>AVAudioSessionCategoryOptions</code>,<strong>实际是多个<code>options</code>的<code>|</code>运算</strong>.<br>默认情况下是<code>0</code>.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">AVAudioSessionCategoryOptions</span>)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">AVAudioSessionCategoryOptionMixWithOthers</span>			= <span class="number">0x1</span>,</div><div class="line">	<span class="built_in">AVAudioSessionCategoryOptionDuckOthers</span>				= <span class="number">0x2</span>,</div><div class="line">	<span class="built_in">AVAudioSessionCategoryOptionAllowBluetooth</span>	__TVOS_PROHIBITED __WATCHOS_PROHIBITED		= <span class="number">0x4</span>,</div><div class="line">	<span class="built_in">AVAudioSessionCategoryOptionDefaultToSpeaker</span> __TVOS_PROHIBITED __WATCHOS_PROHIBITED		= <span class="number">0x8</span>,</div><div class="line">	<span class="built_in">AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0) = <span class="number">0x11</span>,</div><div class="line">	<span class="built_in">AVAudioSessionCategoryOptionAllowBluetoothA2DP</span> API_AVAILABLE(ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>)) = <span class="number">0x20</span>,</div><div class="line">	<span class="built_in">AVAudioSessionCategoryOptionAllowAirPlay</span> API_AVAILABLE(ios(<span class="number">10.0</span>), tvos(<span class="number">10.0</span>)) __WATCHOS_PROHIBITED = <span class="number">0x40</span>,</div><div class="line">&#125; <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">适用类别</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AVAudioSessionCategoryOptionMixWithOthers</td>
<td style="text-align:left">AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute</td>
<td style="text-align:center">是否可以和其他后台App进行混音</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionCategoryOptionDuckOthers</td>
<td style="text-align:left">AVAudioSessionCategoryAmbient, AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute</td>
<td style="text-align:center">是否压低其他App声音</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionCategoryOptionAllowBluetooth</td>
<td style="text-align:left">AVAudioSessionCategoryRecord and AVAudioSessionCategoryPlayAndRecord</td>
<td style="text-align:center">是否支持蓝牙耳机</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionCategoryOptionDefaultToSpeaker</td>
<td style="text-align:left">AVAudioSessionCategoryPlayAndRecord</td>
<td style="text-align:center">是否默认用免提声音</td>
</tr>
</tbody>
</table>
<blockquote>
<p>目前主要的选项有这几种，都有对应的使用场景，除此之外，还有iOS9之后新增加的一些</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">适用类别</th>
<th style="text-align:center">作用</th>
<th style="text-align:left">最低适用系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers</td>
<td style="text-align:left">–</td>
<td style="text-align:center">–</td>
<td style="text-align:left">iOS 9</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionCategoryOptionAllowBluetoothA2DP</td>
<td style="text-align:left">–</td>
<td style="text-align:center">–</td>
<td style="text-align:left">iOS 10</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionCategoryOptionAllowAirPlay</td>
<td style="text-align:left">–</td>
<td style="text-align:center">支持蓝牙A2DP耳机和AirPlay</td>
<td style="text-align:left">iOS 10</td>
</tr>
</tbody>
</table>
<p>下面介绍一下每个子场景选项的作用:</p>
<ul>
<li><p><em><code>AVAudioSessionCategoryOptionMixWithOthers</code>:如果确实用的<code>AVAudioSessionCategoryPlayback</code>实现的一个背景音，可是，又想和QQ音乐并存，那么可以在<code>AVAudioSessionCategoryPlayback</code>类别下在设置这个选项，就可以实现共存了.</em></p>
</li>
<li><p><em><code>AVAudioSessionCategoryOptionDuckOthers</code>：在实时通话的场景，比如QQ音乐，当进行视频通话的时候，会发现QQ音乐自动声音降低了，此时就是通过设置这个选项来对其他音乐App进行了压制.</em></p>
</li>
<li><p><em><code>AVAudioSessionCategoryOptionAllowBluetooth</code>：如果要支持蓝牙耳机电话，则需要设置这个选项.</em></p>
</li>
<li><p><em><code>AVAudioSessionCategoryOptionDefaultToSpeaker</code>： 如果在VoIP模式下，希望默认打开免提功能，需要设置这个选项.</em></p>
</li>
</ul>
<p>通过接口:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)setCategory:(<span class="built_in">NSString</span> *)category withOptions:(<span class="built_in">AVAudioSessionCategoryOptions</span>)options error:(<span class="built_in">NSError</span> **)outError;</div></pre></td></tr></table></figure>
<p>来对当前的类别进行选项(options)的设置.</p>
<p>实例代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)xxxMethod&#123;</div><div class="line">    [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> withOptions:<span class="built_in">AVAudioSessionCategoryOptionMixWithOthers</span> error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"set Option error %@"</span>, error.localizedDescription);</div><div class="line">    &#125;</div><div class="line">    options = [[<span class="built_in">AVAudioSession</span> sharedInstance] categoryOptions];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Category[%@] has %lu options"</span>,  [<span class="built_in">AVAudioSession</span> sharedInstance].category, options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，如果打开QQ音乐播放器，然后再开始进行播放，会发现，QQ和我们的实例都在播放，并且进行了自动混音。</p>
<h3 id="七大模式"><a href="#七大模式" class="headerlink" title="七大模式"></a>七大模式</h3><p>通过上面的<code>七大类别</code>:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#pragma mark -- Values for the mode property --</span></div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionModeDefault</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionModeVoiceChat</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionModeGameChat</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionModeVideoRecording</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionModeMeasurement</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionModeMoviePlayback</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionModeVideoChat</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</div><div class="line"></div><div class="line"><span class="built_in">AVF_EXPORT</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">AVAudioSessionModeSpokenAudio</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</div></pre></td></tr></table></figure>
<p>我们基本覆盖了常用的<strong>主场景</strong>，在每个主场景中可以通过<code>Option</code>进行<strong>微调</strong>。为此<code>CoreAudio</code>提供了七大比较常见微调后的子场景。叫做<code>各个类别的模式</code>.</p>
<table>
<thead>
<tr>
<th style="text-align:left">模式Mode</th>
<th style="text-align:left">适用的类别</th>
<th style="text-align:center">场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AVAudioSessionModeDefault</td>
<td style="text-align:left">所有类别</td>
<td style="text-align:center">默认的模式</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionModeVoiceChat</td>
<td style="text-align:left">AVAudioSessionCategoryPlayAndRecord</td>
<td style="text-align:center">VoIP</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionModeGameChat</td>
<td style="text-align:left">AVAudioSessionCategoryPlayAndRecord</td>
<td style="text-align:center">游戏录制，由GKVoiceChat自动设置，无需手动调用</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionModeVideoRecording</td>
<td style="text-align:left">AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord</td>
<td style="text-align:center">录制视频时</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionModeMoviePlayback</td>
<td style="text-align:left">AVAudioSessionCategoryPlayback</td>
<td style="text-align:center">视频播放</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionModeMeasurement</td>
<td style="text-align:left">AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayback</td>
<td style="text-align:center">最小系统</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionModeVideoChat</td>
<td style="text-align:left">AVAudioSessionCategoryPlayAndRecord</td>
<td style="text-align:center">视频通话</td>
</tr>
</tbody>
</table>
<p>每个模式有其适用的类别，所以，并不是有“七七 四十九”种组合。如果当前处于的类别下没有这个模式，那么是设置不成功的。  </p>
<p>设置完Category后可以通过如下代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *availableModes;</div></pre></td></tr></table></figure>
<p>这个属性,查看其支持哪些属性，做合法性校验。</p>
<p>下面说一下具体应用场景:</p>
<ul>
<li><p><strong><code>AVAudioSessionModeDefault</code>： 每种类别默认的就是这个模式，所有要想还原的话，就设置成这个模式。</strong></p>
</li>
<li><p><strong><code>AVAudioSessionModeVoiceChat</code>：主要用于VoIP场景，此时系统会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集。此时有个副作用，他会设置类别的选项为<code>AVAudioSessionCategoryOptionAllowBluetooth</code>从而支持蓝牙耳机。</strong></p>
</li>
<li><p><strong><code>AVAudioSessionModeVideoChat</code> ： 主要用于视频通话，比如QQ视频、FaceTime。时系统也会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集并且会设置类别的选项为<code>AVAudioSessionCategoryOptionAllowBluetooth</code>和<code>AVAudioSessionCategoryOptionDefaultToSpeaker</code>。</strong></p>
</li>
<li><p><strong><code>AVAudioSessionModeGameChat</code> ： 适用于游戏App的采集和播放，比如“GKVoiceChat”对象，一般不需要手动设置.</strong></p>
</li>
</ul>
<blockquote>
<p>另外几种和音频APP关系不大，一般我们只需要关注VoIP或者视频通话即可。</p>
</blockquote>
<p>通过调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)setMode:(<span class="built_in">NSString</span> *)mode error:(<span class="built_in">NSError</span> **)outError;</div></pre></td></tr></table></figure>
<p>可以在设置<code>Category</code>之后再设置模式。</p>
<p>当然，这些模式只是<code>CoreAduio</code>总结的，不一定完全满足要求，对于具体的模式，在<code>iOS10</code>中还是可以微调的。  </p>
<p>通过接口:  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)setCategory:(<span class="built_in">NSString</span> *)category mode:(<span class="built_in">NSString</span> *)mode options:(<span class="built_in">AVAudioSessionCategoryOptions</span>)options error:(<span class="built_in">NSError</span> **)outError;</div></pre></td></tr></table></figure>
<p>但是在<code>iOS9</code>及以下就只能在<code>Category</code>上调了，其实本质是一样的，可以认为是个API语法糖，接口封装.</p>
<h3 id="系统中断响应"><a href="#系统中断响应" class="headerlink" title="系统中断响应"></a>系统中断响应</h3><p>上面说的这些<code>Categor、</code>Option<code>以及</code>Mode`都是对自己作为播放主体时的表现，但是假设，现在正在播放着，突然来电话了、闹钟响了或者你在后台放歌但是用户启动其他App用上面的方法影响的时候，我们的App该如何表现呢？最常用的场景当然是先暂停，待恢复的时候再继续。那我们的App要如何感知到这个终端以及何时恢复呢？</p>
<p><code>AVAudioSession</code>提供了多种<code>Notifications</code>来进行此类状况的通知。其中将来电话、闹铃响等都归结为一般性的中断</p>
<p>用<code>AVAudioSessionInterruptionNotification</code>来通知。其回调回来的<code>userInfo</code>主要包含两个键：</p>
<ul>
<li><p><em><code>AVAudioSessionInterruptionTypeKey</code>： 取值为<code>AVAudioSessionInterruptionTypeBegan</code>表示中断开始，我们应该暂停播放和采集，取值为<code>AVAudioSessionInterruptionTypeEnded</code>表示中断结束，我们可以继续播放和采集。</em></p>
</li>
<li><p><em><code>AVAudioSessionInterruptionOptionKey</code>： 当前只有一种值<code>AVAudioSessionInterruptionOptionShouldResume</code>表示此时也应该恢复继续播放和采集。</em></p>
</li>
</ul>
<p><strong>而将其他<code>App</code>占据<code>AudioSession</code>的时候用<code>AVAudioSessionSilenceSecondaryAudioHintNotification</code>来进行通知。其回调回来的</strong><code>userInfo</code>键为:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">AVAudioSessionSilenceSecondaryAudioHintTypeKey</span></div></pre></td></tr></table></figure>
<p>可能包含的值:</p>
<ul>
<li><p><code>AVAudioSessionSilenceSecondaryAudioHintTypeBegin</code>： 表示其他<code>App</code>开始占据<code>Session</code>.</p>
</li>
<li><p><code>AVAudioSessionSilenceSecondaryAudioHintTypeEnd</code>: 表示其他<code>App</code>开始释放<code>Session</code>.</p>
</li>
</ul>
<h3 id="外设改变"><a href="#外设改变" class="headerlink" title="外设改变"></a>外设改变</h3><p>除了其他<code>App</code>和系统服务，会对我们的<code>App</code>产生影响以外，用户的手也会对我们产生影响。默认情况下，<code>AudioSession</code>会在<code>App</code>启动时选择一个最优的输出方案，比如插入耳机的时候，就用耳机。但是这个过程中，用户可能拔出耳机，我们App要如何感知这样的情况呢？</p>
<p>同样<code>AVAudioSession</code>也是通过<code>Notifications</code>来进行此类状况的通知。</p>
<p>假设有这样的App<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/9d2068989e1b3da5c3b2afaa85fd24d07010cceb/20180112AVAudioSession-Category/route_change.png" alt=""></p>
<p>最开始在录音时，用户插入和拔出耳机我们都停止录音，这里通过<code>Notification</code>来通知有新设备了，或者设备被退出了，然后我们控制停止录音。或者在播放时，当耳机被拔出出时，<code>Notification</code>给了通知，我们先暂停音乐播放，待耳机插回时，在继续播放。</p>
<p>在<code>NSNotificationCenter</code>中对<code>AVAudioSessionRouteChangeNotification</code>进行注册。在其<code>userInfo</code>中有键：</p>
<ul>
<li><code>AVAudioSessionRouteChangeReasonKey</code> : 表示改变的原因</li>
<li><code>AVAudioSessionSilenceSecondaryAudioHintTypeKey</code>： 和上面的中断意义意义一样。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">枚举值</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AVAudioSessionRouteChangeReasonUnknown</td>
<td style="text-align:center">未知原因</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionRouteChangeReasonNewDeviceAvailable</td>
<td style="text-align:center">有新设备可用</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionRouteChangeReasonOldDeviceUnavailable</td>
<td style="text-align:center">老设备不可用</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionRouteChangeReasonCategoryChange</td>
<td style="text-align:center">类别改变了</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionRouteChangeReasonOverride</td>
<td style="text-align:center">App重置了输出设置</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionRouteChangeReasonWakeFromSleep</td>
<td style="text-align:center">从睡眠状态呼醒</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionRouteChangeReasonNoSuitableRouteForCategory</td>
<td style="text-align:center">当前Category下没有合适的设备</td>
</tr>
<tr>
<td style="text-align:left">AVAudioSessionRouteChangeReasonRouteConfigurationChange</td>
<td style="text-align:center">Rotuer的配置改变了</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>AVAudioSession</code>构建了一个音频使用生命周期的上下文。当前状态是否可以录音、对其他App有怎样的影响、是否响应系统的静音键、如何感知来电话了等都可以通过它来实现。尤为重要的是<code>AVAudioSession</code>不仅可以和<code>AVFoundation</code>中的<code>AVAudioPlyaer</code>/<code>AVAudioRecorder</code>配合，其他录音/播放工具比如<code>AudioUnit</code>、<code>AudioQueueService</code>也都需要他进行录音、静音等上下文配合。</p>
<p><a href="https://www.jianshu.com/p/3e0a399380df" target="_blank" rel="external">参考</a></p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20180112AVAudioSession-Category/ASPG_intro_2x
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2017年终总结</title>
    <link href="https://www.sunyazhou.com/2017/12/31/20171230Final-Summary/"/>
    <id>https://www.sunyazhou.com/2017/12/31/20171230Final-Summary/</id>
    <published>2017-12-31T02:46:20.000Z</published>
    <updated>2018-03-11T23:32:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/2017FinalSummart1.jpeg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>时间像车轮一样在飞转<br>历史像江河一样在流淌<br>整整走过了365个风雨历程<br>2017年过的如此不寻常<br>一度春夏秋冬 一度雨雪风霜<br>一度翻山越岭 一度起伏延宕  </p>
</blockquote>
<p>又一年过去了,我也得墨守成规的按时交出我的年终总结了,为了不标新立异,我必须尽量不废话.(<strong>talk is cheap, show me the code!</strong>)</p>
<h2 id="2017回顾"><a href="#2017回顾" class="headerlink" title="2017回顾"></a>2017回顾</h2><p>这一年的重点事件主要如下:</p>
<ul>
<li>技术</li>
<li>买房</li>
<li>工作</li>
<li>书法 </li>
<li>读书</li>
<li>运动</li>
<li>驾照</li>
</ul>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>这一年让我唯一有些许成就感的事情莫过于我搭建了自己的技术博客,能在这里记录我的技术成长和生活中的点点滴滴.</p>
<p>从年初我搭建博客开始至今已发表整整45篇.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/2017FinalSummary_blog.png" alt="blog"></p>
<p>正如我的<strong>关于</strong>页面说的,我并没有对它的品质太过于苛求,尽量记录一下容易忘记的技术和生活经验. 虽然大家看到这些并没有太过留意,但我自己确觉得如数家珍,毕竟这是一笔财富.当我几年后会看这篇年终总结的时候,希望自己<strong>没有因为虚度年华而悔恨,也没有因为碌碌无为而羞耻</strong>.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/2017FinalSummary_blog2.png" alt=""></p>
<p>我是一个不喜欢玩各种游戏的90后,每天看着统计后台才找回一点干活的心情.</p>
<p>今年的技术多数集中在多媒体上,每天和音视频斗智斗勇.今年的前半部分在开发TCP的聊天应用叫<code>百度Hi for mac</code>. 当然厂长<a href="https://baike.baidu.com/item/%E6%9D%8E%E5%BD%A6%E5%AE%8F/125160?fr=aladdin" target="_blank" rel="external">Robin(李彦宏)</a>)也在用. <em>对于这个满脑子人工智能一门心思研究无人驾驶每次产品都落地的不咋地整整核心技术人员总留不住的厂长,我递过去了我的辞职申请</em>.今年下半年在全力研究多媒体短视频相关的开发,<code>Open GL</code>,<code>GPUImage</code>,<code>AV Foundation</code>…… 吭哧吭哧(kengchi 一声). 直到写博客现在为止,才刚刚研究完<code>AV Foundation</code>最后一页. 搞了很久技术深感在某些领域需要深耕,不能盲目的跟风,还得脚踏实地.</p>
<p>28岁,90后.这一年感觉技术上没有啥成就感,到有如下感慨:</p>
<blockquote>
<p>也许大神都是命中注定的,而我很不幸,没有被注定.</p>
</blockquote>
<hr>
<h3 id="买房"><a href="#买房" class="headerlink" title="买房"></a>买房</h3><p>这是我2017年经历过最始料未及的一个大事件.</p>
<h4 id="看房"><a href="#看房" class="headerlink" title="看房"></a>看房</h4><p>这事得从2016的十一长假说起, 我回哈尔滨看房</p>
<p>从哈尔滨万达广场沿着 哈尔滨大街 步行, 到群力 又步行回来.跟我一个比较要好的高中室友.</p>
<p>大概的路线是这样的:</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/2017FinalSummary_findhouse.png" alt="看房"></p>
<p>据我后来统计 每天至少步行18公里以上. </p>
<p>于是我得出看房的经验列表:</p>
<table>
<thead>
<tr>
<th style="text-align:center">区域</th>
<th style="text-align:center">房价</th>
<th style="text-align:center">房屋类型</th>
<th style="text-align:center">装修类型</th>
<th style="text-align:center">发展潜力</th>
<th style="text-align:center">推荐看房装备</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">哈西</td>
<td style="text-align:center">均价8k~1w</td>
<td style="text-align:center">期房多/现房少</td>
<td style="text-align:center">毛坯多/精/简装少</td>
<td style="text-align:center">高铁/学区/商圈/地铁</td>
<td style="text-align:center">电动车+跑鞋</td>
</tr>
<tr>
<td style="text-align:center">群力</td>
<td style="text-align:center">均价6k~9k</td>
<td style="text-align:center">期房少/现房少</td>
<td style="text-align:center">毛坯</td>
<td style="text-align:center">周边啥也没有(关东古巷/松花江)</td>
<td style="text-align:center">电动车+跑鞋</td>
</tr>
<tr>
<td style="text-align:center">其它</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">二手居多</td>
<td style="text-align:center">周边配套没调研</td>
<td style="text-align:center">电动车+跑鞋</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意:<em>为啥我推荐的是电动车+跑鞋,因为我看房时发现有的区域跨度太大,需要车最好,有的区域跨度小有车没地方停,尤其是一些还没建成的地块,你去了漫天漂灰,泥泞不堪,你开车不是刷车就是麻烦耽误时间,车速太快你看不清楚哪是哪,走走停停车我认为不方便,摩托车太大一般,只有电动车最合适,一个骑车一个看,哪里不清楚看哪.但需要一个续航里程高点的电动车.还有跑鞋,看房必须得走,上楼下楼,这个单元那个小区的.没有一双舒服的鞋走一上午就知道啥滋味了.</em></p>
</blockquote>
<p>可惜我没车,只有一双腿和一双<code>new balance</code>跑鞋,每天走上18公里,可能是鞋垫太舒服了,脚都磨红了都没起泡,我还暗自慨叹我自己多高明得回没穿别的鞋,可是没当我高兴一会儿就发现,鞋垫快磨碎了. 所以建议大家看房要 <code>管住嘴</code>,<code>带够水</code>,<code>迈开腿</code>,别吃太饱了.</p>
<table>
<thead>
<tr>
<th style="text-align:center">我看过的房地产</th>
<th style="text-align:center">推荐意见和结论</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">有个叫什么红星城</td>
<td style="text-align:center">纯扯淡浪费时间 不推荐</td>
</tr>
<tr>
<td style="text-align:center">东方新天地</td>
<td style="text-align:center">缺钱的可以考虑,据说是房本下来很费劲</td>
</tr>
<tr>
<td style="text-align:center">恒大珺庭</td>
<td style="text-align:center">房屋朝向让我觉得难受,简装,怕费事的可以考虑,拎包入住大开发比较靠谱</td>
</tr>
<tr>
<td style="text-align:center">金爵万象</td>
<td style="text-align:center">貌似在新天地东边,墙皮子直掉不敢买,不推荐</td>
</tr>
<tr>
<td style="text-align:center">辰能溪树庭院</td>
<td style="text-align:center">精装,推荐,就是贵,估计都没有了</td>
</tr>
<tr>
<td style="text-align:center">北纬45度</td>
<td style="text-align:center">就剩公寓了,没住宅了,买不了了</td>
</tr>
<tr>
<td style="text-align:center">君贵东方瑞景</td>
<td style="text-align:center">售楼员挺二,清华大街南北还是城中村,一般,价格死贵还没啥亮点</td>
</tr>
<tr>
<td style="text-align:center">漫步巴黎</td>
<td style="text-align:center">没房了,剩下的都不咋好,房屋太大,内室很不适合我们东北人的习惯,一般</td>
</tr>
<tr>
<td style="text-align:center">百年俪景</td>
<td style="text-align:center">没房, 价格一般,房屋格局还行,喜欢安静的可以考虑,价格稍贵</td>
</tr>
<tr>
<td style="text-align:center">观江国际</td>
<td style="text-align:center">是我见过群力最贵的了当时1.5w 不过没啥好房子了,不差钱推荐</td>
</tr>
<tr>
<td style="text-align:center">其它</td>
<td style="text-align:center">基本没有好的,板楼基本都是期房还没有,高层不是时间长就各种不靠谱</td>
</tr>
</tbody>
</table>
<p>上述这些只代表我个人看法.</p>
<p>时间到达2017年1月份,过年回家</p>
<p>我趁这个时间点又去了几家,发现</p>
<p>房价 从<code>8</code>千涨到<code>1w</code>,恒大珺庭最为明显.十一的时候还有些好的户型,十一以后基本绝迹.剩下一堆破户型,要不挡光要么房屋布局狭窄.</p>
<h4 id="哈尔滨户口和北京公积金"><a href="#哈尔滨户口和北京公积金" class="headerlink" title="哈尔滨户口和北京公积金"></a>哈尔滨户口和北京公积金</h4><p>我是个北漂的码农大学毕业直接去了北京. 户口还不属于哈尔滨市.<br>据我跑完大部分的售楼处后,打听的公积金使用方式,</p>
<ol>
<li>北京的公积金如果想在哈尔滨市用必须是哈尔滨市户口才能用.</li>
<li>想办理哈尔滨市户口必须得买房,或者单位接收等集体户口.</li>
<li>想在<code>哈尔滨</code>买房用<code>北京公积金</code>必须得是<strong>哈尔滨市户口</strong>,别的地方用不了.</li>
</ol>
<p>写到这里我真的想骂娘了,但为了保持儒士的风范我还是忍了,我不得不说,这是个<strong>鸡生蛋</strong>,<strong>蛋生鸡</strong>的问题.</p>
<p>如果说农村户口想成为哈尔滨市市民是因为我们农村人每个人分块地的话,那我请政府收回我的土地,把我户口改成哈尔滨市户口.那块破土地如果能发家致富我又何必背井离乡去北漂.</p>
<h4 id="过年筹划买房"><a href="#过年筹划买房" class="headerlink" title="过年筹划买房"></a>过年筹划买房</h4><p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/haerbin_haxi.jpg" alt=""></p>
<p>回家过年,这年过得我心情都不在年上,心情很矛盾,过了初七就上班回北京了.我的家在绥化市海伦市.</p>
<p>回北京的两个月时间里,根本都没有什么干活的劲头,于是我就给父母打电话</p>
<p>我说了至今为止最具掷地有声的话.</p>
<p>我在电话中对父母说:”我在北京,距离哈尔滨1200多公里,你们说我是千里奔波去看房,还是你们去呢,我周末就两天假,去了回来最多也就能看上半天,你们在家没啥事距离哈尔滨那么近为啥不去帮我去看看房呢.”(父母每年都去外面打工)</p>
<blockquote>
<p>父母确实听了这一番话,也都感同身受</p>
</blockquote>
<p>于是俩人行动了起来, 一周跑了两趟哈尔滨.由于哈尔滨也没啥亲戚只能去了 回海伦,去了回海伦.</p>
<p>我的一番话起了决定性作用, 这俩人在周五打电话告诉我,他们看中了爱达88.回来吧！</p>
<h4 id="天时-地利-人和"><a href="#天时-地利-人和" class="headerlink" title="天时 地利 人和"></a><strong>天时</strong> <strong>地利</strong> <strong>人和</strong></h4><p>买房绝对是一件<code>天时</code>,<code>地利</code>,<code>人和</code>的事情.</p>
<p>我父母帮我看房这一周,我基本也没心情干活,我的老大(经理)看我的心情我都能猜到了,最后他给了我一周假,回家买房.</p>
<p>因为这一周我在办理各种银行的 收入证明,银行流水的打印贷款哈尔滨各种银行的模板,公积金等</p>
<p>北京的公积金如果想拿出来当首付,必须退出北京市公积金.相当于离开北京.<br>说白了就是得离职.</p>
<p>这段经历让我至今难忘,当时的真是进退维谷.</p>
<h4 id="坐飞机回家买房"><a href="#坐飞机回家买房" class="headerlink" title="坐飞机回家买房"></a>坐飞机回家买房</h4><p>2017年的3月某日凌晨5点,周六 天气:<strong>轻度雾霾</strong>,地点:去往北京首都国际机场T2航站楼的路上</p>
<p>前天晚上预约的滴滴专车早已在楼下等候,我和<code>我家那位</code>在最后一遍确认 户口本、身份证、公司人力资源部签发的各种银行的收入证明、各种银行卡、银行流水单…… 确认完毕 出发.</p>
<p>路上司机是个话唠  </p>
<p>司机说:”这是去哪!”<br>我说:”回家看看房”</p>
<p>…</p>
<p>司机说:”我们北京政府给我们分的房子 一平 才3000多,距离地铁不算太远”<br>我说:”北京人真好…国家都如此照顾”</p>
<p>…</p>
<p>司机说:”唉 都是这些外来人口把这房价搞起来的,要不我们还能再便宜点！”<br>我说:”…要啥自行车知足吧!”</p>
<p>司机说:”&amp;%&amp;*#$#&amp;#$#^#$^!”</p>
<p>…</p>
<p>我真都懒的和他吐口水.</p>
<blockquote>
<p>牛逼哄哄的北京人,你要是去哈尔滨租房,北京户口,哥的房子就双倍价格租你,不住就回北京,冰城人不太欢迎你这种得了便宜还不知足的北京土著</p>
</blockquote>
<p>终于到机场,雾霾貌似散去了不少.</p>
<p>东方航空的飞机 早已在停机坪等着值机(值机就是你选好你的座位)检票了.</p>
<p>打印取票…  </p>
<p>等了好长时间发现去太早了,不去太早也不行,就北京这交通还是宁愿早去三个小时也不能相信taxi.地铁绕道好远.</p>
<p>我看飞机票上边写着 9:58分到哈尔滨</p>
<p>…</p>
<p>检票…<br>登机…  </p>
<p>7:59</p>
<p>起飞 (起飞起了半个小时我服了,别告诉你要delay了,坐火车总晚点,坐飞机还晚点我也是醉了)</p>
<p>当飞机起飞开到北京的上空,早已没了雾霾,出现在眼前的是<code>祖国的万里长城</code>(这个时候如果能放上一首《我的中国心》你想起那首歌词, 长江…长城..),如果说去过长城觉得很没意思,那么当你在飞机上俯视它的时候,我觉得你会看到另一种心情,那感觉绝对前所未有.有机会大家可以试试,但要在天气非常好的时候,太阳刚从东方升起. 后来我才发现如果你是个海归的人才当你看到祖国的万里长城心理是什么滋味(你的飞机要降落在祖国的首都国际 机场,看着梦寐已久的万里长城).</p>
<blockquote>
<p>当时我的直觉告诉我,今天是个好兆头.买房应该十拿九稳.</p>
</blockquote>
<p>飞机穿越辽宁的上空,看到一架 <code>歼-15</code>貌似是战斗机 飞机腹部带着一颗导弹 直线向南飞去… 估计是每天执行任务,紧接着 就是白雪皑皑的 平原 尽览无余.</p>
<p>我刻意观察过,这雪的厚度 从略裹地表… 飞过吉林逐渐增加雪的厚度…到哈尔滨 太厚了.</p>
<p>飞行也就一个小时…</p>
<p>如果哈尔滨机场是我见过最破的机场那应该是我说错了,如果我说你看到一片<code>苞米地</code>还有稍许<code>电线杆子</code>飞机跑道的水泥地上都冻成冰了 青一块紫一块的 地表 看清后这是飞机起降的跑道你也许不信,但是这飞机就能在这种恶劣环境正常起降. 降落半个小时,飞行员这个屌丝 不知道干啥 飞行速度降落的时候慢的可怜,哈尔滨周边的村庄屯子 看的一清二楚,哎呀,当时那心情,我只能说我第一次坐飞机回哈尔滨,不知道太平机场周边太荒凉.</p>
<p>降落之后我总结  </p>
<p>原来 行程两个小时其实 中途飞行也就一个小时,起飞半个小时,降落半个小时.我能说啥呢,完美没晚点.这飞机开的我给你打101分.   </p>
<p>坐大巴到哈西…</p>
<p>下来大巴路过哈西站东广场,直奔爱达售楼处. </p>
<p><strong>奇迹的一幕发生了</strong>   </p>
<p>我吐了一口唾沫, 不偏不正, 沿着 广场上有地漏缝隙的大理石<code>直直</code>吐到了下水道,吐进去了,连边都没沾,就是这么准, 我当时惊呆了,可惜当时着急没照相. </p>
<blockquote>
<p>这是真事,我当时的直觉告诉我,怎么这么正道, unblievable看来今天买房能买成.</p>
</blockquote>
<p>到了爱达售楼处我父母早已在那等着我了,</p>
<p>我父母说要不要在周边看看,我说不用了砍瓜切菜挑户型,买吧!</p>
<p>于是就是干净利落的交完定金,回家办理结婚手续,张罗钱.</p>
<blockquote>
<p>看到这里提醒一下大家,事后我发现我选的户型没有阳台,是飘窗那种看样子.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/2017FinalSummary_house_type.jpg" alt=""></p>
<p>爱达88-1单元-12楼-三室两厅一卫-<code>124.7</code>平,当时的价格 10800/平 </p>
<p>来张封顶的照片 感谢<strong>红姐</strong>提供:<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/aida88.JPG" alt=""> </p>
<p>在过去的几年我回家的路线是这样的:<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/way_home_hailun.png" alt=""></p>
<p>从<code>北京坐地铁</code>到<code>北京站</code>–&gt;<code>哈尔滨站</code>–&gt;<code>海伦站</code>–&gt;<code>大客(大巴)</code>–&gt;<code>第二良种场</code><br>全程<code>1455</code>公里左右,说的凄惨一些坐大巴回农村地图都没有导航.压根都没有这个路线,到海伦<code>40公里左右</code></p>
<p>如果说交房以后我的路线应该是这样的:<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/way_home_haerbin.png" alt=""><br>从<code>北京坐地铁</code>到<code>北京站</code>–&gt;<code>哈尔滨西站</code> 完事 走5分钟我到家了.</p>
<blockquote>
<p>为了这<code>265</code>公里(哈尔滨减去到海伦农村的公里)我已为之奋斗了至少<code>4</code>年,未来还会继续奋斗到把房贷还完.</p>
</blockquote>
<h4 id="贷款"><a href="#贷款" class="headerlink" title="贷款"></a>贷款</h4><p>回家办理完最坑的事情发生了</p>
<p>我首付交了61w多 贷了60万,哈尔滨银行是我见过最SB的银行,我的银行流水已经高出两个月的还贷价格,但它还要我女朋友的流水也要达到和我同等标准.我当时真是膈应的哈尔滨银行咬牙切齿. 后来通过招商银行办理的商业贷款买的房.至此我想说如果你有能力达到这个银行的标准你应该离中产阶级不远了,已经是小康中的小康了.</p>
<p>在这里我说几个比较坑的地方</p>
<ol>
<li>银行的贷款银行流水需要现场打印,作假的流水就不要去贷款了否则会得不偿失.</li>
<li>还贷能力不够的需要找一个中间人.他的要求是和你一样准备相关材料.这种基本就需要靠各种亲戚了,可惜的是我家有这样的亲戚却有贷款.</li>
<li>贷款的时候 贷款业务员总推荐你买各种理财产品,不要买trust me.</li>
<li>贷款的银行里面必须保证有至少还贷能力三个月的存款.</li>
</ol>
<p>我被第<code>4</code>条坑了,我交完首付的时候要说身无分文那有点扯淡,但是也就最多<code>2000多元</code>,两个人回北京的路费去除掉 吃饭住宿都勉强不能维持了.还要我存进去<code>3万</code>这不扯淡嘛？后来又和比较好的同学,姐姐借点钱存进去了.唉 太TM扯淡了</p>
<p>我已经回到解放前了,还要我怎样.</p>
<p>至此我觉得一个国家连最基本的老百姓住房都成问题这已经不是一个好的国家了.</p>
<blockquote>
<p><strong>注意:银行贷款放款之后一定要去售楼处索要发票,只有首付款发票+尾款发票=房产证,两张发票有一张没有的话都容易拿不到房产证,这事比较坑的是售楼处的售楼员不告诉我们这些业主. (2018/02/28日更新)</strong></p>
</blockquote>
<h4 id="办理完所有买房手续"><a href="#办理完所有买房手续" class="headerlink" title="办理完所有买房手续"></a>办理完所有买房手续</h4><p>有一种感觉叫如释重负,就是形容买完房办理贷款.等待审批完成最后成为一个不折不扣的房奴,那这段话说的应该是我,心理的一块石头算是落了地.</p>
<p>4月份收到招商银行的审批合同,银行要求必须本人去取.也可以通过代理人拿着本人身份证 代理人身份证去取,于是我求助了我的一个 小学、初中、高中同学.帮我去爱建支行取出我的贷款合同帮我邮寄到了北京.</p>
<p>我买房父母没拿多少钱,全是这几年大学毕业辛苦北漂忍受雾霾拿生命积攒下来的.<br>所以我不羡慕那些拿钱给儿女买房的父母.</p>
<p>至此买房 算是告一段落.</p>
<blockquote>
<p>买房如果写两个人名的话,是签发的6份合同, 房地产,银行,本人各一份<br>产权所有是谁签 51% 和谁签 49%的比例</p>
</blockquote>
<h4 id="提取北京公积金"><a href="#提取北京公积金" class="headerlink" title="提取北京公积金"></a>提取北京公积金</h4><p>北京公积金提取需要提供如下材料:</p>
<ul>
<li>购房合同原件和购房合同复印件</li>
<li>贷款合同原件和贷款合同复印件</li>
<li>北京纳税连续一年以上打印</li>
<li>购房发票原件以及税务查询截图打印</li>
<li>购房的付款小票</li>
<li>公司的提取公积金章程表格</li>
<li>部门经理签字认可单</li>
<li>本人亲自签字认可对提供材料的真实性认可单</li>
</ul>
<p>这些东西办完之后 公积金可以约定支取.由于百度破公司的信誉不好,只能每个季度(3个月)提取一次.</p>
<p><strong>办理完之后北京住房公积金会返回给我们一张<code>公积金约定提取记录单</code>用于其它人提取的凭证,下次提取必须凭借这张提取记录单,比如我女朋友她想提取必须拿这个记录单,记住这很重要.</strong></p>
<p>第一笔钱入账的时候都已经是 6月末,第一件事就是把买房时候借点钱都还清.</p>
<blockquote>
<p>我就想不明白为啥公积金的钱是我的我还提取出来这么费劲,即便是十九大各种开会减少各种手续我发现外地人依然还是老样子,只有北京人提取各种方便.我满腔激愤的膈应起来那个出租车司机.</p>
</blockquote>
<p>经过了如此复杂的手续 我才得以买套房,想想真是心酸无助,确又黯然神伤, 在中国买房就是这么费事, 后来买房的看客们, 做好一个打持久战的准备,因为我们在和中国的体制斗智斗勇.</p>
<p>如果对本人买房经历有任何问题 请底部留言,我一一解答.</p>
<p>到此买房结束, 我相信跟我做邻居的人绝不是一般的普通人,他也必定经历我的这些至少一部分,收入、地位、等等等等,因为能在爱达这个地块买房的人,非富即贵,希望我的经历和买房经验能给你提供借鉴,少走弯路.</p>
<hr>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><h4 id="离开中国互联网之巅-百度"><a href="#离开中国互联网之巅-百度" class="headerlink" title="离开中国互联网之巅-百度"></a>离开中国互联网之巅-百度</h4><p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/2017FinalSummary_work1.jpg" alt=""></p>
<p>如果你是一个年轻需要锻炼的程序员我建议你去百度,那里有你成长所需要的土壤</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/2017FinalSummary_work2.png" alt=""></p>
<p>上边这张是办公环境,可以说确实很好.</p>
<p><strong>有一种离职叫真的干够了</strong></p>
<p>离开百度与其说是一种<strong>损失</strong>不如说是<strong>选择比努力更重要</strong>.</p>
<p>认识了很多精英小伙伴,他们不是<strong>干啥啥行</strong>的人就是在某个领域<strong>世界排行榜都有成就</strong>的人.</p>
<p>我一开始在百度云设备,后来产品不济转岗到<strong>百度网盘</strong>.是的你今天用的<code>iOS</code>百度网盘或者<strong>macOS百度网盘</strong>就有我开发的一段故事.</p>
<p>后来觉得团队气氛不是很好转战到百度hi做聊天,如果我说QQ微信你知道的话,那么百度有没有类似QQ、微信这样的聊天工具呢,有的,这玩意就叫百度Hi.</p>
<p>在Hi团队 接触到了一位来自<code>清华大学</code>毕业的老乡<strong>涛兄</strong>.</p>
<p>如果说这听起来感觉很有面子的话,那我来说一个2017年我听过最真实的笑话.</p>
<p>据涛兄说:</p>
<p><strong>他当年高考的时候,数学打了<code>149</code>分(150满分),让涛兄很不能释怀的是他有时候吃饭的时候都再思考为啥不是<code>150</code>分,他卷面也已经很干净了,没有错误的题目啊.终于有一天他找到了答案,他说:”有可能是卷面太干净了扣了一分”</strong>.</p>
<blockquote>
<p>这是一件2017年我听过最搞笑且真实的笑话,回想我的高考..还是算了,这就是差距.</p>
</blockquote>
<p>离开的百度Hi 来到的新的公司 金山云</p>
<p>进公司的时候唉 一眼望去 好多张熟悉的面孔,原来相当一部分同事都是百度的前同事.</p>
<p>工作就这样把,不多介绍了</p>
<hr>
<h3 id="书法"><a href="#书法" class="headerlink" title="书法"></a>书法</h3><p>这一年买了两只毛笔花了大概200多</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/maobi.png" alt=""></p>
<p>不过用起来确实很好,好马配好鞍,好笔配毛毡.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/IMG_2514.png" alt=""></p>
<p>有幸在百度碰到书法高手-老乡<code>潘旭</code>,这个绥棱人真是干啥啥行,写代码飞驰电掣.还有一手好书法.让我这个海伦人很佩服.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/linzexu.JPG" alt=""></p>
<p>这是林则徐当年写给皇帝的虎门销烟奏折.是我学习书法的最终目标.</p>
<hr>
<h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>在文学上 2017读过+听过的书我都一一记录 也推荐大家看看.</p>
<ul>
<li>《卑鄙的圣人曹操》1~10部全听完 </li>
</ul>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/beibideshengrencaocao.jpg" alt=""></p>
<ul>
<li>《知行合一 王阳明 》</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/zhuxingheyi_wangyangming.jpg" alt=""></p>
<ul>
<li><p>《大清相国》 陈廷敬<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/daqingxiangguo.jpeg" alt=""></p>
</li>
<li><p>《晚清的最后十八年》1~4部</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/wanqingzuihou18nian.jpeg" alt=""></p>
<ul>
<li>《Learn AV Foundation》</li>
</ul>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/learn_av_foundation.jpeg" alt=""></p>
<p>简单就这么多</p>
<p>这里比较推荐的是<strong>《大清相国》</strong>和<strong>《晚清最后的十八年》</strong></p>
<h4 id="读《晚清最后的十八年》中有一个故事值得学习"><a href="#读《晚清最后的十八年》中有一个故事值得学习" class="headerlink" title="读《晚清最后的十八年》中有一个故事值得学习"></a>读《晚清最后的十八年》中有一个故事值得学习</h4><p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/fudaoanzheng.jpg" alt=""></p>
<blockquote>
<p>福岛安正（1852一1919）日本信州人．日本殖民机构关东都督府都督。陆军大将。有“日本情报战之父”之称。他是一个具有超前眼光的阴谋家、战略家.  </p>
<p>1887年，福岛安正被任命为日本驻德国武官。在德国的五年中，他详细的考察了欧洲各国的情况，其中俄国的动向引起了他的极大关注。迫于英国的牵制，俄国传统的南进政策被迫放缓，福岛安正正确预测俄国必然会转向东进。果然，1891年1月，俄国公布了建造西伯利亚大铁路的计划，并立即动工。这条连接俄国首都圣彼得堡和符拉迪沃斯托克（海参崴），横穿欧亚大陆的铁路，可以说是俄国侵略亚洲的最大武器。西伯利亚铁路横穿中国东北部，从哈尔滨向南有一分支，直达旅顺、大连，可以使俄国轻而易举的进入亚洲。福岛预测这条铁路大约要耗时十年，他认为这十年是关系日本生死存亡的十年，日本对此绝不能袖手旁观。  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/Russia.png" alt=""></p>
<blockquote>
<p><strong>为了掌握俄国东进政策的实际情况，福岛决定亲自沿着西伯利亚铁路进行实地侦察。这个大胆的计划立即得到了参谋次长川上操六的大力支持。由于福岛的军人身份会暴露穿越计划的目的，于是福岛对外宣布要进行一次单骑穿越严寒时期西伯利亚的探险旅行。即使是土生土长的俄国人，也不敢轻言在严冬时期穿越西伯利亚，更何况是一个没有严寒地区生活经历的外国人。福岛此言一出，世界哗然，西方探险家对他的“穿越”计划嗤之以鼻，大家都等着看这个日本人的笑话。但福岛安正极为坚定，他深知这个计划对日本意味着什么</strong>。<br><strong>1892年2月11日，福岛和爱骑“凯旋”从德国踏上穿越之旅，在零下20摄氏度的严寒中北上。3月下旬，到达圣彼得堡后，福岛向日本参谋本部发去了第一份关于俄国陆军的调查报告。此时，俄方也隐约觉察到福岛的此次“旅行”是项庄舞剑，意在沛公。4月9日，福岛离开圣彼得堡，于当月下旬抵达莫斯科。在那里受到了沙皇和皇后的接见和赐宴。经过细致考察，福岛向日本参谋本部提交了关于西伯利亚铁路建设方面的报告。9月下旬，福岛到达中俄两国的界山―海拔3000多米的阿尔泰山。从阿尔泰山极目远望，满目皑皑白雪。至此，福岛已经走了7000公里，完成一半路程。<br>福岛安正在旅途中迎来了1893年。1月下旬到2月是西伯利亚最寒冷的时期，气温达到零下50度。俄国人几乎不在这样严寒的冬天外出，但是福岛却以惊人的意志在荒无人烟的冰天雪地里顽强前行。最终，凭借顽强的的毅力，福岛走出了西伯利亚。沿着逐渐转暖的黑龙江一路南下进入中国，福岛安正又用了两个多月的时间，在瑷珲、齐齐哈尔、吉林等地刺探军情。经过一年多的艰苦跋涉，福岛已经身心俱疲。他终于到了终点站–符拉迪沃斯托克。在这次的西伯利亚穿越中，福岛安正至少换了八匹马，历时488天，行程14000公里，创下了情报侦察史上的奇迹</strong>。<br>居住在符拉迪沃斯托克的日本人欣喜若狂地迎接福岛的到来。全世界都在大肆报到他单骑穿越西伯利亚的消息。福岛安正成了世界的名人。明治天皇特授予他三等旭日重光勋章并亲自设宴款待。福岛安正在穿越中获得的第一手资料，成为日俄战争中日本获胜的重要信息保障。<br>一个国家的情报工作，单靠几个人的力量是远远不够的，经过长期的经营才能形成一个庞大而有效的情报网络。在这方面，福岛也是一个行家里手</p>
</blockquote>
<p>这个人日本人横穿俄国欧亚远东大铁路,也就是今天的莫斯科-&gt;&gt;满洲里-&gt;&gt;齐齐哈尔-&gt;&gt;大庆-&gt;&gt;哈尔滨-&gt;&gt;牡丹江-&gt;&gt;海参崴 对俄贸易跨国专列铁路线.</p>
<p>就为了搜集战略情报,铁路途经山川地形地貌河流都绘制成地图(那时候还没有google卫星定位地图),为了战争做好充足的准备. </p>
<p>这个人的意志深深的鼓舞了我,如果一个国家想侵略另一个国家,出一两个这样的人才就差不多够了.</p>
<p>下图是晚清的东北军<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/manqing_dongbeijun.jpg" alt=""></p>
<p>这些书多数都是听的少数用kindle看的.2018年会再接再厉.</p>
<hr>
<h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><p>这一年一直坚持打羽毛球<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/badminton.JPG" alt=""></p>
<p>参加了金山的羽毛球比赛拿了一个季军 老实说纯打酱油哈见笑见笑<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/Runner-up2.JPG" alt=""><br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/Runner-up1.JPG" alt="">  </p>
<p>金山的小伙伴们还是不错的团队<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/badminton_team.gif" alt=""></p>
<hr>
<h3 id="驾照"><a href="#驾照" class="headerlink" title="驾照"></a>驾照</h3><p>这是2017年我觉得最值得去做的一件事,终于把驾驶证考了.上学的时候家里条件实在太差了,没钱考驾照,上班以后没有了时间.总之结果还是好的</p>
<p>来张海淀驾校的照片.<br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/drivinglicence1.png" alt=""></p>
<p>说一下考驾照的感触</p>
<p>科目一、二、三、四 一气呵成.2个月顺利拿本,总计跑了11趟驾校.</p>
<p>不过不得不说首都的教育还是很好的,教学设置一应俱全.果然还是得看首都的发展.</p>
<p>如果是自尊心强的人我建议可以报名.如果挨骂几句都接受不了的话还是别报了.</p>
<h2 id="2018目标"><a href="#2018目标" class="headerlink" title="2018目标"></a>2018目标</h2><p>说完了2017年的各种大事件</p>
<p>下面我列一下今年的目标</p>
<ul>
<li>swift4 进阶看完 </li>
<li>iOS Core Animation 看完</li>
<li>Learn AV Foundation 要写几篇博客从上次段的位置续上</li>
<li>学会Python和数据挖掘 为机器学习做铺垫</li>
<li>人工智能领域要有跨足</li>
<li>多媒体相关技术深耕</li>
<li>英语水平再提高一个level</li>
</ul>
<p>好了目标就这些吧</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一年过很多事件都没来得及想就发生了,有些想的基本很少完成,博客质量有量的积累却没有质的飞跃. 如果用几个字来结束2017的年终总结那我只能发出这句话吧！</p>
<p><strong>雄关漫道真如铁,而今迈步从头越.</strong></p>
<p>(估计大家刚刚进入我的博客,发现有一张劳斯莱斯的背景图,这张图是从劳斯莱斯汽车官方找到的,是<code>1903</code>年<a href="https://zh.wikipedia.org/wiki/%E6%9F%A5%E7%88%BE%E6%96%AF%C2%B7%E5%8B%9E%E6%96%AF" target="_blank" rel="external">查尔斯·史都华·劳斯</a>开车劳斯莱斯汽车打破陆地速度世界记录的画面,最后由于计算速度的设备没有经过组委会认定被判定无效.用这张图的寓意就是有时候做到了不必care认证不认证那不重要,事实已经证明了.)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171230Final-Summary/2017FinalSummart1.jpeg&quot;
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="生活" scheme="https://www.sunyazhou.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Markdown中插入音频文件</title>
    <link href="https://www.sunyazhou.com/2017/12/27/20171227markdown-audio/"/>
    <id>https://www.sunyazhou.com/2017/12/27/20171227markdown-audio/</id>
    <published>2017-12-27T04:04:07.000Z</published>
    <updated>2017-12-30T04:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>喜欢在博客文章打开的时候 播放一首背景音乐, 但Markdown本身是不支持插入音频视频,带着这个疑问开始这篇文章.</p>
<h2 id="markdown插入音乐"><a href="#markdown插入音乐" class="headerlink" title="markdown插入音乐"></a>markdown插入音乐</h2><p><code>markdown</code>其实就是 一种<code>html</code>的转换语法,其实内部也同时支持直接写<code>html</code>标签, 如果不了解各种标签请点击<a href="https://www.w3schools.com/tags/tag_iframe.asp" target="_blank" rel="external">w3cschool</a>查看各种 API 的用法,此时要用到的标签为<code>iframe</code>，代码如下所示，其中</p>
<ul>
<li><code>div</code>用于控制格式，若无则默认为居左</li>
<li><code>frameborder</code>用于规定是否显示框架周围的边框，1为是，0为否</li>
<li><code>marginwidth</code>及<code>marginheight</code>表示距离边缘的像素大小</li>
<li><code>width</code>及<code>height</code>表示播放条的长度和宽度</li>
<li><code>src</code>为播放链接，可以在如网易云音乐的<code>生成外链播放器</code>获取该链接，同时也获得以下代码，并可以自行更改；也可将音频链接改为视频链接，从而播放视频</li>
</ul>
<blockquote>
<p>值得注意的是，音频和视频在默认情况下是会自动循环播放的，可以修改链接的值进行修改<br>在<code>src</code>域中，<code>auto</code>值表示是否自动播放，当值为<code>1</code>时为自动播放，<code>0</code>则不是<br>在<code>src</code>域中，有些链接会附有<code>height</code>或<code>width</code>值，其表示表示播放框的基本宽高，可以更换其值以获得想要的播放框大小，此时可以不用填写外部的<code>width</code>及<code>height</code>.</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">life</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">400</span> <span class="attr">height</span>=<span class="string">140</span> <span class="attr">src</span>=<span class="string">"https://music.163.com/outchain/player?type=2&amp;id=34341360&amp;auto=0&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<div align="life"><br><iframe frameborder="no" marginwidth="0" marginheight="0" width="400" height="140" src="https://music.163.com/outchain/player?type=2&id=34341360&auto=0&height=66"></iframe><br></div>


<h2 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h2><p>这里面可以看到 用了 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">https://music.163.com/outchain/player?type=2&amp;id=34341360&amp;auto=0&amp;height=66</div></pre></td></tr></table></figure>
<p>这个接口的<code>id=34341360</code>是从这里获取的</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171227markdown-audio/markdown_audio1.png" alt=""></p>
<p>找到<code>复制链接</code>,然后用浏览器打开.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171227markdown-audio/markdown_audio2.png" alt=""></p>
<p>后边的 <code>id=34341360</code>就是我们要的 <code>id</code> 然后接口替换就可以了</p>
<p>更多技巧可参考以前写的一篇文章<br><a href="https://www.sunyazhou.com/2017/10/25/20171025markdown-skill/">markdown折叠</a><br><a href="https://www.sunyazhou.com/2017/09/29/20170929markdown-table/">markdown 表格</a></p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;喜欢在博客文章打开的时候 播放一首背景音乐, 但Markdown本身是不支持插入音频视频,带着这个疑问开始这篇文章.&lt;/p&gt;
&lt;h2 id=
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>音频声像Pan值电平左右声道平衡</title>
    <link href="https://www.sunyazhou.com/2017/12/19/20171219AudioPan/"/>
    <id>https://www.sunyazhou.com/2017/12/19/20171219AudioPan/</id>
    <published>2017-12-19T03:40:13.000Z</published>
    <updated>2017-12-24T07:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171219AudioPan/audio-pan.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在开发多媒体音视频相关业务,期间遇到的问题这里全做记录下来,下面是同事提供的一个例子我整理出来,以备后续开发遇到此类问题有个备案.</p>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>最近开发音频涉及到左右声道调节,基于左右声道的音量实现 声音环绕效果.<br>下面是 UI 演示.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171219AudioPan/audio_pan_demo.gif" alt=""></p>
<p>这里其实修改的类似 <code>AVAudioPlayer</code>里面的<code>pan</code>值修改</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171219AudioPan/pan_audio_api.png" alt=""></p>
<p>我在以前的文章也有一篇提到过这个<a href="https://www.sunyazhou.com/2017/03/17/Learning-AV-Foundation-AVAudioPlayer/">pan 值</a></p>
<p>可能大家不理解为啥 这个 API 起名叫<code>pan</code></p>
<p>在声学领域这个东西有专门的名字叫 <code>声像</code>.</p>
<p><a href="http://underwaysoft.com/writing/books/dsp-develop.html#%E7%BA%BF%E6%80%A7%E5%A3%B0%E5%83%8F%EF%BC%88&lt;span class=cnBracket&gt;Pan&lt;/span&gt;%EF%BC%89" target="_blank" rel="external">这篇文章</a>介绍了一些我们对声学知识的简单介绍,虽然不知道作者是谁,但是作者应该是非常专业的声学开发者.</p>
<p>其实按照我们平常的理解应该是这样去实现这个 pan 值的修改</p>
<p>左声道音量给右声道声音的补偿 或者右侧声道给左侧声道的补偿,通过滑块的 value 来决定两边谁加多少减多少,但是大家的思路是对的,但是做法是不正确的,因为 两边的音量放在中间必须是1.0,也就是说 range 在 <code>-1 ~ 1</code>之间. 如果按照这个滑动方式回导致滑动过大. </p>
<p>带着这个问题我的同事找到了一个公式 来计算 这个值</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171219AudioPan/pan-algorithm.png" alt=""></p>
<ul>
<li><code>pan</code>就是我们的滑块的<code>value</code></li>
<li><code>Vl</code> 代表左侧音量</li>
<li><code>Vr</code> 代表右侧音量</li>
</ul>
<p>根据这个公式我们有如下 代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, KSYMCChannelType) &#123;</div><div class="line">    KSYMCChannelTypeLeft = <span class="number">0</span>,</div><div class="line">    KSYMCChannelTypeRight = <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KSYMultiCanvasHelper</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">+ (<span class="built_in">CGFloat</span>)calculateVolume:(KSYMCChannelType)type</div><div class="line">                  panValue:(<span class="built_in">CGFloat</span>)pan</div><div class="line">                    volume:(<span class="built_in">CGFloat</span>)volume;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KSYMultiCanvasHelper</span></span></div><div class="line"></div><div class="line">+ (<span class="built_in">CGFloat</span>)calculateVolume:(KSYMCChannelType)type</div><div class="line">                  panValue:(<span class="built_in">CGFloat</span>)pan</div><div class="line">                    volume:(<span class="built_in">CGFloat</span>)volume&#123;</div><div class="line">    <span class="keyword">if</span> (type == KSYMCChannelTypeLeft) &#123;</div><div class="line">        <span class="built_in">CGFloat</span> leftVolumn = sqrt(<span class="number">2</span>) * cos((<span class="number">1</span> + pan)*M_PI_4) *volume;</div><div class="line">        <span class="keyword">return</span> leftVolumn;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == KSYMCChannelTypeRight) &#123;</div><div class="line">        <span class="built_in">CGFloat</span> rightVolumn = sqrt(<span class="number">2</span>) * sin((<span class="number">1</span> + pan)*M_PI_4) *volume;</div><div class="line">        <span class="keyword">return</span> rightVolumn;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这里的计算还是比较准确的.</p>
<p>经过测试 左侧 音量 为 0 时 右侧音量应该是 1.41左右</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上述测试音频的 pan 值修改 如果自行开发还是比较好搞得,只是鄙人对音频的知识积累的太少了.这篇文章看起来虽然没什么技术含量,全当知识的点滴积累吧. 至于为啥 是 <code>M_PI_4</code>还请专研一下文章的扩展链接,因为要把一个线性的操作转换成一个圆型方便数学的计算,以及 <strong>声像</strong>和<strong>声向</strong>的区别.</p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171219AudioPan/audio-pan.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UICollectionViewCell添加KVO</title>
    <link href="https://www.sunyazhou.com/2017/12/15/20171215cell-add-kvo/"/>
    <id>https://www.sunyazhou.com/2017/12/15/20171215cell-add-kvo/</id>
    <published>2017-12-15T09:05:10.000Z</published>
    <updated>2017-12-16T11:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171215cell-add-kvo/UICollectionViewCell.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都一个多月没更新博客了,这一段时间太忙了. 这篇带来的分享内容是<strong>如何正确的给一个<code>UICollectionViewCell</code>添加<code>KVO</code>监听</strong>.</p>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>由于目前在开发<a href="https://github.com/ksvc/KSYMediaEditorKit_iOS" target="_blank" rel="external">短视频</a>相关的SDK,面向的多数都是小白开发者,为了能让小白以最低的成本看懂 SDK 的代码以及用法,这就要求我们以小白最容易理解的方式开发代码,比如最低级的<code>MVC</code>模式,最直白的<code>Objective-C</code>(老实说我都烦透了 OC 这种超级长看着都难受的编程语言,早想用 swift 来玩一把了),所以在开发的技术选型和代码编写过程中都是达到小白最低的理解能力的开发模式,但有时候不得不面对在<em>小白能理解</em>和<em>功能的高级实现</em>之间做妥协.最近开发遇到个问题,如下:</p>
<blockquote>
<p>PM 有个需求 要实现在一个屏幕内多个 cell 上随意切换 录制视图并且能随意点击取消,再加上录制完成的视频如果不在选中状态就显示封面,如果在选中状态就继续预览,如果没有录制完的视频并且不在预览的 CELL要显示添加功能.</p>
</blockquote>
<p>听完这个需求是不是都晕了,我们来看张我实现完成的图.</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171215cell-add-kvo/record_demo.gif" alt=""></p>
<ol>
<li>录制完的视频取出封面</li>
<li>正在预览的随时准备录制</li>
<li>随意能切换 cell 不影响录制视图</li>
<li>未录制的并且没有已录制完视频文件的 cell 显示 添加按钮</li>
</ol>
<p>第一眼看着没啥技术含量都 UI 是吧</p>
<p>好我们来玩点有技术含量的</p>
<h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>如果使用传统MVC 模式的话<code>Cell</code>上边显示数据,那<code>model</code>里面是不是要放一个<code>record</code>的实例对象 告诉它 啥时候开始啥时候结束,当然你有更好的方式我就不说了我其实也知道.</p>
<h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>取出封面很简单让 cell里面存储一下录制完的 URL 就可以了,然后每次调用 UICollectonView 的 <code>reload:</code>方法</p>
<h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><p>我们实现录制视图的方式是放在 cell 的一个 subview 上, 正在录制的视图如果 reload 的话 应该会瞬间没了.就算吭哧吭哧实现完开始录制、暂停录制、恢复录制、结束录制… 这活我觉得问题和隐患应该非常多.别想了 不能这么玩</p>
<h4 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h4><p>cell的选中和非选中问题,你有没有发现 如果正在录制的 cell 上的 view 是选中的有个红色的框代表当前属于 焦点状态.<br>那录制完成呢.是不是需要重新 reload cell 告诉它当前谁 选中 谁取消,如果点击的是同一个 cell 还要取反操作.如果正在预览是不是再次选中说明要停止预览显示加号或者封面图,想着想着你发现这玩意是个状态机.必须要想好 model 构造,要让model 的参数足够多去控制当前 cell 的选中状态、非选中状态、预览状态、非预览状态、录制状态、非录制状态、录完状态、停止录制状态… 想着想着 太麻烦了 于是我整理出一个状态机的表格 如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Cell Status</th>
<th style="text-align:center">当前cell显示内容</th>
<th style="text-align:center">其它 cell 显示内容</th>
<th style="text-align:center">点击当前</th>
<th style="text-align:center">点击其它选中</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无预览状态</td>
<td style="text-align:center">显示加号/封面图</td>
<td style="text-align:center">显示加号/或者封面</td>
<td style="text-align:center">开始预览</td>
<td style="text-align:center">切换预览视图</td>
</tr>
<tr>
<td style="text-align:center">正在预览状态</td>
<td style="text-align:center">预览视频</td>
<td style="text-align:center">显示加号/或者封面</td>
<td style="text-align:center">显示加号/或者封面</td>
<td style="text-align:center">切换预览视图</td>
</tr>
<tr>
<td style="text-align:center">正在录制状态</td>
<td style="text-align:center">预览视频/播放视频</td>
<td style="text-align:center">(显示加号或播放视频)/(显示加号或预览视频)</td>
<td style="text-align:center">无操作(上锁)</td>
<td style="text-align:center">无操作(上锁)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><em>这些不重要,有这个印象就行了不用仔细看</em></p>
</blockquote>
<p>并不是我把问题复杂化,是 PM 的需求太复杂.不得不完整列出所有状态,精简,再精简,让小白开发者也能看懂的 SDK 才是好 SDK.</p>
<p>其实 其它的问题还有好多 我就不列出来了,好 现在我们来依次解决问题</p>
<p><strong>其实,综合上述信息来看,归根结底的原因是,实现这个录制随意切换功能等等的交互并不适用于<code>MVC</code>这种传统的玩法.<br>更像是一个<code>MVVM</code>的搞法</strong>,于是我想到了 MVVM 里面的精髓所在.要用<strong>数据驱动视图</strong>.</p>
<p>上面的4个主要问题不就是因为 model 的状态修改了要通知 cell 变化嘛.那我们使用 model 的状态来控制</p>
<blockquote>
<p>注意:<em>如果使用 MVVM 的玩法就不要再去调用 collectionview 的 reload:方法了</em></p>
</blockquote>
<p>目前开发实现<code>MVVM</code>的方式主流两种</p>
<ul>
<li>RAC</li>
<li>KVO</li>
</ul>
<p>显然<code>RAC</code>太大并不适用于我们 demo,用 KVO 搞一把.(代码有删减)</p>
<h4 id="第一步定义-model"><a href="#第一步定义-model" class="headerlink" title="第一步定义 model"></a>第一步定义 model</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^CompletionHandler)(<span class="built_in">UIImage</span> * image); <span class="comment">//取出 Image 给 Cell 显示的回调</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>,KSYMultiCanvasModelStatus)&#123;</div><div class="line">    KSYMultiCanvasModelStatusNOPreview = <span class="number">0</span>,<span class="comment">//无预览状态</span></div><div class="line">    KSYMultiCanvasModelStatusINPreview = <span class="number">1</span>,<span class="comment">//正在预览状态</span></div><div class="line">    KSYMultiCanvasModelStatusRecording = <span class="number">2</span> <span class="comment">//正在录制状态</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KSYCanvasModel</span> : <span class="title">NSObject</span> </span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span>  *videoURL; <span class="comment">//存放录制完视频 URL</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span>   isSelected;<span class="comment">//是否是选中</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) KSYMultiCanvasModelStatus modelStatus; <span class="comment">//重要!!!:模型状态用它控制 cell 显示</span></div><div class="line">- (<span class="keyword">void</span>)gengrateImageBySize:(<span class="built_in">CGSize</span>)size</div><div class="line">          completionHandler:(CompletionHandler)handler;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KSYCanvasModel</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="built_in">AVAssetImageGenerator</span> *imageGenerator;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KSYCanvasModel</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)gengrateImageBySize:(<span class="built_in">CGSize</span>)size</div><div class="line">          completionHandler:(CompletionHandler)handler&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.videoURL == <span class="literal">nil</span>) &#123; handler(<span class="literal">nil</span>); &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">AVURLAsset</span> *asset = [<span class="built_in">AVURLAsset</span> assetWithURL:<span class="keyword">self</span>.videoURL];</div><div class="line">    <span class="keyword">self</span>.imageGenerator = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.imageGenerator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:asset];</div><div class="line">    <span class="keyword">self</span>.imageGenerator.maximumSize = size;</div><div class="line">    </div><div class="line">    <span class="built_in">NSError</span> *error=<span class="literal">nil</span>;</div><div class="line">    <span class="built_in">CMTime</span> time= kCMTimeZero;<span class="comment">//CMTime是表示电影时间信息的结构体，第一个参数表示是视频第几秒，第二个参数表示每秒帧数.(如果要活的某一秒的第几帧可以使用CMTimeMake方法)</span></div><div class="line">    <span class="built_in">CMTime</span> actualTime;</div><div class="line">    <span class="built_in">CGImageRef</span> cgImage= [<span class="keyword">self</span>.imageGenerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];</div><div class="line">    <span class="keyword">if</span>(error)&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"截取视频缩略图时发生错误，错误信息：%@"</span>,error.localizedDescription);</div><div class="line">        handler(<span class="literal">nil</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CMTimeShow</span>(actualTime);</div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:cgImage];<span class="comment">//转化为UIImage</span></div><div class="line">    <span class="built_in">CGImageRelease</span>(cgImage);</div><div class="line">    handler(image);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>ok model 大概是这样 .m 文件主要是从视频中取封面图</p>
<h4 id="第二步定义-cell"><a href="#第二步定义-cell" class="headerlink" title="第二步定义 cell"></a>第二步定义 cell</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"KSYCanvasModel.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *KSYModelKVOStatusContext;</div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *KSYKeyPathForModelStatus = <span class="string">@"modelStatus"</span>;</div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *KSYKeyPathForIsSelected = <span class="string">@"isSelected"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KSYCanvasCell</span> : <span class="title">UICollectionViewCell</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *canvasImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *addImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *boundsView;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) KSYCanvasModel *model;</div><div class="line"></div><div class="line"><span class="comment">//注册和移除观察接口</span></div><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context;</div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath </div><div class="line">               context:(<span class="keyword">void</span> *)context;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KSYCanvasCell</span>()</span></div><div class="line"><span class="comment">// 使用 ObservableKeys 保存 keyPath 观察状态，避免重复注册和重复移除（重复移除会导致 crash）</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *observableKeySets;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KSYCanvasCell</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</div><div class="line">    [<span class="keyword">super</span> awakeFromNib];</div><div class="line">    </div><div class="line">    <span class="comment">//千万别把 KOV 监听写在这里</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//.,,此处省略了不太相关的代码</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context&#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.observableKeySets containsObject:keyPath]) &#123; <span class="keyword">return</span>; &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.observableKeySets == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.observableKeySets = [<span class="built_in">NSMutableSet</span> set];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.observableKeySets addObject:keyPath];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model addObserver:observer</div><div class="line">                 forKeyPath:keyPath</div><div class="line">                    options:options</div><div class="line">                    context:context];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">               context:(<span class="keyword">void</span> *)context&#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.observableKeySets containsObject:keyPath]) &#123; <span class="keyword">return</span>; &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model removeObserver:observer</div><div class="line">                    forKeyPath:keyPath</div><div class="line">                       context:context];</div><div class="line">    [<span class="keyword">self</span>.observableKeySets removeObject:keyPath];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context&#123;</div><div class="line">    <span class="keyword">if</span> ([KSYKeyPathForModelStatus isEqualToString:keyPath]) &#123;</div><div class="line">        KSYMultiCanvasModelStatus modelStatus = [[change objectForKey:<span class="built_in">NSKeyValueChangeNewKey</span>] integerValue];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"当前状态:%zd"</span>,modelStatus);</div><div class="line">		 <span class="comment">//拿到模型状态然后做适当的处理</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([KSYKeyPathForIsSelected isEqualToString:keyPath])&#123;</div><div class="line">        <span class="comment">//处理是否显示边框</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这里要在.h 里面复写 下面这俩个方法 因为要再 ViewController 里面拿到 cell 调用这个方法</p>
</blockquote>
<ul>
<li><code>addObserver:forKeyPath:options:context:</code> 这个方法是系统方法需要复写并对外暴露接口</li>
<li><code>removeObserver:forKeyPath:context:</code> 这个方法是系统方法需要复写并对外暴露接口</li>
</ul>
<p>这里定义了一个上下文对象用于找到识别这个在 cell的监听还有两个要监听的属性(KSYCanvasCell.h 顶部)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *KSYModelKVOStatusContext;</div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *KSYKeyPathForModelStatus = <span class="string">@"modelStatus"</span>;</div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *KSYKeyPathForIsSelected = <span class="string">@"isSelected"</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意:<strong>为了防止 cell 重复注册导致复用的时候崩溃,这里用<code>NSMutableSet</code>让 model 的观察者只注册一次</strong></p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KSYCanvasCell</span>()</span></div><div class="line"><span class="comment">// 使用 ObservableKeys 保存 keyPath 观察状态，避免重复注册和重复移除（重复移除会导致 crash）</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *observableKeySets;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>添加的时候做一次check</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</div><div class="line">            context:(<span class="keyword">void</span> *)context&#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.observableKeySets containsObject:keyPath]) &#123; <span class="keyword">return</span>; &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.observableKeySets == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.observableKeySets = [<span class="built_in">NSMutableSet</span> set];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.observableKeySets addObject:keyPath];</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>移除的时候要做一次 check</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">               context:(<span class="keyword">void</span> *)context&#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.observableKeySets containsObject:keyPath]) &#123; <span class="keyword">return</span>; &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model removeObserver:observer</div><div class="line">                    forKeyPath:keyPath</div><div class="line">                       context:context];</div><div class="line">    [<span class="keyword">self</span>.observableKeySets removeObject:keyPath];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ok cell 大概是这个意思</p>
<h4 id="第三步在-ViewController里面-适当的位置-注册-移除监听-并在ViewController控制器的生命周期内也做好相关监听的移除和添加"><a href="#第三步在-ViewController里面-适当的位置-注册-移除监听-并在ViewController控制器的生命周期内也做好相关监听的移除和添加" class="headerlink" title="第三步在 ViewController里面 适当的位置 注册/移除监听 并在ViewController控制器的生命周期内也做好相关监听的移除和添加"></a>第三步在 ViewController里面 适当的位置 注册/移除监听 并在ViewController控制器的生命周期内也做好相关监听的移除和添加</h4><p>这里我们需要实现<code>UICollectionViewDelegate</code>的代理协议来调用 cell 的添加 cell 和移除 cell</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView willDisplayCell:(<span class="built_in">UICollectionViewCell</span> *)cell forItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    KSYCanvasCell *canvasCell = (KSYCanvasCell *)cell;</div><div class="line">    [canvasCell addObserver:canvasCell</div><div class="line">                 forKeyPath:KSYKeyPathForModelStatus</div><div class="line">                    options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">                    context:&amp;KSYModelKVOStatusContext];</div><div class="line">    [canvasCell addObserver:canvasCell</div><div class="line">                 forKeyPath:KSYKeyPathForIsSelected</div><div class="line">                    options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">                    context:&amp;KSYModelKVOStatusContext];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didEndDisplayingCell:(<span class="built_in">UICollectionViewCell</span> *)cell forItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    KSYCanvasCell *canvasCell = (KSYCanvasCell *)cell;</div><div class="line">    <span class="comment">//状态变化</span></div><div class="line">    [canvasCell removeObserver:canvasCell</div><div class="line">                    forKeyPath:KSYKeyPathForModelStatus</div><div class="line">                       context:&amp;KSYModelKVOStatusContext];</div><div class="line">    <span class="comment">//选中变化</span></div><div class="line">    [canvasCell removeObserver:canvasCell</div><div class="line">                    forKeyPath:KSYKeyPathForIsSelected</div><div class="line">                       context:&amp;KSYModelKVOStatusContext];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你是不是会问为啥写这 </p>
<p>我来告诉我我遇到的一个坑</p>
<p>如果你在 下面的方法里写注册 后果不堪设想,因为 cell 是复用的,每次复写 KVO 都是在创建新的对象</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (__kindof <span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    KSYCanvasCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:[KSYCanvasCell className] forIndexPath:indexPath];</div><div class="line">    cell.model = [<span class="keyword">self</span>.models objectAtIndex:indexPath.row];</div><div class="line">    <span class="comment">//如果写在这里</span></div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>KVO的实现原理很简单,就是把这个对象的监听属性在底层复写一下,监听两个值之间的变化.KVO 原理相关的就不多废话了,这都是家常便饭了</p>
<p>我一开始写在了 cell 的 awakeFromNib: 因为都是 cell 拖拽的控件,但是麻烦真是接踵而至,各种崩溃</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</div><div class="line">    [<span class="keyword">super</span> awakeFromNib];</div><div class="line">	 <span class="comment">//别写在这里    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你不信邪可以试试.</p>
<p>最后我们在控制器的适当位置修改 model 的状态这样就做到了实时更新 cell</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didSelectItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="comment">//------------处理点击-----------</span></div><div class="line">    KSYCanvasModel *lastModel = [<span class="keyword">self</span>.models objectAtIndex:<span class="keyword">self</span>.lastSelectedIndexPath.row];</div><div class="line">    KSYCanvasModel *selectedModel = [<span class="keyword">self</span>.models objectAtIndex:indexPath.row];</div><div class="line">    <span class="built_in">BOOL</span> clickSameCell = (<span class="keyword">self</span>.lastSelectedIndexPath == indexPath);</div><div class="line">    <span class="keyword">if</span> (clickSameCell) &#123;</div><div class="line">        <span class="comment">//选择同一个cell</span></div><div class="line">        selectedModel.isSelected = !selectedModel.isSelected;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        lastModel.isSelected = <span class="literal">NO</span>;</div><div class="line">        selectedModel.isSelected = <span class="literal">YES</span>;   </div><div class="line">    &#125;</div><div class="line">    selectedModel.modelStatus = KSYMultiCanvasModelStatusRecording; <span class="comment">//这就会出发 cell的 KVO 了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后别忘了在ViewController的生命周期添加和移出观察者</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</div><div class="line">    [<span class="keyword">self</span>.canvasCollectionView.visibleCells enumerateObjectsUsingBlock:^(KSYCanvasCell *cell, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">        [cell removeObserver:cell</div><div class="line">                  forKeyPath:KSYKeyPathForModelStatus</div><div class="line">                     context:&amp;KSYModelKVOStatusContext];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的实现过程就 解决了 上边提到的 问题 1、2、3、4</p>
<p>这也是最精简的实现方式,以小白的开发视角 来看也需要熟悉一点 MVVM 了.这都是成了 iOS 最标配了.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种偏向MVVM模式开发的方式 我个人觉得还是不错的,虽然现在各种MVVM格式早已经烂大街了,但只要想起来,用起来,能用简单直白的方式解决问题,它就是好的开发设计模式.当然本章也主要讲了一些技巧而已,不足之处还请各位指正.</p>
<p>demo我就不写了 可以参考<a href="https://github.com/ksvc/KSYMediaEditorKit_iOS" target="_blank" rel="external">我们的短视频 demo</a> multicanvas target</p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171215cell-add-kvo/UICollectionViewCell.png
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>适配iPhone X</title>
    <link href="https://www.sunyazhou.com/2017/11/03/20171103iPhone-X-Adaptor/"/>
    <id>https://www.sunyazhou.com/2017/11/03/20171103iPhone-X-Adaptor/</id>
    <published>2017-11-03T03:44:44.000Z</published>
    <updated>2017-11-25T08:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171103iPhone-X-Adaptor/say_hello_to_furture.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近苹果发布iPhone X,随后小伙伴的 X 都到货了,适配问题也接踵而至,<br>相信拿到 iPhone X的感觉是下面这样的:</p>
<p><img src="https://ws1.sinaimg.cn/large/89e3e57fly1fll1y5jyygj22io1w0hdt.jpg" alt=""></p>
<p>本篇主要内容分为:</p>
<ul>
<li>iPhone X尺寸参数</li>
<li>UI适配</li>
<li>极端情况处理</li>
<li>实践案例</li>
<li>总结</li>
</ul>
<h3 id="1-iPhone-X尺寸参数"><a href="#1-iPhone-X尺寸参数" class="headerlink" title="1.iPhone X尺寸参数"></a>1.iPhone X尺寸参数</h3><h4 id="1-1-首先-来围观一下模拟器的-iPhone-X的外观"><a href="#1-1-首先-来围观一下模拟器的-iPhone-X的外观" class="headerlink" title="1.1 首先 来围观一下模拟器的 iPhone X的外观"></a>1.1 首先 来围观一下模拟器的 iPhone X的外观</h4><p><img src="https://ws1.sinaimg.cn/large/89e3e57fly1fll6d0zx4sj20m80c1t9p.jpg" alt="safeArea"></p>
<p>下面这点先记住这很重要:格式UIEdgeInsetsMake(上, 左,下,右);  </p>
<blockquote>
<p>iPhone X竖屏时:占满整个屏幕的控制器的view的safeAreaInsets是（44，0，34，0）<br>iPhone X横屏时:是（0，44，21，44），inset后的区域正好是safeAreaLayoutGuide区域</p>
</blockquote>
<p>safeAreaInsets是相对于屏幕的物理边界计算的偏移量,通俗一点就是</p>
<blockquote>
<p>横屏: 距离顶部(物理屏幕顶边)偏移44，距离左侧偏移0，距离底部偏移34,距离右边偏移0(从右向左偏移别搞错了).<br>竖屏: 距离顶部(物理屏幕顶边)偏移0，距离左侧偏移44，<strong>距离底部偏移21</strong>(注意横屏底部有home 虚拟键),<strong>距离右边偏移44</strong>(同样注意不是竖屏的30了). </p>
</blockquote>
<p>进过测试发现,Margins 区域 有10个像素点就是上边 的 40 - 30 = 10的作用区间(我的理解应该是为了压力触摸屏的事件响应范围)，还有特别留意一下横屏的时候 顶部和底部的区别,顶部为0, 底部要保留21的 pts(points)来显示 home 虚拟键,<strong>记得获取屏幕宽度或者高度的时候要做好减去 21 的准备.</strong></p>
<p><img src="https://ws1.sinaimg.cn/mw690/89e3e57fly1fll3kxabqkj20c10nojru.jpg" alt="穿黑色外套略显优雅"><br><img src="https://ws1.sinaimg.cn/mw690/89e3e57fly1fll3pg1izmj20af0n6mxf.jpg" alt="不穿外套略显尴尬"></p>
<h4 id="1-2-实际场景"><a href="#1-2-实际场景" class="headerlink" title="1.2 实际场景"></a>1.2 实际场景</h4><p><img src="https://ws1.sinaimg.cn/mw690/89e3e57fly1fll3xqtuydj21w02iokjl.jpg" alt="实际测试中的刘海样式"></p>
<blockquote>
<p>看到苹果[射击湿]的扁平化凹陷齐刘海设计的我现在就像在乔布斯坟头上坟烧纸一样,眼神里带有少许悲伤.</p>
</blockquote>
<h4 id="1-3-工业化图纸尺寸"><a href="#1-3-工业化图纸尺寸" class="headerlink" title="1.3 工业化图纸尺寸"></a>1.3 工业化图纸尺寸</h4><p>说重点不废话</p>
<p><img src="https://ws1.sinaimg.cn/large/89e3e57fly1fll4dy8bmrj20yg0icq5y.jpg" alt="iPhone X顶部尺寸图纸"></p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">size 尺寸</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">屏幕宽高</td>
<td style="text-align:center">375 x 812</td>
<td style="text-align:center">pt(point)</td>
</tr>
<tr>
<td style="text-align:center">屏幕宽高比</td>
<td style="text-align:center">9:19.5</td>
<td style="text-align:center">而不是普通的 9:16 了</td>
</tr>
<tr>
<td style="text-align:center">整体屏幕高度</td>
<td style="text-align:center">比<code>iPhone 6/7/8&#39;s</code>高了<code>145</code>pt</td>
<td style="text-align:center">pt(point)</td>
</tr>
<tr>
<td style="text-align:center">状态栏高度(status bar)</td>
<td style="text-align:center">44</td>
<td style="text-align:center">比原来高出了<code>24</code>pt(并且空余的<code>24</code>(44-20)pts 不能被 app 使用,因为他是给<code>Face ID</code>相关传感器留出区域)</td>
</tr>
<tr>
<td style="text-align:center">传感器区域(sensor housing)</td>
<td style="text-align:center">30</td>
<td style="text-align:center">单位 pt,就是被挡住的那个 Face ID传感器区域</td>
</tr>
<tr>
<td style="text-align:center">状态栏+导航栏高度(Navigation Bar)</td>
<td style="text-align:center">88 或 (带 title 样式的 140)</td>
<td style="text-align:center">pt(point)</td>
</tr>
<tr>
<td style="text-align:center">底部 Toolbar</td>
<td style="text-align:center">83</td>
<td style="text-align:center">不在是原来的 44 pt(point),如果横屏 Toolbar 高度 53</td>
</tr>
<tr>
<td style="text-align:center">retina像素倍数</td>
<td style="text-align:center">3x</td>
<td style="text-align:center">3倍屏</td>
</tr>
<tr>
<td style="text-align:center">pixels像素</td>
<td style="text-align:center">1125 x 2436</td>
<td style="text-align:center">和 iPhone各种Plus版本一直</td>
</tr>
<tr>
<td style="text-align:center">iPhone X 安全区</td>
<td style="text-align:center">frame 为(0, 44, 375, 734)</td>
<td style="text-align:center">对比iPhone6/6s安全区frame 为(0, 0, 375, 667)</td>
</tr>
<tr>
<td style="text-align:center">layout margins</td>
<td style="text-align:center">纵向 20,横向64 )</td>
<td style="text-align:center">横向 margins 底部有那个 home 键范围</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意: <em>别搞错了status bar和FaceID传感器区域范围,因为状态栏(status bar)和传感器区域(sensor housing)之间还是有点间隙的 间隙是 6 pt</em><br><em>status bar空余的<code>24</code>(44-20)pts 不能被 app 使用,因为他是给<code>Face ID</code>相关传感器留出区域.而且我们不能改变 出现比如定位的图标、通话、和其他后台任务的图标的小大</em><br><em>这里说的pt(point)是开发人员的计算屏幕一倍的像素单位,不是视觉提供素材的pixel像素</em></p>
</blockquote>
<h3 id="2-UI适配"><a href="#2-UI适配" class="headerlink" title="2. UI适配"></a>2. UI适配</h3><p>ok 看完各种尺寸 我们来说一下 UI 适配工作</p>
<h4 id="2-1-工作分工"><a href="#2-1-工作分工" class="headerlink" title="2.1 工作分工:"></a>2.1 工作分工:</h4><ul>
<li>UI(视觉设计师)的素材提供 </li>
<li>RD(研发工程师)的UI相关适配</li>
</ul>
<h5 id="2-1-1-设计和开发同学需要考虑适配的范围有"><a href="#2-1-1-设计和开发同学需要考虑适配的范围有" class="headerlink" title="2.1.1 设计和开发同学需要考虑适配的范围有"></a>2.1.1 设计和开发同学需要考虑适配的范围有</h5><p><img src="https://ws1.sinaimg.cn/large/89e3e57fly1fll4xm1k21j206f0dwdgm.jpg" alt=""></p>
<ol>
<li>传感器区域(sensor housing), 就是那个顶部<code>Face ID</code>的遮盖区域(大家常说的刘海儿).  </li>
<li>底部<code>Home键</code> 标识的触发区域,就是那个底部的横条(home indicator).  </li>
<li>圆角 四个定点的圆角问题.  </li>
</ol>
<p>三倍(3x)屏的图标素材问题</p>
<ul>
<li>建议使用<code>PDF</code>格式或者矢量图;</li>
<li>使用<code>@2x</code>或者<code>@3x</code>图</li>
<li>如果没有使用<code>LaunchScreen.storyboard</code>作为应用启动的话 <code>3x</code>图用不了.</li>
</ul>
<h5 id="2-1-2-研发的工作范围"><a href="#2-1-2-研发的工作范围" class="headerlink" title="2.1.2 研发的工作范围"></a>2.1.2 研发的工作范围</h5><ol>
<li>适配 UI 的导航栏和状态栏</li>
<li>适配safeArea范围</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/89e3e57fly1fll5z16qs5j20ep056434.jpg" alt="短视频录制顶部按钮适配前"></p>
<p>我们的搞法是把导航栏隐藏掉然后填写上按钮,但是当 iPhone X出来的时候就不行了因为会出现被刘海盖住,其实主要的原因是我们用的 Masonry 自动布局的 edge 超过了安全区范围</p>
<p><img src="https://ws1.sinaimg.cn/large/89e3e57fly1fll689p471g206h07aju1.gif" alt=""></p>
<p>我们的搞法是放置一个 View,并且让他的 edge 在 iOS11上 等于安全区范围.</p>
<p>那么我们为啥要这么搞呢?</p>
<ol>
<li>我们需要适配 iPhone X 的 safeArea 并且兼容 iOS8</li>
<li>后续处理事件 按钮、手势 都用这个 view 搞.</li>
</ol>
<p>对基于这两点我们选择这种搞法.</p>
<p>代码实现如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</div><div class="line">       [<span class="keyword">self</span>.canRotateView mas_remakeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">           make.top.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideTop);</div><div class="line">           make.bottom.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideBottom);</div><div class="line">           make.left.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideLeft);</div><div class="line">           make.right.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideRight);</div><div class="line">       &#125;];</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">   	[<span class="keyword">self</span>.safeAreaView mas_remakeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">           make.edges.equalTo(<span class="keyword">self</span>.view);</div><div class="line">       &#125;];	</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>下面是完成之后的效果图</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171103iPhone-X-Adaptor/KSYMediaEditorKit_launch.PNG" alt="Launch"><br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171103iPhone-X-Adaptor/KSYMediaEditorKit_config.PNG" alt="config"><br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171103iPhone-X-Adaptor/KSYMediaEditorKit_record.PNG" alt="record"><br><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171103iPhone-X-Adaptor/KSYMediaEditorKit_edit.PNG" alt="edit"></p>
<h3 id="3-极端情况处理"><a href="#3-极端情况处理" class="headerlink" title="3. 极端情况处理"></a>3. 极端情况处理</h3><h4 id="极端情况1-如果有些-app-使用的手势-是从下往上滑动的话"><a href="#极端情况1-如果有些-app-使用的手势-是从下往上滑动的话" class="headerlink" title="极端情况1:如果有些 app 使用的手势 是从下往上滑动的话"></a>极端情况1:如果有些 app 使用的手势 是从下往上滑动的话</h4><p><img src="https://ws1.sinaimg.cn/large/89e3e57fly1fll6sir2s3j206n0dxjsi.jpg" alt="手势从下往上滑动"></p>
<p>这样就会造成在 iPhone X上 滑动和 home 虚拟按键冲突的问题,那如果出现这种问题如何解决呢？</p>
<p>我们需要 需要开启 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/2887512-preferredscreenedgesdeferringsys" target="_blank" rel="external"><code>edge protect</code></a>, 这是控制器的方法.</p>
<p>在 UIViewController 里面返回 要触摸返回键的范围</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">preferredScreenEdgesDeferringSystemGestures</span><span class="params">()</span></span> -&gt; <span class="type">UIRectEdge</span></div></pre></td></tr></table></figure>
<p>objc 版本</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">UIRectEdge</span>)preferredScreenEdgesDeferringSystemGestures&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">UIRectEdgeAll</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话 用户 滑动一次 手势响应, 如果 滑动两次 才会触发<code>home indicator</code>.</p>
<h4 id="极端情况2-如何隐藏底部-home-条"><a href="#极端情况2-如何隐藏底部-home-条" class="headerlink" title="极端情况2:如何隐藏底部 home 条?"></a>极端情况2:如何隐藏底部 home 条?</h4><p>那个底部的横条如何 隐藏掉呢?</p>
<p>其实这是一种被动的视图响应体验,<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/2887510-prefershomeindicatorautohidden" target="_blank" rel="external"> auto-hiding</a>, 返回这个<code>UIViewController</code>的 <code>bool</code>的值,这样的话 如果用户没有触发底部的<code>home 条</code>(home indicator)几秒,<code>home 条</code>(home indicator)会淡出不做响应.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">prefersHomeIndicatorAutoHidden</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></div></pre></td></tr></table></figure>
<p>Objective-C 版本</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)prefersHomeIndicatorAutoHidden&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h3><h4 id="实践案例1-safeArea-在-iOS11上开启之后-在低版本-怎么处理"><a href="#实践案例1-safeArea-在-iOS11上开启之后-在低版本-怎么处理" class="headerlink" title="实践案例1:safeArea 在 iOS11上开启之后 在低版本 怎么处理?"></a>实践案例1:safeArea 在 iOS11上开启之后 在低版本 怎么处理?</h4><blockquote>
<p>经过测试 在<code>iOS9</code>之前就是用不了<code>safeArea</code>必须<code>iOS9 or later</code><br>如果兼容 iOS 8.0的建议去掉<code>safeArea</code>否则报错</p>
</blockquote>
<p>解决的方式:参考我们的短视频适配 使用一个背景 View 来做支撑并且使它的 edge 边缘处于<code>safeArea</code>范围内并使用如下代码做 iOS11前的安全区</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> ( <span class="built_in">NS_AVAILABEL</span>(iOS <span class="number">11.0</span>)) &#123;</div><div class="line">	<span class="comment">//iOS11 支持安全区域范围</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">//iOS11之前不支持安全区范围</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实践案例1-Masonryedge-不能等于-safeAreaGuide"><a href="#实践案例1-Masonryedge-不能等于-safeAreaGuide" class="headerlink" title="实践案例1:Masonryedge 不能等于 safeAreaGuide?"></a>实践案例1:<code>Masonry</code>edge 不能等于 safeAreaGuide?</h4><p>因为我们的代码基本都是 xib 拖拽控件，使用 masonry 自动布局</p>
<p>如果对一个 view 让它的上、左、下、右 4个边缘等于父视图的话我们经常写下面 代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[<span class="keyword">self</span>.xxxView mas_remakeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">           make.edges.equalTo(<span class="keyword">self</span>.view);</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>但是为支持 safeArea,<code>Masonry</code>库提供了<code>safeAreaGuide</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line">[<span class="keyword">self</span>.safeAreaView mas_remakeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">       make.edges.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuide);</div><div class="line">  	 &#125;];</div></pre></td></tr></table></figure>
<p>但是经过我验证 这样写会触发<code>Masonry</code>库 bug 导致 crash</p>
<p>看下边的例子:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 底部segement</span></div><div class="line">[<span class="keyword">self</span>.panelTabbar mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.left.right.bottom.equalTo(<span class="keyword">self</span>.view);</div><div class="line">    make.height.equalTo(@<span class="number">44</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>但我要是改成 iOS11</p>
<p>这个写法就会不支持  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 底部segement  </span></div><div class="line">[<span class="keyword">self</span>.panelTabbar mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.left.right.bottom.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuide);</div><div class="line">    make.height.equalTo(@<span class="number">44</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>必须改成 </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 底部segement</span></div><div class="line">[<span class="keyword">self</span>.panelTabbar mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.left.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideLeft);</div><div class="line">    make.right.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideRight);</div><div class="line">    make.bottom.equalTo(<span class="keyword">self</span>.view.mas_safeAreaLayoutGuideBottom);</div><div class="line">    make.height.equalTo(@<span class="number">44</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>正确写法</p>
</blockquote>
<p>我也不知道到底是这个库的作者没搞明白为啥费劲挨个上下左右都这么搞，还是他喜欢这样写冗余代码,总之现在这种搞法是最正确的.</p>
<blockquote>
<p>这个已经给 Masonry 库提了 issue 近期应该会修复</p>
</blockquote>
<h4 id="实践案例3-安全区域-safeArea-的坐标-frame"><a href="#实践案例3-安全区域-safeArea-的坐标-frame" class="headerlink" title="实践案例3: 安全区域 safeArea 的坐标(frame)"></a>实践案例3: 安全区域 safeArea 的坐标(frame)</h4><p>如果有一种需求需要计算 iPhone 的 安全区域 范围 宽高等于多少？如下代码可以得到正确的 范围</p>
<p><code>@available(iOS 11.0, *)</code></p>
<p><code>NSString * safeAreaRect = NSStringFromCGRect(self.view.safeAreaLayoutGuide.layoutFrame);</code></p>
<blockquote>
<p>下面代码请在 ViewController 里面测试</p>
</blockquote>
<p>我测试了 安全局frame 区别</p>
<ul>
<li>iPhone X 安全区 (0, 44, 375, 734).</li>
<li>iPhone 6s 安全区 (0, 0, 375, 667).</li>
</ul>
<blockquote>
<p>高了 734 - 667 = 67 </p>
</blockquote>
<p>如果是视频录制 会导致视频比例不对</p>
<p>解决办法: 推荐 安全区顶部到底部 高度的宽度比值 等于标准的 3:4 或者 9:16</p>
<h4 id="实践案例4-适配-iPhone-X常用的宏"><a href="#实践案例4-适配-iPhone-X常用的宏" class="headerlink" title="实践案例4: 适配 iPhone X常用的宏"></a>实践案例4: 适配 iPhone X常用的宏</h4><p>其实我个人不推荐用宏 鉴于它短时间内 能解决问题 我不得不列举一些</p>
<p>先看问题</p>
<p><img src="https://ws1.sinaimg.cn/mw690/89e3e57fly1fll7kd1a49j20yg05u0tp.jpg" alt="状态栏白色"><br><img src="https://ws1.sinaimg.cn/mw690/89e3e57fly1fll7kd18zlj20np06sq3w.jpg" alt="导航栏太紧"></p>
<p><img src="https://ws1.sinaimg.cn/mw690/89e3e57fly1fll7kd1ipxj20od0ae40k.jpg" alt="适配完"></p>
<p>出现这种问题是由于</p>
<blockquote>
<p>iOS 11上面废除了scrollView的<code>automaticallyAdjustsScrollViewInsets</code>这个属性的使用.使用UIScrollView’s <code>contentInsetAdjustmentBehavior</code>来替代，<a href="https://www.lee1994.com/guan-yu-iphone/" target="_blank" rel="external">详细介绍</a></p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</div><div class="line">    <span class="keyword">self</span>.collectionView.contentInsetAdjustmentBehavior = <span class="built_in">UIApplicationBackgroundFetchIntervalNever</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="literal">false</span>;</div><div class="line">    <span class="comment">// Fallback on earlier versions</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了省事 可以使用这个宏</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#define AdjustsScrollViewInsetNever(controller,view) if(@available(iOS 11.0, *)) &#123;view.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;&#125; else if([controller isKindOfClass:[UIViewController class]]) &#123;controller.automaticallyAdjustsScrollViewInsets = false;&#125;</span></div></pre></td></tr></table></figure>
<p>高度系数宏 812.0 是iPhoneX的高度尺寸</p>
<pre><code class="objc"><span class="meta">#define kHeightCoefficient (kScreenHeight == 812.0 ? 667.0/667.0 : kScreenHeight/667.0)</span>
</code></pre>
<p>好 适配到此为止.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述是测试短视频 SDK 开发过程中适配 iPhone X 的 一些 case,由于偏于多媒体方向,并不涉及到例如 网络层 如果适配 iPhone X等一些短视频开发过程中并没有遇到的特定问题,可能还有一些遗漏部分,如果发现我会及时更新.</p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171103iPhone-X-Adaptor/say_hello_to_furture
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>论一个优雅的模态转场的自我修养</title>
    <link href="https://www.sunyazhou.com/2017/10/31/20171031Elegant-present-transition/"/>
    <id>https://www.sunyazhou.com/2017/10/31/20171031Elegant-present-transition/</id>
    <published>2017-10-31T03:32:17.000Z</published>
    <updated>2017-10-31T12:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开发过程中虽然 UI 这个活很没技术含量,但有时候还是需要做些的特别的转场效果.本教程参考<a href="https://www.raywenderlich.com/139277/uipresentationcontroller-tutorial-getting-started" target="_blank" rel="external">UIPresentationController Tutorial: Getting Started</a> 这篇博文进行 OC 版翻译 也加入了一些小改动</p>
<blockquote>
<p>swift 点这里下载<a href="https://koenig-media.raywenderlich.com/uploads/2016/08/Medal_Count_Completed.zip" target="_blank" rel="external">demo</a><br>Objective-C 点击这里直达<a href="https://github.com/sunyazhou13/SlideInPresentation" target="_blank" rel="external">demo</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/fd8747d4c220c683f587db45126037b080e5c380/20171031Elegant-present-transition/Elegant-present-transition.gif" alt=""></p>
<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>转场对目前的 iOS 来讲已经不能再熟悉了 但想找个靠谱点的带遮盖的转场 没找到几个靠谱的</p>
<p>不是这个问题不行就那个问题不能满足 </p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171031Elegant-present-transition/demo1.png" alt=""></p>
<p>根据<code>Raywenderrich</code>的教程 我翻译成了 OC 版本 并加了一些小改动 </p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ul>
<li>导入头文件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"SlideInPresentationManager.h"</span></span></div></pre></td></tr></table></figure>
<ul>
<li>声明属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) SlideInPresentationManager *slideInTransitioningDelegate;</div></pre></td></tr></table></figure>
<ul>
<li>弹出模态控制器的时候如下代码</li>
</ul>
<pre><code class="objc">- (<span class="keyword">IBAction</span>)presentAction:(<span class="built_in">UIButton</span> *)sender {
    PresentationDirection direction;
    <span class="keyword">if</span> (sender.tag == <span class="number">100</span>) {
        <span class="built_in">NSLog</span>(<span class="string">@"左侧弹出模态转场"</span>);
        direction = PresentationDirectionLeft;
    } <span class="keyword">else</span> <span class="keyword">if</span> (sender.tag == <span class="number">101</span>) {
        <span class="built_in">NSLog</span>(<span class="string">@"上弹出模态转场"</span>);
        direction = PresentationDirectionTop;
    } <span class="keyword">else</span> <span class="keyword">if</span> (sender.tag == <span class="number">102</span>) {
        <span class="built_in">NSLog</span>(<span class="string">@"右弹出模态转场"</span>);
        direction = PresentationDirectionRight;
    } <span class="keyword">else</span> {
        <span class="built_in">NSLog</span>(<span class="string">@"下弹出模态转场"</span>);
        direction = PresentationDirectionBottom;
    }

    <span class="keyword">self</span>.slideInTransitioningDelegate = <span class="literal">nil</span>;
    <span class="comment">//控制现实遮盖的视图转场(core 代码)</span>
    <span class="keyword">self</span>.slideInTransitioningDelegate = [[SlideInPresentationManager alloc] init];
    <span class="keyword">self</span>.slideInTransitioningDelegate.direction = direction;
    <span class="keyword">self</span>.slideInTransitioningDelegate.disableCompactHeight = <span class="literal">NO</span>;
    <span class="keyword">self</span>.slideInTransitioningDelegate.sliderRate = <span class="number">1.0</span>/<span class="number">3.0</span>;

    <span class="comment">//创建控制器实例</span>
    PresentController *presentVC = [[PresentController alloc] initWithNibName:<span class="string">@"PresentController"</span> bundle:[<span class="built_in">NSBundle</span> mainBundle]];
    presentVC.transitioningDelegate = <span class="keyword">self</span>.slideInTransitioningDelegate;
    presentVC.modalPresentationStyle = <span class="built_in">UIModalPresentationCustom</span>;
    [<span class="keyword">self</span> presentViewController:presentVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];
}
</code></pre>
<p>剩下的就可以愉快的玩耍了 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在开发过程中虽然 UI 这个活很没技术含量,但有时候还是需要做些的特别的转场效果.本教程参考&lt;a href=&quot;https://www.ray
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>markdown嵌入折叠标签</title>
    <link href="https://www.sunyazhou.com/2017/10/25/20171025markdown-skill/"/>
    <id>https://www.sunyazhou.com/2017/10/25/20171025markdown-skill/</id>
    <published>2017-10-25T08:10:35.000Z</published>
    <updated>2017-10-31T12:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>这几天一直在开十九大,导致我的梯子翻墙不好使了,就在此时<a href="https://onevcat.com/2017/10/swift-error-category/" target="_blank" rel="external">喵神发表了一篇博文 关于 Swift Error 的分类</a>  </p>
</blockquote>
<p>每次看喵神的文章就像诸葛亮跟周瑜聊天一样如饮美酒,我不能自比诸葛孔明和周公瑾.</p>
<p>当我仔细看喵神博客的时候发现 原来<code>markdown</code>支持很多<code>html</code>标签的小技巧</p>
<p>比如:</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171025markdown-skill/markdown_skill1.gif" alt="喵神文章中的"></p>
<p>第一眼我震撼了 原来 markdown 里面还能嵌入这么多好玩的 就这个问题 问了一下喵神</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171025markdown-skill/markdown_question.png" alt="与喵神对话"></p>
<p><a href="https://www.w3schools.com/tags/tag_summary.asp" target="_blank" rel="external">简单的 summary tag 而已..</a></p>
<p>于是我测试了一下代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>点击时的区域标题<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> - 测试 测试测试<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> 测试二 测试三 。。。。。 .<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面我们来玩一下试试</p>
<details><br>  <summary>这是孙先生的博客 点击查看更多内容.</summary><br>  <p> 666666 昨天程序员节 是不是被 PM 虐了 QA 提个很多 bug 不想 fix.</p><br>  <p> 昨天一不小心驾照考下来了 耗时2个月 快不快。。。。.</p><br></details>



<p>OK 上边就是我们用到的几行代码 很简单直接嵌入 markdown 编辑器里面就马上出效果</p>
<p>感谢<a href="https://onevcat.com/" target="_blank" rel="external">喵神的指导</a></p>
<p>更多标签相关 可参考<a href="https://www.w3schools.com/tags/tag_summary.asp" target="_blank" rel="external">w3schools</a></p>
<p>全文完 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这几天一直在开十九大,导致我的梯子翻墙不好使了,就在此时&lt;a href=&quot;https://onevcat.com/
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="macOS开发" scheme="https://www.sunyazhou.com/tags/macOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="技巧" scheme="https://www.sunyazhou.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>理解UIView的绘制</title>
    <link href="https://www.sunyazhou.com/2017/10/16/20171016UIView-Rendering/"/>
    <id>https://www.sunyazhou.com/2017/10/16/20171016UIView-Rendering/</id>
    <published>2017-10-16T05:00:30.000Z</published>
    <updated>2017-11-25T08:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171016UIView-Rendering/UIView_rendering%402x.png" alt="UIView渲染"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近研究OpenGL ES相关和 GPU 相关 发现这篇文章很具有参考的入门价值.</p>
<h3 id="理解-UIView-的绘制-UIView-是如何显示到-Screen-上的"><a href="#理解-UIView-的绘制-UIView-是如何显示到-Screen-上的" class="headerlink" title="理解 UIView 的绘制, UIView 是如何显示到 Screen 上的?"></a>理解 UIView 的绘制, UIView 是如何显示到 Screen 上的?</h3><p>首先要从<code>Runloop</code>开始说,iOS 的<code>MainRunloop</code> 是一个60fps 的回调,也就是说16.7ms(毫秒)会绘制一次屏幕,这个时间段内要完成:</p>
<ul>
<li><code>view</code>的缓冲区创建</li>
<li><code>view</code>内容的绘制(如果重写了 drawRect)  </li>
</ul>
<p>这些 <code>CPU</code>的工作.</p>
<p>然后将这个缓冲区交给<code>GPU</code>渲染, 这个过程又包含:</p>
<ul>
<li>多个<code>view</code>的拼接(compositing)</li>
<li>纹理的渲染(Texture)等.</li>
</ul>
<p>最终现实在屏幕上.因此,如果在16.7ms 内完不成这些操作, eg: CPU做了太多的工作, 或者<code>view</code>层次过于多,图片过于大,导致<code>GPU</code>压力太大,就会导致”卡”的现象,也就是 <strong>丢帧</strong>,<strong>掉帧</strong>.</p>
<p>苹果官方给出的最佳帧率是:<strong>60fps</strong>(60Hz),也就是一帧不丢, 当然这是理想中的绝佳体验.</p>
<h3 id="这个60fps该怎么理解呢？"><a href="#这个60fps该怎么理解呢？" class="headerlink" title="这个60fps该怎么理解呢？"></a>这个<code>60fps</code>该怎么理解呢？</h3><p>一般来说如果帧率达到 <code>25+fps</code>(fps &gt;= 25帧以上,不是25加别看错),人眼就基本感觉不到卡顿了,因此,如果你能让你的 iOS 程序<strong>稳定</strong>保持在<code>30fps</code>已经很不错了, 注释,是”稳定”在30fps,而不是, <code>10fps</code>,<code>40fps</code>,<code>20fps</code>这样的跳动,如果帧频不稳就会有卡的感觉,<code>60fps</code>真的很难达到, 尤其是在 iPhone 4/4s等 32bit 位机上,不过现在苹果已经全面放弃32位,支持最低64位会好很多.</p>
<p>总的来说, UIView从绘制到Render的过程有如下几步：</p>
<ul>
<li>每一个<code>UIView</code>都有一个<code>layer</code></li>
<li>每一个<code>layer</code>都有个<code>content</code>,这个<code>content</code>指向的是一块缓存,叫做<strong><code>backing store</code></strong>.  </li>
</ul>
<p><code>UIView</code>的绘制和渲染是两个过程:</p>
<ul>
<li>当<code>UIView</code>被绘制时,CPU执行<code>drawRect</code>，通过<code>context</code>将数据写入<strong><code>backing store</code></strong>  </li>
<li>当<strong><code>backing store</code></strong>写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上.</li>
</ul>
<p>上面提到的从<code>CPU</code>到<code>GPU</code>的过程可用下图表示:</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171016UIView-Rendering/CPU_to_GPU.001.png" alt=""></p>
<p>下面具体来讨论下这个过程</p>
<ul>
<li>CPU bound:</li>
</ul>
<p>假设我们创建一个 UILabel</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">UILabel</span>* label = [[<span class="built_in">UILabel</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">14</span>)];</div><div class="line">label.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">label.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14.0</span>f];</div><div class="line">label.text = <span class="string">@"test"</span>;</div><div class="line">[<span class="keyword">self</span>.view addSubview:label];</div></pre></td></tr></table></figure>
<p>这个时候不会发生任何操作, 由于 UILabel 重写了<code>drawRect</code>方法,因此,这个 <code>View</code>会被 <code>marked as &quot;dirty&quot;</code>:</p>
<p>类似这个样子:</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/179212e7ed967e07c602dbe7eef101c4c5eb7b16/20171016UIView-Rendering/drawRect.png" alt=""></p>
<p>然后一个新的<code>Runloop</code>到来，上面说道在这个<code>Runloop</code>中需要将界面渲染上去，对于<code>UIKit</code>的渲染，Apple用的是它的<code>Core Animation</code>。<br>做法是在Runloop开始的时候调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[<span class="built_in">CATransaction</span> begin]</div></pre></td></tr></table></figure>
<p>在<code>Runloop</code>结束的时候调用  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"></div><div class="line">[<span class="built_in">CATransaction</span> commit]</div></pre></td></tr></table></figure>
<p>在<code>begin</code>和<code>commit</code>之间做的事情是将<code>view</code>增加到<code>view hierarchy</code>中，这个时候也不会发生任何绘制的操作。<br>当<code>[CATransaction commit]</code>执行完后，<code>CPU</code>开始绘制这个<code>view</code>:</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171016UIView-Rendering/CATransaction_commit.png" alt="CPU绘制图"></p>
<p>首先<code>CPU</code>会为<code>layer</code>分配一块内存用来绘制<code>bitmap</code>，叫做<strong><code>backing store</code></strong><br>创建指向这块<code>bitmap</code>缓冲区的指针，叫做<code>CGContextRef</code><br>通过<code>Core Graphic</code>的<code>api</code>，也叫<code>Quartz2D</code>，绘制<code>bitmap</code><br>将<code>layer</code>的<code>content</code>指向生成的<code>bitmap</code><br>清空<code>dirty flag</code>标记<br>这样<code>CPU</code>的绘制基本上就完成了.<br>通过<code>time profiler</code>可以完整的看到个过程：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line"></div><div class="line">Running Time Self Symbol Name</div><div class="line">2.0ms 1.2% 0.0 +[CATransaction flush]</div><div class="line">2.0ms 1.2% 0.0 CA::Transaction::commit()</div><div class="line">2.0ms 1.2% 0.0 CA::Context::commit_transaction(CA::Transaction*)</div><div class="line">1.0ms 0.6% 0.0 CA::Layer::layout_and_display_if_needed(CA::Transaction*)</div><div class="line">1.0ms 0.6% 0.0 CA::Layer::display_if_needed(CA::Transaction*)</div><div class="line">1.0ms 0.6% 0.0 -[CALayer display]</div><div class="line">1.0ms 0.6% 0.0 CA::Layer::display()</div><div class="line">1.0ms 0.6% 0.0 -[CALayer _display]</div><div class="line">1.0ms 0.6% 0.0 CA::Layer::display_()</div><div class="line">1.0ms 0.6% 0.0 CABackingStoreUpdate_</div><div class="line">1.0ms 0.6% 0.0 backing_callback(CGContext*, void*)</div><div class="line">1.0ms 0.6% 0.0 -[CALayer drawInContext:]</div><div class="line">1.0ms 0.6% 0.0 -[UIView(CALayerDelegate) drawLayer:inContext:]</div><div class="line">1.0ms 0.6% 0.0 -[UILabel drawRect:]</div><div class="line">1.0ms 0.6% 0.0 -[UILabel drawTextInRect:]</div></pre></td></tr></table></figure>
<p>假如某个时刻修改了<code>label</code>的<code>text</code>:  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">label.text = <span class="string">@"hello world"</span>;</div></pre></td></tr></table></figure>
<p>由于内容变了,<code>layer</code>的<code>content</code>的<code>bitmap</code>的尺寸也要变化，因此这个时候当新的<code>Runloop</code>到来时，<code>CPU</code>要为<code>layer</code>重新创建一个<code>backing store</code>，重新绘制<code>bitmap</code>.<br><code>CPU</code>这一块最耗时的地方往往在<code>Core Graphic</code>的绘制上，关于<code>Core Graphic</code>的性能优化是另一个话题了，又会牵扯到很多东西，就不在这里讨论了.</p>
<p>GPU bound：</p>
<p><code>CPU</code>完成了它的任务：将<code>view</code>变成了<code>bitmap</code>，然后就是<code>GPU</code>的工作了，<code>GPU</code>处理的单位是<code>Texture</code>.<br>基本上我们控制<code>GPU</code>都是通过<code>OpenGL</code>来完成的，但是从<code>bitmap</code>到<code>Texture</code>之间需要一座桥梁，<code>Core Animation</code>正好充当了这个角色：<br><code>Core Animation</code>对<code>OpenGL</code>的<code>api</code>有一层封装，当我们要渲染的<code>layer</code>已经有了<code>bitmap content</code>的时候，这个<code>content</code>一般来说是一个<code>CGImageRef</code>，<code>CoreAnimation</code>会创建一个<code>OpenGL</code>的<code>Texture</code>并将<code>CGImageRef（bitmap）</code>和这个<code>Texture</code>绑定，通过<code>TextureID</code>来标识。<br>这个对应关系建立起来之后，剩下的任务就是<code>GPU</code>如何将<code>Texture</code>渲染到屏幕上了。<br><code>GPU</code>大致的工作模式如下：</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/8f92ec74bfc31508293f5a6cadcd68ac703eb1a0/20171016UIView-Rendering/GPU_work.png" alt=""></p>
<p>整个过程也就是一件事：</p>
<p><code>CPU</code>将准备好的<code>bitmap</code>放到<code>RAM</code>里，<code>GPU</code>去搬这快内存到<code>VRAM</code>中处理。<br>而这个过程<code>GPU</code>所能承受的极限大概在16.7ms完成一帧的处理，所以最开始提到的60fps其实就是GPU能处理的最高频率.<br>因此，<code>GPU</code>的挑战有两个：</p>
<ul>
<li>将数据从<code>RAM</code>搬到<code>VRAM</code>中</li>
<li>将<code>Texture</code>渲染到屏幕上    </li>
</ul>
<p>这两个中瓶颈基本在第二点上。渲染<code>Texture</code>基本要处理这么几个问题：</p>
<ul>
<li>Compositing:</li>
</ul>
<p><code>Compositing</code>是指将多个纹理拼到一起的过程，对应<code>UIKit</code>，是指处理多个<code>view</code>合到一起的情况，如:  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[<span class="keyword">self</span>.view addsubview : subview]。</div></pre></td></tr></table></figure>
<p>如果<code>view</code>之间没有叠加，那么<code>GPU</code>只需要做普通渲染即可.<br>如果多个<code>view</code>之间有叠加部分，<code>GPU</code>需要做<code>blending</code>.  </p>
<p>加入两个<code>view</code>大小相同，一个叠加在另一个上面，那么计算公式如下：</p>
<p><code>R</code> = <code>S</code>+<code>D</code>*(<code>1</code>-<code>Sa</code>)  </p>
<blockquote>
<p><code>R</code>: 为最终的像素值<br><code>S</code>: 代表 上面的Texture（Top Texture）<br><code>D</code>: 代表下面的Texture(lower Texture)  </p>
</blockquote>
<p>其中<code>S</code>,<code>D</code>都已经<code>pre-multiplied</code>各自的<code>alpha</code>值。<br><code>Sa</code>代表<code>Texture</code>的<code>alpha</code>值。  </p>
<p>假如<code>Top Texture</code>（上层<code>view</code>）的<code>alpha</code>值为<code>1</code>，即不透明。那么它会遮住下层的<code>Texture</code>.<br>即,<code>R</code> = <code>S</code>。是合理的。  </p>
<p>假如<code>Top Texture</code>（上层<code>view</code>）的<code>alpha</code>值为<code>0.5</code>，<br><code>S</code>为<code>(1,0,0)</code>，乘以<code>alpha</code>后为<code>(0.5,0,0）</code>。<br><code>D</code>为<code>(0，0，1)</code>。<br>得到的<code>R</code>为<code>（0.5，0，0.5）</code>。  </p>
<p>基本上每个像素点都需要这么计算一次。  </p>
<p>因此，<code>view</code>的层级很复杂，或者<code>view</code>都是半透明的（<code>alpha</code>值不为<code>1</code>）都会带来<code>GPU</code>额外的计算工作。</p>
<ul>
<li>Size</li>
</ul>
<p>这个问题，主要是处理<code>image</code>带来的，假如内存里有一张<code>400x400</code>的图片，要放到<code>100x100</code>的<code>imageview</code>里，如果不做任何处理，直接丢进去，问题就大了，这意味着，<code>GPU</code>需要对大图进行缩放到小的区域显示，需要做像素点的<code>sampling</code>，这种<code>smapling</code>的代价很高，又需要兼顾<code>pixel alignment</code>。  计算量会飙升。  </p>
<ul>
<li>Offscreen Rendering And Mask</li>
</ul>
<p>如果我们对<code>layer</code>做这样的操作：  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">label.layer.cornerRadius = <span class="number">5.0</span>f;</div><div class="line">label.layer.masksToBounds = <span class="literal">YES</span>;</div></pre></td></tr></table></figure>
<p>会产生<code>offscreen rendering</code>,它带来的最大的问题是，当渲染这样的<code>layer</code>的时候，需要额外开辟内存，绘制好<code>radius，mask</code>，然后再将绘制好的<code>bitmap</code>重新赋值给<code>layer</code>。<br>因此继续性能的考虑，<code>Quartz</code>提供了优化的<code>api</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">label.layer.cornerRadius = <span class="number">5.0</span>f;</div><div class="line">label.layer.masksToBounds = <span class="literal">YES</span>;</div><div class="line">label.layer.shouldRasterize = <span class="literal">YES</span>;</div><div class="line">label.layer.rasterizationScale = label.layer.contentsScale;</div></pre></td></tr></table></figure>
<p>简单的说，这是一种<code>cache</code>机制。<br>同样<code>GPU</code>的性能也可以通过<code>instrument</code>去衡量：</p>
<p><img src="https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/e3fad5583fdd4fd52b11a8fe44a9528b95f8ac1b/20171016UIView-Rendering/rendering_result.png" alt=""></p>
<p>红色代表<code>GPU</code>需要做额外的工作来渲染<code>View</code>，绿色代表<code>GPU</code>无需做额外的工作来处理<code>bitmap</code>。</p>
<p>全文完</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunyazhou13/sunyazhou13.github.io-images/master/20171016UIView-Rendering/UIView_rendering%402
    
    </summary>
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="https://www.sunyazhou.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
